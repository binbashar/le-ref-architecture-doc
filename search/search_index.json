{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2017 - 2020 binbash</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"concepts/","title":"Index","text":""},{"location":"concepts/#concepts","title":"Concepts","text":""},{"location":"concepts/#welcome","title":"Welcome!","text":"<p>Welcome to Leverage's documentation! Here you will find the concepts you need to understand to work with our stack, the steps to try Leverage by yourself, and the extensive documentation about every aspect of our solution.</p>"},{"location":"concepts/#getting-started","title":"Getting Started","text":"<p>Feel free to explore the following pages to know more about Leverage.</p> <ul> <li>  See What is Leverage to fully understand what Leverage is.</li> <li>  See Why Leverage to help you decide whether Leverage is the right tool for you.</li> <li>  See What can Leverage do for you to understand more about the capabilities of Leverage.</li> <li>  See Our Tech Stack to learn about our design choices for the technology stack.</li> </ul>"},{"location":"concepts/next-steps/","title":"Next Steps","text":"<p>Now that you know the basic concepts about Leverage feel free to give it a try or check out the User Guide section to go deeper into the implementation details. Links down below:</p>"},{"location":"concepts/next-steps/#learn-more","title":"Learn More","text":"<p> See Try Leverage to take the tutorial that will help you deploy a basic AWS Landing Zone via Leverage.</p> <p> See User Guide to take the comprehensive route to learn more about Leverage.</p> <p> See Work with us if you want to join us or know more about the team behind Leverage.</p>"},{"location":"concepts/our-tech-stack/","title":"Our Tech Stack","text":"<p>Leverage was built around the AWS Well Architected Framework and it uses a stack that includes Terraform, Ansible, Helm and other tools.</p> <p>We are also adopters and supporters of Kubernetes and the Cloud Native movement, which should become self-evident as you keep exploring our technology stack.</p>"},{"location":"concepts/our-tech-stack/#why-did-we-choose-our-tech-stack","title":"Why did we choose our tech stack?","text":"Why AWS\u2753 <p>Amazon Web Services (AWS) is the world\u2019s most comprehensive and broadly adopted  cloud platform, offering over 200 fully featured services from data centers globally. Millions of customers\u2014including the fastest-growing startups, largest enterprises, and leading government agencies\u2014are using AWS to lower costs, become more agile, and innovate faster.</p> <p>Build, Deploy, and Manage Websites, Apps or Processes On AWS' Secure, Reliable Network. AWS is Secure, Reliable, Scalable Services. HIPAA Compliant. Easily Manage Clusters. Global Infrastructure. Highly Scalable.</p> <p> Read More: What is AWS</p> Why WAF (Well Architected Framework)\u2753 <p>AWS Well-Architected helps cloud architects to build secure, high-performing, resilient, and efficient infrastructure for their applications and workloads. Based on five pillars \u2014 operational excellence, security, reliability, performance efficiency, and cost optimization \u2014 AWS Well-Architected provides a consistent approach for customers and partners to evaluate architectures, and implement designs that can scale over time.</p> <p> Read More: AWS Well-architected</p> Why Infra as Code (IaC) &amp; Terraform\u2753 <ul> <li> <p> Confidence: A change breaks the env? Just roll it back. Still not working? Build a whole new env with a few keystrokes. IaC enables this.</p> </li> <li> <p> Repeatability: Allows your infra to be automatically instantiated, making it easy to build multiple identical envs.</p> </li> <li> <p> Troubleshooting: Check source control and see exactly what changed in the env.  As long as you are diligent and don\u2019t make manual envs changes, then IaC can be a game changer.</p> </li> <li> <p> DR: Require the ability to set up an alternate env in a different DC or Region. IaC makes this a much more manageable prospect.</p> </li> <li> <p> Auditability: You will need to be able to audit both changes and access to an env, IaC gives you this right out of the box.</p> </li> <li> <p> Visibility: As an env expands over time, is challenging to tell what has been provisioned. In the #cloud this can be a huge #cost issue. IaC allows tracking your resources.</p> </li> <li> <p> Portability: Some IaC techs are #multicloud. Also, translating #Terraform from one cloud provider to another is considerably more simple than recreating your entire envs in a cloud-specific tool.</p> </li> <li> <p> Security: See history of changes to your SG rules along with commit messages can do wonders for being confident about the security configs of your envs.</p> </li> </ul> <p>Terraform allows to codify your application infrastructure, reduce human error and  increase automation by provisioning infrastructure as code. With TF we can manage infrastructure across clouds and provision infrastructure  across 300+ public clouds and services using a single workflow. Moreover it helps to create reproducible infrastructure and provision consistent testing, staging, and production environments with the same configuration.</p> <p>Terraform has everything we expect from a IaC framework: open source, cloud-agnostic provisioning tool that supported immutable infrastructure, a declarative language, and a client-only architecture.</p> <p> Read More</p> <ul> <li>Why Infrastructure as Code</li> <li>Why Terraform by Gruntwork</li> </ul> Why Organizations\u2753 <p>AWS Organizations helps you centrally manage and govern your environment as you grow and scale your AWS resources. Using AWS Organizations, you can programmatically create new AWS accounts and allocate resources, group accounts to organize your workflows, apply policies to accounts or groups for governance, and simplify billing by using a  single payment method for all of your accounts.</p> <p> Read More </p> <ul> <li>How it works: AWS Organizations</li> <li>AWS Organizations</li> </ul> Why IAM and roles\u2753 <p>AWS Identity and Access Management (IAM) enables you to manage access to AWS services and resources securely. Using IAM, you can create and manage AWS users and groups, and use permissions to allow and deny their access to AWS resources.</p> <ul> <li>Integration and Fine-grained access control with almost every AWS service and its resources.</li> <li>Multi-factor authentication for highly privileged users.</li> <li>Analyze, monitor and audit access.</li> </ul> <p> Read More </p> <ul> <li>How it works: AWS IAM</li> <li>AWS Identity and Access Management (IAM)</li> </ul> Security | Why Web Application Firewall (WAF), Cloud Trail, Config, Guarduty\u2753 <p>Raise your security posture with AWS infrastructure and services. Using AWS, you will gain the control and confidence you need to securely run your business with the most flexible and secure cloud computing environment available today. As an AWS customer, you will benefit from AWS data centers and a network architected to protect your information, identities, applications, and devices. With AWS, you can improve your ability to meet core security and compliance requirements, such as data locality, protection, and confidentiality with our comprehensive services and features.</p> <p> Read More </p> <ul> <li>How it works: AWS Security</li> <li>AWS Cloud Security</li> </ul> Why VPC\u2753 <p>Amazon Virtual Private Cloud (Amazon VPC) is a service that lets you launch AWS resources in a logically isolated virtual network that you define. You have complete control over your virtual networking environment, including selection of your own IP address range, creation of subnets, and configuration of route tables and network gateways. You can use both IPv4 and IPv6 for most resources in your virtual private cloud, helping to ensure secure and easy access to resources and applications.</p> <p> Read More </p> <ul> <li>How it works: AWS Networking</li> <li>AWS Virtual Private Cloud</li> </ul> Why Kubernetes (K8s) &amp; AWS EKS\u2753 <p>Kubernetes, also known as K8s, is an open-source system for automating deployment, scaling, and management of containerized applications. It groups containers that make up an application into logical units for easy management and discovery. Kubernetes builds upon 15 years of experience of running production workloads at Google, combined with best-of-breed ideas and practices from the community.</p> <p>Amazon Elastic Kubernetes Service (Amazon EKS) gives you the flexibility to start, run, and scale Kubernetes applications in the AWS cloud or on-premises. Amazon EKS helps you provide highly-available and secure clusters and automates key tasks such as patching, node provisioning, and updates. Customers such as Intel, Snap, Intuit, GoDaddy, and Autodesk trust EKS to run their most sensitive and mission critical applications.</p> <p>EKS runs upstream Kubernetes and is certified Kubernetes conformant for a predictable experience. You can easily migrate any standard Kubernetes application to EKS without  needing to refactor your code.</p> <p> Read More </p> <ul> <li>How it works: AWS EKS</li> <li>AWS EKS</li> <li>Kubernetes</li> </ul> Why S3\u2753 <p>Amazon Simple Storage Service (Amazon S3) is an object storage service that offers industry-leading scalability, data availability, security, and performance.  This means customers of all sizes and industries can use it to store and protect any amount of data for a range of use cases, such as data lakes, websites, mobile applications, backup and restore, archive, enterprise applications, IoT devices, and big data analytics. Amazon S3 provides easy-to-use management features so you can organize your data and configure finely-tuned access controls to meet your specific business, organizational, and compliance requirements. Amazon S3 is designed for 99.999999999% (11 9's) of durability, and stores data for millions of applications for companies all around the world.</p> <p> Read More </p> <ul> <li>How it works: AWS Storage</li> <li>AWS S3</li> </ul> Why RDS\u2753 <p>Amazon Relational Database Service (Amazon RDS) makes it easy to set up, operate, and scale a relational database in the cloud. It provides cost-efficient and resizable capacity while automating time-consuming administration tasks such as hardware provisioning, database setup, patching and backups. It frees you to focus on your applications so you can give them the fast performance, high availability, security and compatibility they need.</p> <p>Amazon RDS is available on several database instance types - optimized for memory, performance or I/O - and provides you with six familiar database engines to choose from, including Amazon Aurora, PostgreSQL, MySQL, MariaDB, Oracle Database, and SQL Server. You can use the AWS Database Migration Service to easily migrate or replicate your existing databases to Amazon RDS.</p> <p> Read More </p> <ul> <li>How it works: AWS Databases</li> <li>AWS RDS</li> </ul> Why Hashicorp Vault\u2753 <p>As many organizations migrate to the public cloud, a major concern has been how to best secure data, preventing it from unauthorized access or exfiltration.</p> <p>Deploying a product like HashiCorp Vault gives you better control of your sensitive credentials and helps you meet cloud security standards.</p> <p>HashiCorp Vault is designed to help organizations manage access to secrets and transmit them safely within an organization. Secrets are defined as any form of sensitive credentials that need to be tightly controlled and monitored and can be used to unlock sensitive information. Secrets could be in the form of passwords, API keys, SSH keys, RSA tokens, or OTP.</p> <p>HashiCorp Vault makes it very easy to control and manage access by providing you with a unilateral interface to manage every secret in your infrastructure. Not only  that, you can also create detailed audit logs and keep track of who accessed what.</p> <p>Manage Secrets and Protect Sensitive Data. Secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API.</p> <p> Read More </p> <ul> <li>How it works: Secrets</li> <li>Hashicorp Vault Project</li> </ul>"},{"location":"concepts/what-is-leverage/","title":"What is Leverage?","text":"<p>Leverage was made out of a significant amount of knowledge, acquired through several years of experience, turned into an ecosystem of code, tools, and workflows that enables you to build the AWS infrastructure for your applications and services quickly and securely.</p> <p>Since all the code and modules are already built, we can get you up and running up to 10x faster   than a consulting company --  typically in just a few weeks! -- and on top of code that is thoroughly documented, tested, and has been proven in production at dozens of other project deployments.</p>"},{"location":"concepts/what-is-leverage/#core-components","title":"Core Components","text":"<p>Our focus is on creating reusable, high quality  Cloud Infrastructure code, through our core components:</p> <ul> <li> <p> Reference Architecture: Designed under optimal configs for the most popular modern web and mobile applications needs. Its design is fully based on the AWS Well Architected Framework.</p> </li> <li> <p> Infrastructure as Code (IaC) Library: A collection of reusable, tested, production-ready E2E AWS Cloud infrastructure as code solutions, leveraged by modules written in: Terraform, Ansible, Helm charts, Dockerfiles and Makefiles.</p> </li> <li> <p> Leverage CLI: projects' command line tool. Provides the means to interact and deploy Leverage Reference Architecture on AWS and if needed it allows you to define custom tasks to run.</p> </li> </ul>"},{"location":"concepts/what-is-leverage/#video-presentation","title":"Video Presentation","text":"<p>Check out this intro video  that explains what Leverage is in less than 5 minutes:</p>"},{"location":"concepts/what-leverage-can-do-for-you/","title":"What can Leverage do for you?","text":"<p>Still not convinced? Check out the following sections which describe what Leverage can bring on the table depending on your role in a company.</p>"},{"location":"concepts/what-leverage-can-do-for-you/#leverage-for-cios-ctos-and-vps-of-engineering","title":"Leverage for CIOs, CTOs and VPs of Engineering","text":"Accelerate development and optimize costs <p>Annual cost savings are a new standard and best practice. Profits are being targeted to business development, regulatory and compliance needs. Resulting in a reduction of pressure on IT and development budgets, granting the opportunity to focus in new features and boost innovation.</p> Modernize applications architecture (loosely coupled and modular) <p>Strategically decompose the monolith into a fine-grained, loosely coupled modular architecture to increase both  development and business agility. When the system architecture is designed to allow teams to test, deploy and change systems without relying on other teams, they require little communication to get the job done.  In other words, both the architecture and the teams are loosely coupled.</p> Innovation - Rapidly adopt new technologies and reduce development time <p>Use Leverage Reference Architecture and for AWS + our libraries to provide a collection of cloud application architecture components to build and deploy faster in the cloud. Building a cloud Landing Zone is complex,  especially since most companies have little or no expertise in this area. And it can take a significant amount  of time to get it right. Leverage a reference architecture to give you an AWS Landing Zone that provides a  consistent and solid \"foundations\" to bootstrap your project in the cloud. The code solution implements the best  AWS Well-Architected Framework practices as well as the battle-tested tech experience and years of knowledge of our contributors.</p> Hours or days, not weeks or months <p>Leverage implements infrastructure as code at all times. We have rolled this out using Terraform, and has been fully proven in AWS and other Terraform providers that are part of our reference architecture like Kubernetes, Helm and Hashicorp Vault. By using the <code>Leverage CLI</code>, our binary will help you to quickly bootstrap your AWS Landing Zone in a matter of hours (or at most a few days).</p> It's not just a pile of scripts <p>It's not just another layer of untested, one time and stand-alone developed scripts. The code is modularized and well designed under best practices, our <code>Leverage CLI</code> has both unit and integration tests. While our Terraform code has been extensively E2E tested. Moreover, 100% of the code is yours (to modify, extend, reuse, etc), with no vendor locking and vendor licensing fees. We use the MIT license, so you can take the code, modify it and use it as your private code. All we ask in return is a friendly greeting and that (if possible) consider contributing to binbash Leverage project. Implement Leverage yourself or we  can deploy it for you!</p> DevOps culture and methodologies <p>Team agility and continuous improvements based on feedback loops are some of the main drivers of cloud adoption, and IAC's goal of reducing the frequency of deployment of both infrastructure and applications are some of the most important aspects of DevOps practices. We continue to apply these methodologies to achieve a DevOps first culture. We have experienced and demonstrated their potential and have practiced them in dozens of projects over the past 5 years. The Leverage reference architecture for AWS combines a set of application best practices, technology patterns and a common CI/CD deployment approach through <code>Leverage CLI</code> for all your application environments. As a result, we are pursuing a world-class software delivery performance through optimized collaboration, communication, reliability, stability, scalability and security at ever-decreasing cost and effort.</p> Repeatable, composable and extensible immutable infrastructure <p>The best high-performance development teams create and recreate their development and production environments using infrastructure as code (IaC) as part of their daily development processes. The <code>Leverage CLI</code> allows to build repeatable and immutable infrastructure. So your cloud development, staging and production environments will consistently be the same.</p>"},{"location":"concepts/what-leverage-can-do-for-you/#leverage-for-devops-engineers-cloud-architects-and-software-engineers","title":"Leverage for DevOps Engineers, Cloud Architects and Software Engineers","text":"Provisioning infrastructure as code (Iac) <p>Instead of manually provisioning infrastructure, the real benefits of cloud adoption come from orchestrating infrastructure through code. However, this is really challenging to achieve, there are literally thousands of tiny things and configs to consider and they all seem to take forever. Our experience is that it can take teams up to 24 months to achieve a desired infra state in AWS. By using Leverage you could get your AWS Landing-Zone in few weeks, or your entire AWS Well-Architected based cloud solution within 1 to 3 months (depending on your project complexity needs).</p> We've done it before (don't reinvent the wheel) <p>Often, development teams have similar and recurring requests such as: iam, networking, security, storage,  databases, compute and secret management, etc. binbash Leverage has been proven in dozen of project to create software-defined (IaC) AWS environments.</p> Best practices baked in the code <p>Leverage provides IaC reference architecture for AWS hosted applications infrastructure. This is baked into the code as a combination of the best AWS Well-Architected framework practices and the experience of having successfully orchestrated many customers to AWS cloud.</p> On-demand infra deployment <p>Leverage provides your DevOps, Cloud, SRE and Development teams with the ability to provision on-demand infrastructure, granting that it will meet the rigorous security requirements of modern cloud native best practices.  It fully implements AWS Well-Architected Framework (WAF) and best DevOps practices, including practices, including collaboration, version control, CI/CD, continuous testing, cloud infrastructure and losely couple architectures.</p> Easier to support and maintain <p>Leverage IaC approach significantly reduce your AWS infra deployment, config and support burden and reduce risk.  Our code backed provisioning has been rigorously tested many times, eliminating the possibility of manual errors.  Because the entire infrastructure is deployed from the same proven code, the consistency your cloud environments will simplify your setup and maintenance. Use the versioned code to iterate and improve, extend or compose your internal processes as your cloud operating model evolves.</p> There is no vendor lock-in. You own the solution <p>With Leverage you own 100% of the code with no lock-in clauses. If you choose to leave Leverage, you will still  have your entire AWS cloud infrastructure that you can access and manage. If you drop Leverage, you will still have your entire cloud native infrastructure code (Terraform, Helm, Ansible, Python). It\u2019s 100% Open Source on GitHub and is free to use with no strings attached under MIT license  (no licensing fees), and you are free to commercially and privately use, distribute and modify.</p> Consistent environments (Dev/prod parity) <p>Keep development, staging, and production cloud envs parity. Infrastructure as code allow us to define and provisioning all infrastructure components (think networks, load  balancers, databases, security, compute and storage, etc.) using code. Leverage uses Terraform as the IaC language, to deploy and setup all the AWS, Kubernetes and Hashicorp Vault resources (it has support for multiple cloud and technology providers). Backed by code, your cloud environments are built exactly the identical way all the time.  Finally, this will result in no differences between development, staging and production.</p> Development in production like envs <p>IaC allows your development team to deploy and test the AWS infrastructure as if it were application code.  Your development is always done in production-like environments. Provision your cloud test and sandbox  environments on demand and tear them down when all your testing is complete. Leverage takes all the pain out of maintaining production-like environments, with stable infra releases. It eliminates the unpredictability of wondering if what actually worked in your development envs will work in production.</p>"},{"location":"concepts/why-leverage/","title":"Why Leverage?","text":"<p>By implementing our Reference Architecture for AWS and the Infrastructure as Code (IaC) Library via Leverage CLI, you will get your entire Cloud Native Application Infrastructure deployed in only a few weeks.</p> <p>Did you know?</p> <p>You can roll out Leverage by yourself or we can implement it for you! </p>"},{"location":"concepts/why-leverage/#the-problem-and-our-solution","title":"The problem and our solution","text":""},{"location":"concepts/why-leverage/#what-are-the-problems-you-might-be-facing","title":"What are the problems you might be facing?","text":"Figure: Why Leverage? The problem. (Source: binbash, \"Leverage Presentation: Why you should use Leverage?\", accessed June 15th 2021)."},{"location":"concepts/why-leverage/#what-is-our-solution","title":"What is our solution?","text":"Figure: Why Leverage? The solution. (Source: binbash, \"Leverage Presentation: Why you should use Leverage?\", accessed June 15th 2021)."},{"location":"es/bienvenido/","title":"Bienvenido","text":""},{"location":"es/bienvenido/#proximamente","title":"Pr\u00f3ximamente","text":""},{"location":"how-it-works/ref-architecture/","title":"How it works","text":""},{"location":"how-it-works/ref-architecture/#how-it-works","title":"How it works","text":"<p>The objective of this document is to explain how the binbash Leverage Reference Architecture for AWS works, in particular how the Reference Architecture model is built and why we need it.</p>"},{"location":"how-it-works/ref-architecture/#overview","title":"Overview","text":"<p>This documentation contains all the guidelines to create binbash  Leverage Reference Architecture for AWS that will be implemented on the  Projects\u2019 AWS infrastructure.</p> <p>We're assuming you've already have in place your AWS Landing Zone based on the First Steps guide. </p> <p>Our Purpose</p> <ul> <li> Democratize advanced technologies: As complex as it may sound, the basic idea behind this design principle is  simple. It is not always possible for a business to maintain a capable in-house IT department while staying up to date. It is entirely feasible to set up your own cloud computing ecosystem from scratch without experience, but that would take a considerable amount of resources; it is definitely not the most efficient way to go. </li> <li> An efficient business-minded way to go is to employ AWS as a service allows organizations to benefit from the advanced technologies integrated into AWS without learning, researching, or creating teams specifically for those technologies.</li> </ul> <p>Info</p> <p>This documentation will provide a detailed reference of the tools and techs used,  the needs they address and how they fit with the multiple practices we will be implementing.</p>"},{"location":"how-it-works/ref-architecture/considerations/","title":"Considerations","text":""},{"location":"how-it-works/ref-architecture/considerations/#important-considerations","title":"Important Considerations","text":"<p>Assumptions</p> <ul> <li> AWS Regions: Multi Region setup \u2192 1ry: us-east-1 (N. Virginia) &amp; 2ry: us-west-2 (Oregon).</li> <li> Repositories &amp; Branching Strategy <ul> <li>DevOps necessary repositories will be created. Consultant will use a trunk-based branching strategy with short-lived feature branches (<code>feature/ID-XXX</code> -&gt; `master), and members from either the Consultant or the Client will be reviewers of every code delivery to said  repositories (at least 1 approver per Pull Request). </li> <li>Infra as code deployments should run from the new <code>feature/ID-XXX</code> or <code>master</code> branch. <code>feature/ID-XXX</code> branch must be merged immediately (ASAP) via PR to the <code>master</code> branch.</li> <li> Consideration: validating that the changes within the code will only affect the desired target resources is the responsibility of the executor (to ensure everything is OK please consider exec after review/approved PR).  </li> </ul> </li> <li> Infra as Code + GitOps <ul> <li>After deployment via IaC (Terraform, Ansible &amp; Helm) all subsequent changes will be performed via versioned controlled code, by modifying the corresponding repository and running the proper IaC Automation execution. </li> <li>All AWS resources will be deployed via Terraform and rarely occasional CloudFormation, Python SDK &amp; AWS CLI when the resource is not defined by Terraform (almost none scenario). All code and scripts will be included in the repository. We'll start the process via Local Workstations. Afterwards full exec automation will be considered via: Github Actions,  ,Gitlab Pipelines or equivalent preferred service. </li> <li> Consideration: Note that any change manually performed will generate inconsistencies on the deployed resources    (which left them out of governance and support scope).</li> </ul> </li> <li> Server OS provisioning: Provisioning via Ansible for resources that need to be provisioned on an OS.</li> <li> Containers Orchestration: Orchestration via Terraform + Helm Charts for resources that need to be      provisioned in Kubernetes (with Docker as preferred container engine).</li> <li> Pre-existing AWS Accounts: All resources will be deployed in several new AWS accounts created inside the Client AWS Organization.      Except for the AWS Legacy Account invitation to the AWS Org and OrganizationAccountAccessRole creation in it,      there will be no intervention whatsoever in Client Pre-existing accounts, unless required by Client      authority and given a specific requirement.</li> </ul> <p>Info</p> <p>We will explore the details of all the relevant Client application stacks, CI/CD processes,  monitoring, security, target service level objective (SLO) and others in a separate document.</p>"},{"location":"try-leverage/","title":"Index","text":""},{"location":"try-leverage/#try-leverage","title":"Try Leverage","text":""},{"location":"try-leverage/#before-you-begin","title":"Before you begin","text":"<p>The objective of this guide is to introduce you to our binbash Leverage Reference Architecture for AWS workflow  through the complete deployment of a basic landing zone configuration.</p> <p>The Leverage Landing Zone is the smallest possible fully functional configuration.  It lays out the base infrastructure required to manage the environment: billing and financial management, user management, security enforcement, and shared services and resources. Always following the best practices layed out by the AWS Well-Architected Framework  to ensure quality and to provide a solid base to build upon. This is the starting point from which any Leverage user can and will develop all the features and capabilities they may require to satisfy their specific needs.</p> <p></p> Figure: Leverage Landing Zone architecture components diagram."},{"location":"try-leverage/#about-this-guide","title":"About this guide","text":"<p>In this guide you will learn how to:</p> <ul> <li> Create and configure your AWS account.</li> <li> Work with the Leverage CLI to manage your credentials, infrastructure and the whole Leverage stack.</li> <li> Prepare your local environment to manage a Leverage project.</li> <li> Orchestrate the project's infrastructure.</li> <li> Configure your users' credentials to interact with the project.</li> </ul> <p>Upon completion of this guide you will gain an understanding of the structure of a project as well as familiarity with the tooling used to manage it.</p> <p>To begin your journey into creating your first Leverage project, continue to the next section of the guide where you will start by setting up your AWS account.</p>"},{"location":"try-leverage/add-aws-accounts/","title":"Add more AWS Accounts","text":""},{"location":"try-leverage/add-aws-accounts/#brief","title":"Brief","text":"<p>You can add new AWS accounts to your Leverage project by following the steps in this page.</p> <p>Important</p> <p>In the examples below, we will be using <code>apps-prd</code> as the account we will be adding and it will be created in the <code>us-east-1</code> region.</p>"},{"location":"try-leverage/add-aws-accounts/#create-the-new-account-in-your-aws-organization","title":"Create the new account in your AWS Organization","text":"<ol> <li>Go to <code>management/global/organizations</code>.</li> <li>Edit the <code>locals.tf</code> file to add the account to the local <code>accounts</code> variable.     <pre><code>    accounts = {\n...\n...\napps-prd = {\nemail     = \"aws+apps-prd@yourcompany.com\",\nparent_ou = \"apps\"\n}\n}\n</code></pre>     Note that the <code>apps</code> organizational unit (OU) is being used as the parent OU of the new account. If you need to use a new OU you can add it to <code>organizational_units</code> variable in the same file.</li> <li>Run the Terraform workflow to apply the new changes. Typically that would be this:     <pre><code>leverage terraform init\nleverage terraform apply\n</code></pre></li> </ol> <p>Authentication error</p> <p>Note this layer was first applied before using the boostrap user. Now, that we are working with SSO, credentials have changed. So, if this is the first account you add you'll probably get this error applying: \"Error: error configuring S3 Backend: no valid credential sources for S3 Backend found.\" In this case running <code>leverage tf init -reconfigure</code> will fix the issue.</p> <ol> <li> <p>Add the new account to the <code>&lt;project&gt;/config/common.tfvars</code> file. The new account ID should have been displayed in the output of the previous step, e.g.:    <pre><code>aws_organizations_account.accounts[\"apps-prd\"]: Creation complete after 14s [id=999999999999]\n</code></pre> Note the id, <code>999999999999</code>.</p> <p>...so please grab it from there and use it to update the file as shown below: <pre><code>accounts = {\n\n[...]\n\napps-prd = {\nemail = \"&lt;aws+apps-prd@yourcompany.com&gt;\",\n        id    = \"&lt;add-the-account-id-here&gt;\"\n}\n}\n</code></pre> 5. Since you are using SSO in this project, permissions on the new account must be granted before we can move forward. Add the right permissions to the <code>management/global/sso/account_assignments.tf</code> file. For the example: <pre><code> # -------------------------------------------------------------------------\n# apps-prd account\n# -------------------------------------------------------------------------\n{\naccount             = var.accounts.apps-prd.id,\npermission_set_arn  = module.permission_sets.permission_sets[\"Administrator\"].arn,\npermission_set_name = \"Administrator\",\nprincipal_type      = local.principal_type_group\nprincipal_name      = local.groups[\"administrators\"].name\n},\n{\naccount             = var.accounts.apps-prd.id,\npermission_set_arn  = module.permission_sets.permission_sets[\"DevOps\"].arn,\npermission_set_name = \"DevOps\",\nprincipal_type      = local.principal_type_group\nprincipal_name      = local.groups[\"devops\"].name\n},\n</code></pre> Note your needs can vary, these permissions are just an example, please be careful with what you are granting here.</p> <p>Apply these changes: <pre><code>leverage terraform apply\n</code></pre> And you must update your AWS config file accordingly by running this: <pre><code>leverage aws configure sso\n</code></pre></p> </li> </ol> <p>Good! Now you are ready to create the initial directory structure for the new account. The next section will guide through those steps.</p>"},{"location":"try-leverage/add-aws-accounts/#create-and-deploy-the-layers-for-the-new-account","title":"Create and deploy the layers for the new account","text":"<p>In this example we will create the <code>apps-prd</code> account structure by using the <code>shared</code> as a template.</p>"},{"location":"try-leverage/add-aws-accounts/#create-the-initial-directory-structure-for-the-new-account","title":"Create the initial directory structure for the new account","text":"<ol> <li>Ensure you are at the root of this repository</li> <li>Now create the directory structure for the new account:     <pre><code>mkdir -p apps-prd/{global,us-east-1}\n</code></pre></li> <li>Set up the config files:<ol> <li>Create the config files for this account:      <pre><code>cp -r shared/config apps-prd/config\n</code></pre></li> <li>Open <code>apps-prd/config/backend.tfvars</code> and replace any occurrences of <code>shared</code> with <code>apps-prd</code>.</li> <li>Do the same with <code>apps-prd/config/account.tfvars</code></li> </ol> </li> </ol>"},{"location":"try-leverage/add-aws-accounts/#create-the-terraform-backend-layer","title":"Create the Terraform Backend layer","text":"<ol> <li> <p>Copy the layer from an existing one:     <pre><code>cp -r shared/us-east-1/base-tf-backend apps-prd/us-east-1/base-tf-backend\n</code></pre></p> <p>Info</p> <p>If the source layer was already initialized you should delete the previous Terraform setup using <code>sudo rm -rf .terraform*</code> in the target layer's directory, e.g. <code>rm -rf apps-prd/us-east-1/base-tf-backend/.terraform*</code></p> </li> <li> <p>Go to the <code>apps-prd/us-east-1/base-tf-backend</code> directory, open the <code>config.tf</code> file and comment the S3 backend block. E.g.:     <pre><code>#backend \"s3\" {\n#    key = \"shared/tf-backend/terraform.tfstate\"\n#}\n</code></pre>     We need to do this for the first apply of this layer.</p> </li> <li> <p>Now run the Terraform workflow to initialize and     apply this layer. The flag <code>--skip-validation</code> is needed here since the bucket does not yet exist.     <pre><code>leverage terraform init --skip-validation\nleverage terraform apply\n</code></pre></p> </li> <li>Open the <code>config.tf</code> file again uncommenting the block commented before and replacing <code>shared</code> with <code>apps-prd</code>. E.g.:     <pre><code>backend \"s3\" {\nkey = \"apps-prd/tf-backend/terraform.tfstate\"\n}\n</code></pre></li> <li>To finish with the backend layer, re-init to move the <code>tfstate</code> to the new location. Run:     <pre><code>leverage terraform init\n</code></pre>     Terraform will detect that you are trying to move from a local to a remote state and will ask for confirmation.     <pre><code>Initializing the backend...\nAcquiring state lock. This may take a few moments...\nDo you want to copy existing state to the new backend?\n    Pre-existing state was found while migrating the previous \"local\" backend to the\n    newly configured \"s3\" backend. No existing state was found in the newly\n    configured \"s3\" backend. Do you want to copy this state to the new \"s3\"\nbackend? Enter \"yes\" to copy and \"no\" to start with an empty state.\n\n    Enter a value: </code></pre>     Enter <code>yes</code> and hit enter.</li> </ol>"},{"location":"try-leverage/add-aws-accounts/#create-the-security-base-layer","title":"Create the <code>security-base</code> layer","text":"<ol> <li> <p>Copy the layer from an existing one:     From the repository root run:      <pre><code>cp -r shared/us-east-1/security-base apps-prd/us-east-1/security-base\n</code></pre></p> <p>Info</p> <p>If the source layer was already initialized you should delete the previous Terraform setup using <code>sudo rm -rf .terraform*</code> in the target layer's directory, e.g. <code>rm -rf apps-prd/us-east-1/security-base/.terraform*</code></p> </li> <li> <p>Go to the <code>apps-prd/us-east-1/security-base</code> directory and open the <code>config.tf</code> file replacing any occurrences of <code>shared</code> with <code>apps-prd</code>     E.g. this line should be:     <pre><code>backend \"s3\" {\nkey = \"apps-prd/security-base/terraform.tfstate\"\n}\n</code></pre></p> </li> <li> <p>Init and apply the layer</p> <pre><code>leverage tf init\nleverage tf apply\n</code></pre> </li> </ol>"},{"location":"try-leverage/add-aws-accounts/#create-the-network-layer","title":"Create the <code>network</code> layer","text":"<ol> <li> <p>Copy the layer from an existing one:     From the root of the repository run this:      <pre><code>cp -r shared/us-east-1/base-network apps-prd/us-east-1/base-network\n</code></pre></p> <p>Info</p> <p>If the source layer was already initialized you should delete the previous Terraform setup using <code>sudo rm -rf .terraform*</code> in the target layer's directory, e.g. <code>rm -rf apps-prd/us-east-1/base-network/.terraform*</code></p> </li> <li> <p>Go to the <code>apps-prd/us-east-1/base-network</code> directory and open the <code>config.tf</code> file replacing any occurrences of <code>shared</code> with <code>apps-prd</code>. E.g. this line should be:     <pre><code>backend \"s3\" {\nkey = \"apps-prd/network/terraform.tfstate\"\n}\n</code></pre></p> </li> <li> <p>Open the file <code>locals.tf</code> and set the new account's CIDRs.     <pre><code>vpc_cidr_block = \"172.19.0.0/20\"\nazs = [\n\"${var.region}a\",\n\"${var.region}b\",\n#\"${var.region}c\",\n#\"${var.region}d\",\n]\n\nprivate_subnets_cidr = [\"172.19.0.0/21\"]\nprivate_subnets = [\n\"172.19.0.0/23\",\n\"172.19.2.0/23\",\n#\"172.19.4.0/23\",\n#\"172.19.6.0/23\",\n]\n\npublic_subnets_cidr = [\"172.19.8.0/21\"]\npublic_subnets = [\n\"172.19.8.0/23\",\n\"172.19.10.0/23\",\n#\"172.19.12.0/23\",\n#\"172.19.14.0/23\",\n]\n</code></pre>     Note here only two AZs are enabled, if needed uncomment the other ones in the three structures.</p> <p>Do not overlap CIDRs!</p> <p>Be careful when chosing CIDRs. Avoid overlaping CIDRs between accounts. If you need a reference on how to chose the right CIDRs, please see here.</p> <p>Calculate CIDRs</p> <p>To calculate CIDRs you can check this playbook.</p> </li> <li> <p>Init and apply the layer     <pre><code>leverage tf init\nleverage tf apply\n</code></pre></p> </li> <li> <p>Create the VPC Peering between the new account and the VPC of the Shared account. Edit file <code>shared/us-east-1/base-network/config.tf</code> and add provider and remote state for the created account.     <pre><code>provider \"aws\" {\nalias                   = \"apps-prd\"\nregion                  = var.region\nprofile                 = \"${var.project}-apps-prd-devops\"\n}\n\ndata \"terraform_remote_state\" \"apps-prd-vpcs\" {\nfor_each = {\nfor k, v in local.apps-prd-vpcs :\nk =&gt; v if !v[\"tgw\"]\n}\n\nbackend = \"s3\"\n\nconfig = {\nregion  = lookup(each.value, \"region\")\nprofile = lookup(each.value, \"profile\")\nbucket  = lookup(each.value, \"bucket\")\nkey     = lookup(each.value, \"key\")\n}\n}\n</code></pre>     Edit file <code>shared/us-east-1/base-network/locals.tf</code> and under      <pre><code>#\n# Data source definitions\n#\n</code></pre>     ...add the related structure:     <pre><code>#\n# Data source definitions\n#\napps-prd-vpcs = {\napps-prd-base = {\nregion  = var.region\nprofile = \"${var.project}-apps-prd-devops\"\nbucket  = \"${var.project}-apps-prd-terraform-backend\"\nkey     = \"apps-prd/network/terraform.tfstate\"\ntgw     = false\n}\n}\n</code></pre>     Edit file <code>shared/us-east-1/base-network/vpc_peerings.tf</code> (if this is your first added account the file won\u00b4t exist, please crate it) and add the peering definition:     <pre><code>#\n# VPC Peering: AppsPrd VPC =&gt; Shared VPC\n#\nmodule \"vpc_peering_apps_prd_to_shared\" {\nsource = \"github.com/binbashar/terraform-aws-vpc-peering.git?ref=v6.0.0\"\n\nfor_each = {\nfor k, v in local.apps-prd-vpcs :\nk =&gt; v if !v[\"tgw\"]\n}\n\nproviders = {\naws.this = aws\naws.peer = aws.apps-prd\n}\n\nthis_vpc_id = module.vpc.vpc_id\npeer_vpc_id = data.terraform_remote_state.apps-prd-vpcs[each.key].outputs.vpc_id\n\nthis_rts_ids = concat(module.vpc.private_route_table_ids, module.vpc.public_route_table_ids)\npeer_rts_ids = concat(\ndata.terraform_remote_state.apps-prd-vpcs[each.key].outputs.public_route_table_ids,\ndata.terraform_remote_state.apps-prd-vpcs[each.key].outputs.private_route_table_ids\n)\n\nauto_accept_peering = true\n\ntags = merge(local.tags, {\n\"Name\"             = \"${each.key}-to-shared\",\n\"PeeringRequester\" = each.key,\n\"PeeringAccepter\"  = \"shared\"\n})\n}\n</code></pre>     Apply the changes (be sure to CD into <code>shared/us-east-1/base-network</code> layer for doing this):     <pre><code>leverage terraform init\nleverage terraform apply\n</code></pre></p> </li> </ol>"},{"location":"try-leverage/add-aws-accounts/#done","title":"Done!","text":"<p>That should be it. At this point you should have the following:</p> <ol> <li>A brand new AWS account in your AWS organization.</li> <li>Working configuration files for both existing layers and any new layer you add in the future.</li> <li>A remote Terraform State Backend for this new account.</li> <li>Roles and policies (SSO) that are necessary to access the new account.</li> <li>The base networking resources ready to host your compute services.</li> <li>The VPC peerings between the new account and shared</li> </ol>"},{"location":"try-leverage/add-aws-accounts/#next-steps","title":"Next steps","text":"<p>Now you have a new account created, so what else?</p> <p>To keep creating infra on top of this binbash Leverage Landing Zone with this new account added, please check:</p> <ul> <li>  Check common use cases in Playbooks</li> <li>  Review the binbash Leverage architecture</li> <li>  Go for EKS!</li> </ul>"},{"location":"try-leverage/aws-account-setup/","title":"Creating your AWS Management account","text":""},{"location":"try-leverage/aws-account-setup/#create-the-first-aws-account","title":"Create the first AWS account","text":"<p>First and foremost you'll need to create an AWS account for your project.</p> <p>Attention</p> <p>Note this will be your management account and has to be called <code>&lt;project-name&gt;-management</code>.</p> <p>E.g. if your project is called <code>binbash</code> then your account should be <code>binbash-management</code>.</p> <p>Follow the instructions here.</p> <p>This will be the management account for your AWS Organization and the email address you use for signing up will be the root user of this account -- you can see this user represented in the architecture diagram.</p> <p>Since the root user is the main access point to your account it is strongly recommended that you keep its credentials (email, password) safe by following AWS best practices.</p> <p>Tip<p>To protect your management account, enabling Multi Factor Authentication is highly encouraged. Also, reviewing the account's billing setup is always a good idea before proceeding.</p> </p> <p>For more details on setting up your AWS account:  Organization account setup guide</p>"},{"location":"try-leverage/aws-account-setup/#create-a-bootstrap-user-with-temporary-administrator-permissions","title":"Create a bootstrap user with temporary administrator permissions","text":"<p>Leverage needs a user with temporary administrator permissions in order to deploy the initial resources that will form the foundations you will then use to keep building on. That initial deployment is called the bootstrap process and thus the user required for that is called \"the bootstrap user\".</p> <p>To create that user, navigate to the IAM page and create a user named <code>mgmt-org-admin</code> following steps 2 and 3 of this leverage doc.</p> <p>Info<p>Bear in mind that the page for creating users may change from time to time but the key settings for configuring the bootstrap user are the following:</p> <ul> <li>It must be an IAM user (we won't be using IAM Identity Center for this)</li> <li>Password can be auto-generated</li> <li>It requires admin privileges which you can achieve by directly attaching the <code>AdministratorAccess</code> policy to it</li> <li>There's no need to add the user to any group as it is only a temporary user</li> </ul> </p> <p>Usually the last step of the user creation should present you the following information:</p> <ul> <li>Console sign-in URL</li> <li>User name</li> <li>Console password</li> </ul> <p>Make a note of all of these and keep them in a safe place as you will need them in the following steps.</p> <p>Info<p>If you are only getting the bootstrap user credentials for someone else in your team or in Binbash's team, then please share that using a secure way (e.g. password management service, GPG keys, etc).</p> </p> <p>Info<p>If user was set up with the option \"Force to change password on first login\", you should log into the console to do so.</p> </p>"},{"location":"try-leverage/aws-account-setup/#next-steps","title":"Next steps","text":"<p>You have successfully created and configured the AWS account for your Leverage project. From now on, almost all interactions with the AWS environment (with few notable exceptions) will be performed via Leverage.</p> <p>Next, you will setup all required dependencies to work on a Leverage project in your local machine.</p>"},{"location":"try-leverage/enabling-sso/","title":"Configure SSO settings","text":""},{"location":"try-leverage/enabling-sso/#enable-sso","title":"Enable SSO","text":"<p>Let's start by configuring SSO settings. Open this file: <code>&lt;your_project&gt;/config/common.tfvars</code> and update the following lines: <pre><code>sso_enabled   = false\nsso_start_url = \"https://bbleverage.awsapps.com/start\"\n</code></pre></p> <p>Change <code>sso_enabled</code> to <code>true</code> as follows to enable SSO support: <pre><code>sso_enabled   = true\n</code></pre></p> <p>Now you need to set the <code>sso_start_url</code> with the right URL. To find that, navigate here: <code>https://us-east-1.console.aws.amazon.com/singlesignon/home</code> -- you should be already logged in to the Management account for this to work. You should see a \"Settings summary\" panel on the right of the screen that shows the \"AWS access portal URL\". Copy that and use it to replace the value in the <code>sso_start_url</code> entry. Below is an example just for reference: <pre><code>sso_start_url = \"https://d-xyz01234567.awsapps.com/start\"\n</code></pre></p> <p>Customize the AWS access portal URL</p> <p>The 'AWS access portal URL' can be customized to use a more friendly name. Check the official documentation for that.</p> <p>Further info on configuring SSO</p> <p>There is more information on how to configure SSO here.</p>"},{"location":"try-leverage/enabling-sso/#update-backend-profiles-in-the-management-account","title":"Update backend profiles in the management account","text":"<p>It's time to set the right profile names in the backend configuration files. Open this file: <code>management/config/backend.tfvars</code> and change the <code>profile</code> value from this: <pre><code>profile = \"me-bootstrap\"\n</code></pre> To this: <pre><code>profile = \"me-management-oaar\"\n</code></pre> Please note that in the examples above my short project name is <code>me</code> which is used as a prefix and it's the part that doesn't get replaced.</p>"},{"location":"try-leverage/enabling-sso/#activate-your-sso-user-and-set-up-your-password","title":"Activate your SSO user and set up your password","text":"<p>The SSO users you created when you provisioned the SSO layer need to go through an email activation procedure.</p> <p>The user is the one you set in the <code>project.yaml</code> file at the beginning, in this snippet:</p> <pre><code>users:\n- first_name: the-name\nlast_name: the-last-name\nemail: user@domain.co\ngroups:\n- administrators\n- devops\n</code></pre> <p>To activate the user find the instructions here.</p> <p>Once SSO user's have been activated, they will need to get their initial password so they are able to log in. Check out the steps for that here.</p> <p>Basically:</p> <ul> <li>Log into your <code>sso_start_url</code> address</li> <li>Ingress your username (the user email)</li> <li>Under Password, choose Forgot password.</li> <li>Type in the code shown in the screen</li> <li>A reset password email will be sent</li> <li>Follow the link and reset your password</li> <li>Now, in the same URL as before, log in with the new credentials</li> <li>You will be prompted to create an MFA, just do it.</li> </ul>"},{"location":"try-leverage/enabling-sso/#configure-the-cli-for-sso","title":"Configure the CLI for SSO","text":"<p>Almost there. Let's try the SSO integration now.</p>"},{"location":"try-leverage/enabling-sso/#configure-your-sso-profiles","title":"Configure your SSO profiles","text":"<p>Since this is your first time using that you will need to configure it by running this: </p> <pre><code>leverage aws configure sso\n</code></pre> <p>Follow the wizard to get your AWS config file created for you. There is more info about that here.</p>"},{"location":"try-leverage/enabling-sso/#verify-on-a-layer-in-the-management-account","title":"Verify on a layer in the management account","text":"<p>To ensure that worked, let's run a few commands to verify:</p> <ol> <li>We'll use <code>sso</code> for the purpose of this example</li> <li>Move to the <code>management/global/sso</code> layer</li> <li>Run: <code>leverage tf plan</code></li> <li>You should get this error: \"Error: error configuring S3 Backend: no valid credential sources for S3 Backend found.\"</li> <li>This happens because so far you have been running Terraform with a different AWS profile (the bootstrap one). Luckily the fix is simple, just run this: <code>leverage tf init -reconfigure</code>. Terraform should reconfigure the AWS profile in the <code>.terraform/terraform.tfstate</code> file.</li> <li>Now try running that <code>leverage tf plan</code> command again</li> <li>This time it should succeed, you should see the message: <code>No changes. Your infrastructure matches the configuration.</code></li> </ol> <p>Note if you still have the same error, try clearing credentials with:</p> <pre><code>leverage aws sso logout &amp;&amp; leverage aws sso login\n</code></pre>"},{"location":"try-leverage/enabling-sso/#next-steps","title":"Next steps","text":"<p>You successfully enabled SSO.</p> <p>Next, you will orchestrate the remaining accounts, <code>security</code> and <code>shared</code>.</p>"},{"location":"try-leverage/leverage-project-setup/","title":"Create a Leverage project","text":"<p>A Leverage project starts with a simple project definition file that you modify to suit your needs. That file is then used to render the initial directory layout which, at the end of this guide, will be your reference architecture. Follow the sections below to begin with that.</p> <p>The account's name will be given by your project's name followed by <code>-management</code>, since Leverage uses a suffix naming system to differentiate between the multiple accounts of a project. For this guide we'll stick to calling the project <code>MyExample</code> and so, the account name will be <code>myexample-management</code>. </p> <p>Along the same line, we'll use the <code>example.com</code> domain for the email address used to register the account. Adding a <code>-aws</code> suffix to the project's name to indicate that this email address is related to the project's AWS account, we end up with a registration email that looks like <code>myexample-aws@example.com</code>.</p> <p>Email addresses for AWS accounts.<p>Each AWS account requires having a unique email address associated to it. The Leverage Reference Architecture for AWS makes use of multiple accounts to better manage the infrastructure, as such, you will need different addresses for each one. Creating a new email account for each AWS is not a really viable solution to this problem, a better approach is to take advantage of mail services that support aliases. For information regarding how this works:  Email setup for your AWS account.</p> </p>"},{"location":"try-leverage/leverage-project-setup/#create-the-project-directory","title":"Create the project directory","text":"<p>Each Leverage project lives in its own working directory. Create a directory for your project as follows: <pre><code>mkdir myexample\ncd myexample\n</code></pre></p>"},{"location":"try-leverage/leverage-project-setup/#initialize-the-project","title":"Initialize the project","text":"<p>Create the project definition file by running the following command: <pre><code>$ leverage project init\n[18:53:24.407] INFO     Project template found. Updating.                                                                                              [18:53:25.105] INFO     Finished updating template.                                                                                                    [18:53:25.107] INFO     Initializing git repository in project directory.                                                                              [18:53:25.139] INFO     No project configuration file found. Dropping configuration template project.yaml.                                             [18:53:25.143] INFO     Project initialization finished.\n</code></pre></p> <p>The command above should create the project definition file (<code>project.yaml</code>) and should initialize a <code>git</code> repository in the current working directory. This is important because Leverage projects by-design rely on specific <code>git</code> conventions and also because it is assumed that you will want to keep your infrastructure code versioned.</p>"},{"location":"try-leverage/leverage-project-setup/#modify-the-project-definition-file","title":"Modify the project definition file","text":"<p>Open the <code>project.yaml</code> file and fill in the required information.</p> <p>Typically the placeholder values between <code>&lt;</code> and <code>&gt;</code> symbols are the ones you would want to edit however you are welcome to adjust any other values to suit your needs.</p> <p>For instance, the following is a snippet of the <code>project.yaml</code> file in which the values for <code>project_name</code> and <code>short_name</code> have been set to <code>example</code> and <code>ex</code> respectively: <pre><code>project_name: example\nshort_name: ex\nprimary_region: us-east-1\nsecondary_region: us-west-2\n...\n</code></pre></p> <p>The <code>project_name</code> field only accepts lowercase alphanumeric characters and allows hyphens('-'). For instance, valid names could be 'example' or 'leveragedemo' or 'example-demo' </p> <p>The <code>short_name</code> field only accepts 2 to 4 lowercase alpha characters. For instance, valid names could be 'exam or 'leve or 'ex </p> <p>We typically use as 1ry <code>us-east-1</code> and 2ry <code>us-west-2</code> as our default regions for the majority of our projects. However, please note that these regions may not be the most fitting choice for your specific use case. For detailed guidance, we recommend following these provided guidelines.</p> <p>Another example is below. Note that the <code>management</code>, <code>security</code>, and <code>shared</code> accounts have been updated with slightly different email addresses (actually <code>aws+security@example.com</code> and <code>aws+shared@example.com</code> are email aliases of <code>aws@example.com</code> which is a convenient trick in some cases): <pre><code>...\norganization:\n  accounts:\n  - name: management\n    email: aws@example.com\n  - name: security\n    email: aws+security@example.com\n  - name: shared\n    email: aws+shared@example.com\n...\n</code></pre></p> <p>Finally, here's another example snippet that shows how you can define users and assign them to groups: <pre><code>...\nusers:\n- first_name: Jane\n  last_name: Doe\n  email: jane.doe@example.com\n  groups:\n  - administrators\n  - devops\n- first_name: Foo\n  last_name: Bar\n  email: foo.bar@example.com\n  groups:\n  - devops\n...\n</code></pre></p> <p>Note these users will be the ones used later for SSO access.</p> <p>The project definition file includes other entries but the ones shown above are the most frequently updated.</p>"},{"location":"try-leverage/leverage-project-setup/#configure-bootstrap-credentials","title":"Configure \"bootstrap\" credentials","text":"<p>To be able to interact with your AWS environment you first need to configure the credentials to enable AWS CLI to do so. Provide the keys obtained in the previous account creation step to the command by any of the available means.</p> ManuallyFile selectionProvide file in command <p><pre><code>leverage credentials configure --type BOOTSTRAP\n</code></pre> <pre><code>[09:37:17.530] INFO     Loading configuration file.\n[09:37:18.477] INFO     Loading project environment configuration file.\n[09:37:20.426] INFO     Configuring bootstrap credentials.\n&gt; Select the means by which you'll provide the programmatic keys: Manually\n&gt; Key: AKIAU1OF18IXH2EXAMPLE\n&gt; Secret: ****************************************\n[09:37:51.638] INFO     Bootstrap credentials configured in: /home/user/.aws/me/credentials\n[09:37:53.497] INFO     Fetching management account id.\n[09:37:53.792] INFO     Updating project configuration file.\n[09:37:55.344] INFO     Skipping assumable roles configuration.\n</code></pre></p> <p><pre><code>leverage credentials configure --type BOOTSTRAP\n</code></pre> <pre><code>[09:37:17.530] INFO     Loading configuration file.\n[09:37:18.477] INFO     Loading project environment configuration file.\n[09:37:20.426] INFO     Configuring bootstrap credentials.\n&gt; Select the means by which you'll provide the programmatic keys: Path to an access keys file obtained from AWS\n&gt; Path to access keys file: ../bootstrap_accessKeys.csv\n[09:37:51.638] INFO     Bootstrap credentials configured in: /home/user/.aws/me/credentials\n[09:37:53.497] INFO     Fetching management account id.\n[09:37:53.792] INFO     Updating project configuration file.\n[09:37:55.344] INFO     Skipping assumable roles configuration.\n</code></pre></p> <p><pre><code>leverage credentials configure --type BOOTSTRAP --credentials-file ../bootstrap_accessKeys.csv\n</code></pre> <pre><code>[09:37:17.530] INFO     Loading configuration file.\n[09:37:18.477] INFO     Loading project environment configuration file.\n[09:37:20.426] INFO     Configuring bootstrap credentials.\n[09:37:51.638] INFO     Bootstrap credentials configured in: /home/user/.aws/me/credentials\n[09:37:53.497] INFO     Fetching management account id.\n[09:37:53.792] INFO     Updating project configuration file.\n[09:37:55.344] INFO     Skipping assumable roles configuration.\n</code></pre></p> <p>More information on <code>credentials configure</code></p> <p>During the credentials setup, the AWS account id is filled in for us in the project configuration file.</p> <pre><code>...\norganization:\naccounts:\n- name: management\nemail: myexample-aws@example.com\nid: '000123456789'\n...\n</code></pre>"},{"location":"try-leverage/leverage-project-setup/#create-the-configured-project","title":"Create the configured project","text":"<p>Now you will finally create all the infrastructure definition in the project.</p> <pre><code>leverage project create\n</code></pre> <pre><code>[09:40:54.934] INFO     Loading configuration file.\n[09:40:54.950] INFO     Creating project directory structure.\n[09:40:54.957] INFO     Finished creating directory structure.\n[09:40:54.958] INFO     Setting up common base files.\n[09:40:54.964] INFO     Account: Setting up management.\n[09:40:54.965] INFO             Layer: Setting up config.\n[09:40:54.968] INFO             Layer: Setting up base-tf-backend.\n[09:40:54.969] INFO             Layer: Setting up base-identities.\n[09:40:54.984] INFO             Layer: Setting up organizations.\n[09:40:54.989] INFO             Layer: Setting up security-base.\n[09:40:54.990] INFO     Account: Setting up security.\n[09:40:54.991] INFO             Layer: Setting up config.\n[09:40:54.994] INFO             Layer: Setting up base-tf-backend.\n[09:40:54.995] INFO             Layer: Setting up base-identities.\n[09:40:55.001] INFO             Layer: Setting up security-base.\n[09:40:55.002] INFO     Account: Setting up shared.\n[09:40:55.003] INFO             Layer: Setting up config.\n[09:40:55.006] INFO             Layer: Setting up base-tf-backend.\n[09:40:55.007] INFO             Layer: Setting up base-identities.\n[09:40:55.008] INFO             Layer: Setting up security-base.\n[09:40:55.009] INFO             Layer: Setting up base-network.\n[09:40:55.013] INFO     Project configuration finished.\n               INFO     Reformatting terraform configuration to the standard style.\n[09:40:55.743] INFO     Finished setting up project.\n</code></pre> <p>More information on <code>project create</code></p> <p>In this step, the directory structure for the project and all definition files are created using the information from the <code>project.yaml</code> file and checked for correct formatting.</p> <p>You will end up with something that looks like this:</p> MyExample project file structure <p><pre><code>\ud83d\udcc2 myexample\n\u251c\u2500\u2500 \ud83d\udcc4 build.env\n\u251c\u2500\u2500 \ud83d\udcc4 project.yaml\n\u251c\u2500\u2500 \ud83d\udcc2 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 common.tfvars\n\u251c\u2500\u2500 \ud83d\udcc2 management\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 config\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tfvars\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 backend.tfvars\n|   \u251c\u2500\u2500 \ud83d\udcc2 global\n|   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 organizations\n|   \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 accounts.tf\n|   \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n|   \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 delegated_administrator.tf\n|   \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 locals.tf\n|   \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 organizational_units.tf\n|   \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 organization.tf\n|   \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 policies_scp.tf\n|   \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 policy_scp_attachments.tf\n|   \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 service_linked_roles.tf\n|   \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n|   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 base-identities\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 groups.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 keys\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 locals.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 outputs.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 roles.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 users.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n|   \u2514\u2500\u2500 \ud83d\udcc2 us-east-1\n|    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-tf-backend\n|    \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n|    \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 locals.tf\n|    \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 main.tf\n|    \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n|    \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 security-base\n|    \u00a0\u00a0     \u251c\u2500\u2500 \ud83d\udcc4 account.tf\n|    \u00a0\u00a0     \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n|    \u00a0\u00a0     \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n\u251c\u2500\u2500 \ud83d\udcc2 security\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 config\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tfvars\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 backend.tfvars\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 global\n|   |   \u2514\u2500\u2500 \ud83d\udcc2 base-identities\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 groups_policies.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 groups.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 keys\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 locals.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 outputs.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 role_policies.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 roles.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 users.tf\n|   \u2502\u00a0\u00a0  \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 us-east-1\n|    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-tf-backend\n|    \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n|    \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 locals.tf\n|    \u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 main.tf\n|    \u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n|    \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 security-base\n|    \u00a0\u00a0     \u251c\u2500\u2500 \ud83d\udcc4 account.tf\n|    \u00a0\u00a0     \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n|    \u00a0\u00a0     \u251c\u2500\u2500 \ud83d\udcc4 iam_access_analyzer.tf\n|    \u00a0\u00a0     \u251c\u2500\u2500 \ud83d\udcc4 locals.tf\n\u2502    \u00a0\u00a0     \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n\u2514\u2500\u2500 \ud83d\udcc2 shared\n    \u251c\u2500\u2500 \ud83d\udcc2 config\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tfvars\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 backend.tfvars\n    \u251c\u2500\u2500 \ud83d\udcc2 global\n    |   \u2514\u2500\u2500 \ud83d\udcc2 base-identities\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tf\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 locals.tf\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 policies.tf\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 roles.tf\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 service_linked_roles.tf\n    |    \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n    \u2514\u2500\u2500 \ud83d\udcc2 us-east-1\n        \u251c\u2500\u2500 \ud83d\udcc2 base-network\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tf\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 locals.tf\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 network.tf\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 network_vpc_flow_logs.tf\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 outputs.tf\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n        \u251c\u2500\u2500 \ud83d\udcc2 base-tf-backend\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 locals.tf\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 main.tf\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n        \u2514\u2500\u2500 \ud83d\udcc2 security-base\n            \u251c\u2500\u2500 \ud83d\udcc4 account.tf\n            \u251c\u2500\u2500 \ud83d\udcc4 config.tf\n            \u2514\u2500\u2500 \ud83d\udcc4 variables.tf\n</code>\n<p>As you can see, it is a structure comprised of directories for each account containing all the definitions for each of the accounts respective layers.</p>\n<p>The layers themselves are also grouped based on the region in which they are deployed. The regions are configured through the <code>project.yaml</code> file. In the case of the Leverage landing zone, most layers are deployed in the primary region, so you can see the definition of these layers in a <code>us-east-1</code> directory, as per the example configuration.</p>\n<p>Some layers are not bound to a region because their definition is mainly comprised of resources for services that are global in nature, like IAM or Organizations. These kind of layers are kept in a <code>global</code> directory.</p>"},{"location":"try-leverage/leverage-project-setup/#next-steps","title":"Next steps","text":"<p>You have now created the definition of all the infrastructure for your project and configured the credentials need to deploy such infrastructure in the AWS environment.</p>\n<p>Next, you will orchestrate the first and main account of the project, the management account.</p>"},{"location":"try-leverage/local-setup/","title":"Install Leverage CLI","text":"<p>Leverage-based projects are better managed via the Leverage CLI which is a companion tool that simplifies your daily interactions with Leverage. This page will guide you through the installation steps.</p>"},{"location":"try-leverage/local-setup/#prerequisites","title":"Prerequisites","text":"<p>In order to install the CLI you should have the following installed in your system:</p> <ul> <li> Git</li> <li> Python 3 <code>version 3.8 and up</code></li> <li> Docker</li> </ul>"},{"location":"try-leverage/local-setup/#install-leverage-cli_1","title":"Install Leverage CLI","text":"<p>Leverage CLI is distributed as a python package that you can install it via <code>pip</code> as follows: <pre><code>pip install leverage\n</code></pre></p> <p>For further details on installing Leverage CLI:  Install Leverage CLI</p>"},{"location":"try-leverage/local-setup/#verify-your-leverage-cli-installation","title":"Verify your Leverage CLI installation","text":"<p>Verify that your Leverage CLI installation was successful by running the following command: <pre><code>$ leverage --version\nleverage, version 1.9.2\n</code></pre></p> <p>It is generally recommended to install the latest stable version of the CLI</p>"},{"location":"try-leverage/local-setup/#enable-tab-completion","title":"Enable tab completion","text":"<p>If you use Bash, Zsh or Fish, you can enable shell completion for Leverage commands.</p> BashZshFish <p>Add to <code>~/.bashrc</code>: <pre><code>eval \"$(_LEVERAGE_COMPLETE=bash_source leverage)\"\n</code></pre></p> <p>Add to <code>~/.zshrc</code>: <pre><code>eval \"$(_LEVERAGE_COMPLETE=zsh_source leverage)\"\n</code></pre></p> <p>Add to <code>~/.config/fish/completions/leverage.fish</code>: <pre><code>eval (env _LEVERAGE_COMPLETE=fish_source leverage)\n</code></pre></p> <p>Now you need to restart your shell.</p>"},{"location":"try-leverage/local-setup/#next-steps","title":"Next steps","text":"<p>Now you have your system completely configured to work on a Leverage project.</p> <p>Next, you will setup and create your Leverage project.</p>"},{"location":"try-leverage/management-account/","title":"Configure the Management account","text":"<p>Finally we reach the point in which you'll get to actually create the infrastructure in our AWS environment.</p> <p>Some accounts and layers rely on other accounts or layers to be deployed first, which creates dependencies between them and establishes an order in which all layers should be deployed. We will go through these dependencies in order.</p> <p>The management account is used to configure and access all the accounts in the AWS Organization. Consolidated Billing and Cost Management are also enforced though this account.</p> <p>Costs associated with this solution</p> <p>By default this AWS Reference Architecture configuration should not incur in any costs.</p>"},{"location":"try-leverage/management-account/#deploy-the-management-accounts-layers","title":"Deploy the Management account's layers","text":"<p>To begin, place yourself in the <code>management</code> account directory. <pre><code>cd management\n</code></pre></p>"},{"location":"try-leverage/management-account/#terraform-backend-layer","title":"Terraform backend layer","text":"<p>Move into the <code>us-east-1/base-tf-backend</code> directory and run: <pre><code>leverage terraform init --skip-validation\nleverage terraform apply\n</code></pre></p> <p>All <code>apply</code> commands will prompt for confirmation, answer <code>yes</code> when this happens.</p> <p>More information on <code>terraform init</code> and <code>terraform apply</code></p> <p>Now, the infrastructure for the Terraform state management is created. The next step is to push the local <code>.tfstate</code> to the bucket. To do this, uncomment the <code>backend</code> section for the <code>terraform</code> configuration in <code>management/base-tf-backend/config.tf</code></p> <pre><code>  backend \"s3\" {\nkey = \"management/tf-backend/terraform.tfstate\"\n}\n</code></pre> <p>And run once more: <pre><code>leverage terraform init\n</code></pre></p> <p>When prompted, answer <code>yes</code>. Now you can safely remove the <code>terraform.tfstate</code> and <code>terraform.tfstate.backup</code> files created during the <code>apply</code> step.</p> <p>Terraform backend</p> <p>More information regarding what is the Terraform backend and Terraform state management:</p> <ul> <li>Terraform backend</li> <li>How to manage Terraform state</li> </ul>"},{"location":"try-leverage/management-account/#organizations-layer","title":"Organizations layer","text":"<p>Next, in the same fashion as in the previous layer, move into the <code>global/organizations</code> directory and run: <pre><code>leverage terraform init\nleverage terraform apply\n</code></pre></p> <p>The AWS account that you created manually is the <code>management</code> account itself, so to prevent Terraform from trying to create it and error out, this account definition is commented by default in the code. Now you need to make the Terraform state aware of the link between the two. To do that, uncomment the <code>management</code> organizations account resource in <code>accounts.tf</code></p> <pre><code>resource \"aws_organizations_account\" \"management\" {\nname  = \"${var.project_long}-management\"\nemail = local.management_account.email\n}\n</code></pre> <p>Grab the management account id that previously was automatically filled in for us in the <code>project.yaml</code> file</p> <pre><code>...\norganization:\naccounts:\n- name: management\nemail: myexample-aws@example.com\nid: '000123456789'\n...\n</code></pre> <p>And run: <pre><code>leverage terraform import aws_organizations_account.management 000123456789\n</code></pre></p> <p>More information on <code>terraform import</code></p> <p>Getting errors with zsh?</p> <p>Zsh users may need to prepend <code>noglob</code> to the import command for it to be recognized correctly, as an alternative, square brackets can be escaped as <code>\\[\\]</code></p>"},{"location":"try-leverage/management-account/#security-layer","title":"Security layer","text":"<p>Change directory to <code>us-east-1/security-base</code> and run this: <pre><code>leverage terraform init\nleverage terraform apply\n</code></pre></p>"},{"location":"try-leverage/management-account/#update-the-bootstrap-credentials","title":"Update the bootstrap credentials","text":"<p>Now that the <code>management</code> account has been deployed, and more specifically, all Organizations accounts have been created (in the organizations layer) you need to update the credentials for the bootstrap process before proceeding to deploy any of the remaining accounts.</p> <p>This will fetch the organizations structure from the AWS environment and create individual profiles associated with each account for the AWS CLI to use. So, run: <pre><code>$ leverage credentials configure --type BOOTSTRAP --skip-access-keys-setup\n[09:08:44.762] INFO     Loading configuration file.\n[09:08:44.785]     Loading project environment configuration file.\n[09:08:44.791]     Loading Terraform common configuration.\n[09:08:53.247]     Configuring assumable roles.\n[09:08:53.248]     Fetching organization accounts.\n[09:08:55.193]     Backing up account profiles file.\n[09:08:55.761]             Configuring profile me-management-oaar\n[09:08:59.977]             Configuring profile me-security-oaar\n[09:09:04.081]             Configuring profile me-shared-oaar\n[09:09:08.305]     Account profiles configured in: /home/user/.aws/me/config\n[09:09:08.307] INFO     Updating project's Terraform common configuration.\n</code></pre></p> <p>More information on <code>credentials configure</code></p>"},{"location":"try-leverage/management-account/#sso-layer","title":"SSO layer","text":"<p>Before working on the SSO layer you have to navigate to the AWS IAM Identity Center page, set the region to the primary region you've chosen and enable Single Sign-On (SSO) by clicking on the <code>Enable</code> button.</p> <p>Now back to the terminal. The SSO layer is deployed in two steps. First, switch to the <code>global/sso</code> directory and run the following: <pre><code>leverage terraform init\nleverage terraform apply\n</code></pre></p> <p>Secondly, open the <code>account_assignments.tf</code> file and uncomment the entire section that starts with this line: <pre><code># module \"account_assignments\" {\n#   source = \"github.com/binbashar/terraform-aws-sso.git//modules/account-assignments?ref=0.7.1\"\n\n[REDACTED]\n\n#   ]\n# }\n</code></pre></p> <p>After that, run these commands: <pre><code>leverage terraform init\nleverage terraform apply\n</code></pre></p>"},{"location":"try-leverage/management-account/#next-steps","title":"Next steps","text":"<p>You have successfully orchestrated the <code>management</code> account for your project and configured the credentials for the next steps.</p> <p>Now, let's enable SSO for the rest of the process.</p>"},{"location":"try-leverage/post-deployment/","title":"Post-deployment steps","text":"<p>At this point the landing zone should be ready.</p> <p>The bootstrap user can now be deleted.</p>"},{"location":"try-leverage/post-deployment/#delete-the-bootstrap-user","title":"Delete the bootstrap user","text":"<ul> <li>Log into your <code>sso_start_url</code> address with your SSO user</li> <li>Select the <code>management</code> account and log into the <code>Management console</code></li> <li>Go to IAM</li> <li>Delete the user <code>mgmt-org-admin</code></li> </ul>"},{"location":"try-leverage/post-deployment/#adding-sso-users-and-groups","title":"Adding SSO users and groups","text":"<p>To add users or groups, please see SSO Managing Users document.</p>"},{"location":"try-leverage/post-deployment/#next-steps","title":"Next steps","text":"<p>Now you not only have a fully functional landing zone configuration deployed, but also are able to interact with it using your own AWS SSO credentials.</p> <p>For more detailed information on the binbash Leverage Landing Zone, visit the links below.</p> <ul> <li> How it works</li> <li> User guide</li> </ul>"},{"location":"try-leverage/security-and-shared-accounts/","title":"Configure the Security and Shared accounts","text":"<p>You should by now be more familiar with the steps required to create and configure the Management account. Now you need to do pretty much the same with two more accounts: Security and Shared. Follow the sections in this page to get started!</p> <p>What are these accounts used for?</p> <p>The Security account is intended for operating security services (e.g. GuardDuty, AWS Security Hub, AWS Audit Manager, Amazon Detective, Amazon Inspector, and AWS Config), monitoring AWS accounts, and automating security alerting and response.</p> <p>The Shared Services account supports the services that multiple applications and teams use to deliver their outcomes. Some examples include VPN servers, monitoring systems, and centralized logs management services.</p>"},{"location":"try-leverage/security-and-shared-accounts/#deploy-the-security-accounts-layers","title":"Deploy the Security account's layers","text":"<p>The next account to orchestrate is the security account.</p> <p>This account is intended for centralized user management via a IAM roles based cross organization authentication approach. This means that most of the users for your organization will be defined in this account and those users will access the different accounts through this one.</p> <p>First, go to the <code>security</code> directory. <pre><code>cd security\n</code></pre></p>"},{"location":"try-leverage/security-and-shared-accounts/#set-profile","title":"Set profile","text":"<p>Since we are using SSO, check in <code>security/config/backend.tfvars</code> file the <code>profile</code> is set to:</p> <pre><code>profile = \"me-security-devops\"\n</code></pre> <p>If it is not, please modify it. Note we are using a sample short project name <code>me</code>, use the one you have set.</p>"},{"location":"try-leverage/security-and-shared-accounts/#terraform-backend-layer","title":"Terraform backend layer","text":"<p>Move into the <code>us-east-1/base-tf-backend</code> directory and run: <pre><code>leverage terraform init --skip-validation\nleverage terraform apply\n</code></pre></p> <p>More information on <code>terraform init</code> and <code>terraform apply</code></p> <p>Now, to push the local <code>.tfstate</code> to the bucket, uncomment the <code>backend</code> section for the <code>terraform</code> configuration in <code>security/base-tf-backend/config.tf</code> <pre><code>  backend \"s3\" {\nkey = \"security/tf-backend/terraform.tfstate\"\n}\n</code></pre></p> <p>And run again: <pre><code>leverage terraform init\n</code></pre></p> <p>When prompted, answer <code>yes</code>.</p> <p>Now you can safely remove the <code>terraform.tfstate</code> and <code>terraform.tfstate.backup</code> files created during the <code>apply</code> step.</p>"},{"location":"try-leverage/security-and-shared-accounts/#security-layer","title":"Security layer","text":"<p>The last layer for the <code>security</code> account is the security layer. Move into the <code>us-east-1/security-base</code> directory and run: <pre><code>leverage terraform init\nleverage terraform apply\n</code></pre></p>"},{"location":"try-leverage/security-and-shared-accounts/#deploy-the-shared-accounts-layers","title":"Deploy the Shared account's layers","text":"<p>The last account in this deployment is the <code>shared</code> account.</p> <p>Again, this account is intended for managing the infrastructure of shared services and resources such as directory services, DNS, VPN, monitoring tools or centralized logging solutions.</p> <p>Place yourself in the <code>shared</code> directory. <pre><code>cd shared\n</code></pre></p>"},{"location":"try-leverage/security-and-shared-accounts/#set-profile_1","title":"Set profile","text":"<p>Since we are using SSO, check in <code>shared/config/backend.tfvars</code> file the <code>profile</code> is set to:</p> <pre><code>profile = \"me-shared-devops\"\n</code></pre> <p>If it is not, please modify it. Note we are using a sample short project name <code>me</code>, use the one you have set.</p>"},{"location":"try-leverage/security-and-shared-accounts/#terraform-backend-layer_1","title":"Terraform backend layer","text":"<p>Move into the <code>us-east-1/base-tf-backend</code> directory and run: <pre><code>leverage terraform init --skip-validation\nleverage terraform apply\n</code></pre></p> <p>More information on <code>terraform init</code> and <code>terraform apply</code></p> <p>Now, to push the local <code>.tfstate</code> to the bucket, uncomment the <code>backend</code> section for the <code>terraform</code> configuration in <code>shared/base-tf-backend/config.tf</code> <pre><code>  backend \"s3\" {\nkey = \"shared/tf-backend/terraform.tfstate\"\n}\n</code></pre></p> <p>And run a second time: <pre><code>leverage terraform init\n</code></pre></p> <p>When prompted, answer <code>yes</code>.</p> <p>Now you can safely remove the <code>terraform.tfstate</code> and <code>terraform.tfstate.backup</code> files created during the <code>apply</code> step.</p>"},{"location":"try-leverage/security-and-shared-accounts/#security-layer_1","title":"Security layer","text":"<p>Next, move into the <code>us-east-1/security-base</code> directory: <pre><code>leverage terraform init\nleverage terraform apply\n</code></pre></p>"},{"location":"try-leverage/security-and-shared-accounts/#network-layer","title":"Network layer","text":"<p>The last layer should be the network layer, so switch to that <code>us-east-1/base-network</code> and run: <pre><code>leverage terraform init\nleverage terraform apply\n</code></pre></p>"},{"location":"try-leverage/security-and-shared-accounts/#next-steps","title":"Next steps","text":"<p>You have now a fully deployed landing zone configuration for the Leverage Reference Architecture for AWS, with its three accounts management, security and shared ready to be used.</p> <p>Next, you are going to tackle de last steps.</p>"},{"location":"user-guide/","title":"Index","text":""},{"location":"user-guide/#user-guide","title":"User Guide","text":""},{"location":"user-guide/#overview","title":"Overview","text":"<p>The pages in this section explore, with great detail, the architecture of the components that make up Leverage.</p> <ul> <li> Reference Architectures<ul> <li> Reference Architecture for AWS</li> <li> Reference Architecture for EKS</li> <li> Reference Architecture for Ansible</li> </ul> </li> <li> Infrastructure-as-Code Library</li> <li> Leverage CLI</li> </ul> <p>But don't feel constrained to the links above, feel free to use the left menu to explore more on your own.</p>"},{"location":"user-guide/infra-as-code-library/infra-as-code-library-forks/","title":"Leverage Open Source Modules management.","text":"<p>We\u2019ll fork every Infrastructure as Code (IaC) Library dependency repo, why?</p> <p>Grant full governance over the lib repositories</p> <ul> <li> Availability: Because our project resilience and continuity (including the clients) depends on these repositories (via requirement files or imports) and we want and need total control over the repository used as a dependency. NOTE: There could be few exceptions when using official open source modules makes sense, e.g. the ones shared and maintained by Nginx, Weave, Hashiport, etc.</li> <li> Reliability (Avoid unforeseen events): in the event that the original  project becomes discontinued while we are still working or depending on it (the owners, generally individual maintainers of the original repository, might decide to move from github, ansible galaxy, etc. or even close their repo for personal reasons).</li> <li> Stability: Our forks form modules (ansible roles / terraform / dockerfiles, etc.) are always going to be locked to fixed versions for every client so no unexpected behavior will occur.</li> <li> Projects that don't tag versions: having the fork protects us against breaking changes.</li> <li> Write access: to every Leverage library component repository ensuring at all times that we can support, update, maintain, test, customize and release a new version of this component.</li> <li> Centralized Org source of truth: for improved customer experience and keeping dependencies consistently imported from binbash repos at Leverage Github</li> <li> Scope: binbash grants and responds for all these dependencies.</li> <li> Metrics:  Dashboards w/ internal measurements.</li> <li> Automation: We\u2019ll maintain all this workflow cross-tech as standardized and automated as possible, adding any extra validation like testing, security check, etc., if needed -&gt; Leverage dev-tools</li> <li> Licence &amp; Ownership: Since we fork open-source and commercially reusable components w/ MIT and Apache 2.0 license.  We keep full rights to all commercial, modification, distribution, and private use of the code (No Lock-In w/ owners) through forks inside our own Leverage Project repos.  As a result, when time comes, we can make our libs private at any moment if necessary. (for the time being Open Source looks like the best option)</li> </ul> <p>Collaborators considerations</p> <ul> <li>We look forward to have every binbash Leverage repo open sourced favoring the  collaboration of the open source community. </li> <li>Repos that are still private must not be forked by our internal collaborators till we've done a detailed and rigorous review in order to open source them.</li> <li>As a result any person looking forward to use, extend or update Leverage public repos, could also fork them in its personal or company Github account and create an upstream PR to contribute.</li> </ul>"},{"location":"user-guide/infra-as-code-library/infra-as-code-library-specs/","title":"Tech Specifications","text":"As Code: Hundred of thousands lines of code <p>Written in:</p> <ul> <li> Terraform</li> <li> Groovy (Jenkinsfiles)</li> <li> Ansible</li> <li> Makefiles + Bash </li> <li> Dockerfiles</li> <li> Helm Charts</li> </ul> Stop reinventing the wheel, automated and fully as code <ul> <li> automated (executable from a single source).</li> <li> as code.</li> <li> parameterized<ul> <li>variables</li> <li>input parameters</li> <li>return / output parameters</li> </ul> </li> <li> \"Stop reinventing the wheel\"<ul> <li>avoid re-building the same things more than X times.</li> <li>avoid wasting time.</li> <li>not healthy, not secure and slows us down.</li> </ul> </li> </ul> DoD of a highly reusable, configurable, and composable sub-modules <p>Which will be 100%</p> <ul> <li> modular <ul> <li>equivalent to other programming languages functions - Example for terraform -  https://www.terraform.io/docs/modules/usage.html (but can be propagated for other languages and tools):<ol> <li>inputs, outputs parameters.</li> <li>code reuse (reusable): consider tf modules and sub-modules approach.</li> <li>testable by module / function.<ol> <li>Since TF is oriented to work through 3<sup>rd</sup> party API calls, then tests are more likely to be  <code>integration tests</code> rather than <code>unit tests</code>. If we don't allow integration for terraform then we   can't work at all.<ol> <li>This has to be analyzed for every language we'll be using and how we implement it (terraform,  cloudformation, ansible, python, bash, docker, kops and k8s kubeclt cmds)</li> </ol> </li> </ol> </li> <li>composition (composable): have multiple functions and use them together<ol> <li>eg: <code>def_add(x,y){return x+y} ; def_sub(x,y){return x-y}; sub(add(3,4), add(7,5))</code></li> </ol> </li> <li>abstraction (abstract away complexity): we have a very complex function but we only expose it's  definition to the API, eg: <code>def_ai_processing(data_set){very complex algorithm here};   ai_processing([our_data_set_here])</code></li> <li>avoid inline blocks: The configuration for some Terraform resources can be defined either as  inline blocks or as separate resources. For example, the aws_route_table    resource allows you to define routes via inline blocks. But by doing so, your module become less    flexible and configurable. Also, if a mix of both, inline blocks and separate resources, is used,    errors may arise in which they conflict and overwrite each other. Therefore, you must use one or     the other (ref: https://blog.gruntwork.io/how-to-create-reusable-infrastructure-with-terraform-modules-25526d65f73d)     As a rule of thumb, when creating a module, separate resources should always be used.</li> <li>use module-relative paths: The catch is that the used file path has to be relative  (since you could run Terraform on many different computers)\u200a\u2014\u200abut relative to what? By default,   Terraform interprets the path as relative to the working directory. That\u2019s a good default for normal    Terraform templates, but it won\u2019t work if the file is part of a module.     To solve this issue, always use a path variable     in file paths.     eg:      <pre><code>resource \"aws_instance\" \"example\" {\n  ami = \"ami-2d39803a\"\n  instance_type = \"t2.micro\"\n  user_data = \"${file(\"${path.module}/user-data.sh\")}\"\n}\n</code></pre></li> </ol> </li> </ul> </li> </ul> Solutions must be versioned <p>So as to be able to manage them as a software product with releases and change log.  This way we'll be able to know which version is currently deployed in a given client and consider upgrading it.</p> Env Parity <p>Promote immutable, versioned infra modules based across envs. </p> Updated <p>Continuously perform updates, additions, and fixes to libraries and modules. </p> Orchestrated in automation <p>We use the leverage-cli for this purpose </p> Proven &amp; Tested <p>Every commit goes through a suite of automated tests to grant code styling and functional testing.</p> <ul> <li> Develop a wrapper/jobs together with specific testing tools in order to grant the modules are working as expected.</li> <li> Ansible: <ul> <li>Testing your ansible roles w/ molecule</li> <li>How to test ansible roles with molecule on ubuntu</li> </ul> </li> <li> Terraform:<ul> <li>gruntwork-io/terratest</li> </ul> </li> </ul> Cost savings by design <p>The architecture for our Library / Code Modules helps an organization to analyze its current IT and DevSecOps Cloud strategy and identify areas where changes could lead to cost savings. For instance, the architecture may show that multiple database systems could be changed so only one product is used, reducing software and support costs. Provides a basis for reuse. The process of architecting can support both the use and creation of reusable assets. Reusable assets are beneficial for an organization, since they can reduce the overall cost of a system and also improve its quality, since a reusable asset has already been proven.</p> Full Code Access &amp; No Lock-In <p>You get access to 100% of the code under Open Source license, if you choose to discontinue the direct support of the binbash Leverage team, you keep rights to all the code.</p> Documented <p>Includes code examples, use cases and thorough documentation, such as README.md,  --help command, doc-string and in line comments.</p> Supported  &amp; Customizable <p>Commercially maintained and supported by binbash.</p>"},{"location":"user-guide/infra-as-code-library/modules-library-by-technology/","title":"Modules by Technology","text":""},{"location":"user-guide/infra-as-code-library/modules-library-by-technology/#open-source-modules-repos","title":"Open Source Modules Repos","text":"Category URLs Ansible Galaxy Roles bb-leverage-ansible-roles-list Dockerfiles bb-leverage-dockerfiles-list Helm Charts bb-leverage-helm-charts-list Terraform Modules bb-leverage-terraform-modules-list"},{"location":"user-guide/infra-as-code-library/modules-library-by-technology/#open-source-private-modules-repos-via-github-teams","title":"Open Source + Private Modules Repos (via GitHub Teams)","text":"Repositories Details Reference Architecture Most of the AWS resources are here, divided by account. Dockerfiles These are Terraform module we created/imported to build reusable resources / stacks. Ansible Playbooks &amp; Roles Playbooks we use for provisioning servers such as Jenkins, Spinnaker, Vault, and so on. Helm Charts Complementary Jenkins pipelines to clean docker images, unseal Vault, and more. Also SecOps jobs can be found here. Terraform Modules Jenkins pipelines, docker images, and other resources used for load testing."},{"location":"user-guide/infra-as-code-library/overview/","title":"Infrastructure as Code (IaC) Library","text":""},{"location":"user-guide/infra-as-code-library/overview/#overview","title":"Overview","text":"<p>A collection of reusable, tested, production-ready E2E infrastructure as code solutions, leveraged by modules written in Terraform, Ansible, Dockerfiles, Helm charts and Makefiles.</p>"},{"location":"user-guide/infra-as-code-library/overview/#model","title":"Model","text":"<p>Our development model is strongly based on code reusability. </p>"},{"location":"user-guide/infra-as-code-library/overview/#reusability","title":"Reusability","text":"<p>High level summary of the the code reusability efficiency. </p> <p>Considerations</p> <p> Above detailed <code>%</code> are to be seen as estimates: </p> <ul> <li> AWS PCI-DSS Reference article</li> <li> AWS HIPAA Reference article</li> <li> AWS GDPR Reference article</li> </ul>"},{"location":"user-guide/infra-as-code-library/overview/#modules","title":"Modules","text":"<p>Infrastructure as Code (IaC) Library development and implementation workflow. </p>"},{"location":"user-guide/leverage-cli/basic-features/","title":"Basic CLI features","text":"<p>To view a list of all the available commands and options in your current Leverage version simply run <code>leverage</code> or <code>leverage --help</code>. You should get an output similar to this: <pre><code>$ leverage\nUsage: leverage [OPTIONS] COMMAND [ARGS]...\n\n  Leverage Reference Architecture projects command-line tool.\n\nOptions:\n  -f, --filename TEXT  Name of the build file containing the tasks\n                       definitions.  [default: build.py]\n-l, --list-tasks     List available tasks to run.\n  -v, --verbose        Increase output verbosity.\n  --version            Show the version and exit.\n  --help               Show this message and exit.\n\nCommands:\n  aws          Run AWS CLI commands in a custom containerized environment.\n  credentials  Manage AWS cli credentials.\n  kc           Run Kubectl commands in a custom containerized environment.\n  kubectl      Run Kubectl commands in a custom containerized environment.\n  project      Manage a Leverage project.\n  run          Perform specified task(s) and all of its dependencies.\n  shell        Run a shell in a generic container.\n  terraform    Run Terraform commands in a custom containerized...\n  tf           Run Terraform commands in a custom containerized...\n  tfautomv     Run TFAutomv commands in a custom containerized...\n</code></pre></p> <p>Similarly, subcommands provide further information by means of the <code>--help</code> flag. For example <code>leverage tf --help</code>.</p>"},{"location":"user-guide/leverage-cli/basic-features/#global-options","title":"Global options","text":"<ul> <li><code>-f</code> | <code>--filename</code>:  Name of the file containing the tasks' definition. Defaults to <code>build.py</code></li> <li><code>-l</code> | <code>--list-tasks</code>: List all the tasks defined for the project along a description of their purpose (when available). <pre><code>Tasks in build file `build.py`:\n\n  clean                   Clean build directory.\n  copy_file               \n  echo                    \n  html                    Generate HTML.\n  images        [Ignored] Prepare images.\n  start_server  [Default] Start the server\n  stop_server             \n\nPowered by Leverage 1.9.0\n</code></pre></li> <li> <p><code>-v</code> | <code>--verbose</code>: Increases output verbosity.   When running a command in a container, the tool provides a description of the container's configuration before the execution.   This is specially useful if the user were to to have the need of recreating Leverage's behavior by themselves. <pre><code>$ leverage -v tf plan\n[18:23:22.222] DEBUG    Found config file /home/user/binbash/le-tf-infra-aws/build.env\n[18:23:22.239] DEBUG    Container configuration:\n                        {\n\"image\": \"binbash/leverage-toolbox:1.2.7-0.1.7\", #(1)!\n\"command\": \"\",\n                          \"stdin_open\": true,\n                          \"environment\": { #(2)!\n\"COMMON_CONFIG_FILE\": \"/binbash/config/common.tfvars\",\n                            \"ACCOUNT_CONFIG_FILE\": \"/binbash/security/config/account.tfvars\",\n                            \"BACKEND_CONFIG_FILE\": \"/binbash/security/config/backend.tfvars\",\n                            \"AWS_SHARED_CREDENTIALS_FILE\": \"/root/tmp/bb/credentials\",\n                            \"AWS_CONFIG_FILE\": \"/root/tmp/bb/config\",\n                            \"SRC_AWS_SHARED_CREDENTIALS_FILE\": \"/root/tmp/bb/credentials\",\n                            \"SRC_AWS_CONFIG_FILE\": \"/root/tmp/bb/config\",\n                            \"AWS_CACHE_DIR\": \"/root/tmp/bb/cache\",\n                            \"SSO_CACHE_DIR\": \"/root/tmp/bb/sso/cache\",\n                            \"SSH_AUTH_SOCK\": \"/ssh-agent\"\n},\n                          \"entrypoint\": \"/bin/terraform\",\n                          \"working_dir\": \"/binbash/security/global/base-identities\",\n                          \"host_config\": {\n\"NetworkMode\": \"default\",\n                            \"SecurityOpt\": [\n\"label:disable\"\n],\n                            \"Mounts\": [ #(3)!\n{\n\"Target\": \"/binbash\",\n                                \"Source\": \"/home/user/binbash/le-tf-infra-aws\",\n                                \"Type\": \"bind\",\n                                \"ReadOnly\": false\n},\n                              {\n\"Target\": \"/root/tmp/bb\",\n                                \"Source\": \"/home/user/.aws/bb\",\n                                \"Type\": \"bind\",\n                                \"ReadOnly\": false\n},\n                              {\n\"Target\": \"/etc/gitconfig\",\n                                \"Source\": \"/home/user/.gitconfig\",\n                                \"Type\": \"bind\",\n                                \"ReadOnly\": false\n},\n                              {\n\"Target\": \"/ssh-agent\",\n                                \"Source\": \"/run/user/1000/keyring/ssh\",\n                                \"Type\": \"bind\",\n                                \"ReadOnly\": false\n}\n]\n}\n}\n[18:23:22.274] DEBUG    Checking for layer /home/user/binbash/le-tf-infra-aws/security/global/base-identities...\n[18:23:22.279] DEBUG    Checking layer /home/user/binbash/le-tf-infra-aws/security/global/base-identities...\n[18:23:22.282] DEBUG    Running command: sh -c 'cat $SSO_CACHE_DIR/token'\n[18:23:22.901] DEBUG    Running with entrypoint: /root/scripts/aws-sso/aws-sso-entrypoint.sh -- /bin/terraform\n[18:23:22.903] DEBUG    Running command: plan -var-file=/binbash/config/common.tfvars -var-file=/binbash/security/config/account.tfvars -var-file=/binbash/security/config/backend.tfvars #(4)!\n...\n</code></pre></p> <ol> <li> Docker image being used</li> <li>Environment variables available in the container</li> <li>Mapping of the host (<code>Source</code>) directories and files into the container (<code>Target</code>)</li> <li>Command being executed (useful when trying to replicate Leverage's behavior by yourself)</li> </ol> </li> </ul>"},{"location":"user-guide/leverage-cli/history/","title":"A bit of history","text":""},{"location":"user-guide/leverage-cli/history/#how-leverage-cli-came-about","title":"How Leverage CLI came about","text":"<p>The multiple tools and technologies required to work with a Leverage project were initially handled through a Makefiles system. Not only to automate and simplify the different tasks, but also to provide a uniform user experience during the management of a project.</p> <p>As a result of more and more features being added and the Leverage Reference Architecture becoming broader and broader, our Makefiles were growing large and becoming too repetitive, and thus, harder to maintain. Also, some limitations and the desire for a more friendly and flexible language than that of Makefiles made evident the need for a new tool to take their place.</p> <p>Python, a language broadly adopted for automation due to its flexibility and a very gentle learning curve seemed ideal. Even more so, Pynt, a package that provides the ability to define and manage tasks as simple Python functions satisfied most of our requirements, and thus, was selected for the job. Some gaps still remained but with minor modifications these were bridged.</p> <p>Gradually, all capabilities originally implemented through Makefiles were migrated to Python as libraries of tasks that still resided within the Leverage Reference Architecture. But soon, the need to deliver these capabilities pre-packaged in a tool instead of embedded in the infrastructure definition became apparent, and were re-implemented in the shape of built-in commands of Leverage CLI.</p> <p>Currently, the core functionality needed to interact with a Leverage project is native to Leverage CLI but a system for custom tasks definition and execution heavily inspired in that of Pynt is retained.</p>"},{"location":"user-guide/leverage-cli/installation/","title":"Installation","text":"<p>To use Leverage CLI you need to install it from the Python Package Index (Pypi). Currently, only Linux and Mac OS are supported operative systems.</p> <p>Requirements</p> <ul> <li> Python <code>&gt;= 3.8</code></li> <li> Git <code>&gt;= 2.25</code></li> <li> Docker engine <code>&gt;= 20.x.y</code></li> </ul> <p>Having issues with the CLI?</p> <p>Check out the troubleshooting section to find more help.</p>"},{"location":"user-guide/leverage-cli/installation/#install-pip","title":"Install Pip","text":"Ubuntu/DebianCentOS/RHELFedoraMacOS <pre><code>$ sudo apt install python3-pip\n</code></pre> <pre><code>$ sudo yum install python3-pip\n</code></pre> <pre><code>$ sudo dnf install python3-pip\n</code></pre> <p>Pip should already be installed alongside your Python 3 installation. If for whatever reason this is not the case: <pre><code>$ brew install python3\n</code></pre></p>"},{"location":"user-guide/leverage-cli/installation/#install-leverage-cli","title":"Install Leverage CLI","text":"<pre><code>$ pip3 install leverage\n</code></pre>"},{"location":"user-guide/leverage-cli/installation/#update-leverage-cli-from-previous-versions","title":"Update Leverage CLI from previous versions","text":"<p>Upgrade to a specific version. <pre><code>$ pip3 install -Iv leverage==1.9.1\n</code></pre></p> <p>Upgrade to the latest stable version <pre><code>$ pip3 install --upgrade leverage\n</code></pre></p>"},{"location":"user-guide/leverage-cli/installation/#verify-your-leverage-installation","title":"Verify your Leverage installation","text":"<p>Verify that your Leverage installation was successful by running <pre><code>$ leverage --help\nUsage: leverage [OPTIONS] COMMAND [ARGS]...\n\n  Leverage Reference Architecture projects command-line tool.\n\nOptions:\n  -f, --filename TEXT  Name of the build file containing the tasks\n                       definitions.  [default: build.py]\n-l, --list-tasks     List available tasks to run.\n  -v, --verbose        Increase output verbosity.\n  --version            Show the version and exit.\n  --help               Show this message and exit.\n\nCommands:\n  aws          Run AWS CLI commands in a custom containerized environment.\n  credentials  Manage AWS cli credentials.\n  kubectl      Run Kubectl commands in a custom containerized environment.\n  project      Manage a Leverage project.\n  run          Perform specified task(s) and all of its dependencies.\n  terraform    Run Terraform commands in a custom containerized...\n  tf           Run Terraform commands in a custom containerized...\n  tfautomv     Run TFAutomv commands in a custom containerized...\n</code></pre></p>"},{"location":"user-guide/leverage-cli/installation/#installation-in-an-isolated-environment","title":"Installation in an isolated environment","text":"<p>If you prefer not to install the Leverage package globally and would like to limit its influence to only the directory of your project, we recommend using tools like Pipenv or Poetry. These tools are commonly used when working with python applications and help manage common issues that may result from installing and using such applications globally.</p>"},{"location":"user-guide/leverage-cli/installation/#shell-completion","title":"Shell completion","text":"<p>To enable autocompletion for Leverage in your shell, do the following:</p> BashZshFish <p>Add to <code>~/.bashrc</code>: <pre><code>eval \"$(_LEVERAGE_COMPLETE=bash_source leverage)\"\n</code></pre></p> <p>Add to <code>~/.zshrc</code>: <pre><code>eval \"$(_LEVERAGE_COMPLETE=zsh_source leverage)\"\n</code></pre></p> <p>Add to <code>~/.config/fish/completions/leverage.fish</code>: <pre><code>eval (env _LEVERAGE_COMPLETE=fish_source leverage)\n</code></pre></p> <p>Or to avoid invoking <code>eval</code> every time a shell starts:</p> BashZshFish <p>Save the script: <pre><code>_LEVERAGE_COMPLETE=bash_source leverage &gt; ~/.leverage-complete.bash\n</code></pre> Source the script in <code>~/.bashrc</code>: <pre><code>. ~/.leverage-complete.bash\n</code></pre></p> <p>Save the script: <pre><code>_LEVERAGE_COMPLETE=zsh_source leverage &gt; ~/.leverage-complete.zsh\n</code></pre> Source the script in <code>~/.zshrc</code>: <pre><code>. ~/.leverage-complete.zsh\n</code></pre></p> <p>Save the script to <code>~/.config/fish/completions/leverage.fish</code>: <pre><code>_LEVERAGE_COMPLETE=fish_source leverage &gt; ~/.config/fish/completions/leverage.fish\n</code></pre></p> <p>Start a new shell in order to load any changes made to the shell config.</p>"},{"location":"user-guide/leverage-cli/overview/","title":"Overview","text":""},{"location":"user-guide/leverage-cli/overview/#leverage-cli","title":"Leverage CLI","text":""},{"location":"user-guide/leverage-cli/overview/#overview","title":"Overview","text":"<p>Leverage CLI is the tool used to manage and interact with any Leverage project.</p> <p>It transparently handles the most complex and error prone tasks that arise from working with a state-of-the-art infrastructure definition like our Leverage Reference Architecture. Leverage CLI uses a dockerized approach to encapsulate the tools needed to perform such tasks and to free the user from having to deal with the configuration and management of said tools.</p>"},{"location":"user-guide/leverage-cli/overview/#repositories","title":"Repositories","text":"<ul> <li> Source Code (Github)</li> <li> Releases Packages (PyPI)</li> </ul>"},{"location":"user-guide/leverage-cli/private-repositories/","title":"Private Repositories","text":""},{"location":"user-guide/leverage-cli/private-repositories/#working-with-terraform-modules-in-private-repos","title":"Working with Terraform modules in private repos","text":"<p>If it is the case that the layer is using a module from a private repository read the following. E.g.: <pre><code>module \"themodule\" {\nsource = \"git@gitlab.com:some-org/some-project/the-private-repo.git//modules/the-module?ref=v0.0.1\"\n...\n}\n</code></pre> where <code>gitlab.com:some-org/some-project/the-private-repo.git</code> is a private repo.</p>"},{"location":"user-guide/leverage-cli/private-repositories/#ssh-accessed-repository","title":"SSH accessed repository","text":"<p>To source a Terraform module from a private repository in a layer via an SSH connection these considerations have to be kept in mind.</p> <p>Leverage CLI will mount the host's SSH-Agent socket into the Leverage Toolbox container, this way your keys are accessed in a secure way.</p> <p>So, if an SSH private reporitory has to be accessed, the corresponding keys need to be loaded to the SSH-Agent.</p> <p>If the agent is automatically started and the needed keys added in the host system, it should work as it is.</p> <p>These steps should be followed otherwise:</p> <ul> <li> <p>start the SSH-Agent: <pre><code>$ eval \"$(ssh-agent -s)\"\n</code></pre></p> </li> <li> <p>add the keys to it <pre><code>$ ssh-add ~/.ssh/&lt;private_ssh_key_file&gt;\n</code></pre> (replace <code>private_ssh_key_file</code> with the desired file, the process can request the passphrase if it was set on key creation step)</p> </li> </ul>"},{"location":"user-guide/leverage-cli/private-repositories/#using-the-ssh-config-file-to-specify-the-key-that-must-be-used-for-a-given-host","title":"Using the SSH config file to specify the key that must be used for a given host","text":"<p>The ssh-agent socket is not always available in all the OS, like in Mac. So now our <code>leverage terraform init</code> command copies the ssh config file (and the whole .ssh directory) into the container volume, which means any custom configuration you have there, will be used. You can read more on the ssh official documentation.</p> <p>If, for example, you need to use a custom key for your private repositories on gitlab, you could add a block to your <code>ssh config</code> file, specifying:</p> <pre><code>host gitlab.com\n HostName gitlab.com\n IdentityFile ~/.ssh/my_gitlab_key\n</code></pre>"},{"location":"user-guide/leverage-cli/shell/","title":"Getting Shell Access","text":""},{"location":"user-guide/leverage-cli/shell/#the-shell-environment","title":"The shell environment","text":"<p>When launching a Terraform shell, Leverage provides the user with a completely isolated environment tailored to operate in the current project via a Docker container.</p> <p>The whole project is mounted on a directory named after the value for <code>project_long</code> in the global configuration file, or simply named <code>\"project\"</code> if this value is not defined. A project named <code>myexample</code>, would be mounted in <code>/myexample</code>.</p> <p>The <code>.gitconfig</code> user's file is also mounted on <code>/etc/gitconfig</code> for convenience, while (if <code>ssh-agent</code> is running), the socket stated in <code>SSH_AUTH_SOCK</code> is mounted on <code>/ssh-agent</code>. Also, the credentials files (<code>credentials</code> and <code>config</code>) found in the project AWS credentials directory (<code>~/.aws/myexample</code>), are mapped to the locations given by the environment variables <code>AWS_SHARED_CREDENTIALS_FILE</code> and <code>AWS_CONFIG_FILE</code> respectively within the container. </p>"},{"location":"user-guide/leverage-cli/shell/#authentication","title":"Authentication","text":"<p>Determining which credentials are needed to operate on a layer, and retrieving those credentials, may prove cumbersome for many complex layer definitions. In addition to that, correctly configuring them can also become a tedious an error prone process. For that reason Leverage automates this process upon launching the shell if requested by the user via the <code>shell</code> command options.</p> <p>Bear in mind, that an authenticated shell session's credentials are obtained for the layer in which the session was launched. These credentials may not be valid for other layers in which different roles need to be assumed or require more permissions.</p>"},{"location":"user-guide/leverage-cli/shell/#multi-factor-authentication","title":"Multi-Factor authentication","text":"<pre><code>leverage terraform shell --mfa\n</code></pre> <p>If MFA authentication is required, Leverage will prompt the user for the required tokens for the layer or use the cached credentials if still valid.</p> <p>The user's programmatic keys must be configured beforehand via <code>leverage credentials configure</code> command.</p>"},{"location":"user-guide/leverage-cli/shell/#single-sign-on","title":"Single-Sign On","text":"<p>If authentication via SSO is required, the user will need to configure or login into SSO before launching the shell via</p> <pre><code>leverage terraform shell --sso\n</code></pre>"},{"location":"user-guide/leverage-cli/shell/#operations-on-the-projects-layer","title":"Operations on the project's layer","text":"<p>In order to operate in a project's layer, Terraform commands such as <code>plan</code> or <code>apply</code> will need to receive extra parameters providing the location of the files that contain the definition of the variables required by the layer. Usually, these files are:</p> <ul> <li>the project global configuration file <code>common.tfvars</code></li> <li>the account configuration file <code>account.tfvars</code></li> <li>the terraform backend configuration file <code>backend.tfvars</code></li> </ul> <p>In this case these parameters should take the form: <pre><code>-var-file=/myexample/config/common.tfvars -var-file=/myexample/account/config/account.tfvars -var-file=/myexample/account/config/backend.tfvars`\n</code></pre></p> <p>Relative paths can prove useful when providing these locations. A layer definition may require more than just these files.</p> <p>So, for example, to apply changes on a standard Leverage Reference Architecture layer, the complete command would be: <pre><code>terraform apply -var-file=../../../config/common.tfvars -var-file=../../config/account.tfvars -var-file=../../config/backend.tfvars\n</code></pre> However, when initializing Terraform different parameters are needed, so it should be run as: <pre><code>terraform init -backend-config=../../config/backend.tfvars\n</code></pre></p>"},{"location":"user-guide/leverage-cli/extending-leverage/build.env/","title":"The build.env file","text":""},{"location":"user-guide/leverage-cli/extending-leverage/build.env/#override-defaults-via-buildenv-file","title":"Override defaults via <code>build.env</code> file","text":"<p>By utilizing the <code>build.env</code> capability, you can easily change some default behaviors of the CLI. In the binbash Leverage\u2122 Ref Architecture you will find the following <code>build.env</code> example as an example.  This allows you to specify several configurations for the CLI, such as the Leverage-Toolbox-Image you want to use, ensuring that you are using the latest version or a specific version that you prefer based on your compatibility requirements. This helps you avoid compatibility issues and ensures that your infrastructure deployments go smoothly.</p>"},{"location":"user-guide/leverage-cli/extending-leverage/build.env/#buildenv-file-format","title":"<code>build.env</code> file format","text":"<p>The <code>build.env</code> file format and supported parameters are the following:</p> <pre><code># Project settings\nPROJECT=bb\n\n# General\nMFA_ENABLED=false\n\n# Terraform\nTERRAFORM_IMAGE_TAG=1.2.7-0.1.4\n</code></pre> <p>Customizing or extending the leverage-toolbox docker image</p> <p>You can locally copy and edit the Dockerfile in order to rebuild it based on your needs, eg for a <code>Dockerfile</code> placed in the current working directory: <code>$ docker build -t binbash/leverage-toolbox:1.2.7-0.1.4 --build-arg TERRAFORM_VERSION='1.2.7' .</code> In case you like this changes to be permanent please consider  creating and submitting a PR.</p>"},{"location":"user-guide/leverage-cli/extending-leverage/build.env/#working-principle-multiple-buildenv-precedence","title":"Working principle &amp; multiple <code>build.env</code> precedence","text":"<p>The <code>leverage CLI</code> has an environmental variable loading utility that will load all <code>.env</code> files with the given name in  the current directory an all of its parents up to the repository root directory, and store them in a dictionary. Files are traversed from parent to child as to allow values in deeper directories to override possible previously existing values. Consider all files must bear the same name, which in our case defaults to <code>\"build.env\"</code>. So you can have multiple  <code>build.env</code> files that will be processed by the <code>leverage</code> CLI in the context of a specific layer of a  Reference Architecture project.  For example the /le-tf-infra-aws/apps-devstg/us-east-1/k8s-kind/k8s-resources/build.env file. </p>"},{"location":"user-guide/leverage-cli/extending-leverage/how-to-extend/","title":"Extending &amp; Configuring leverage CLI","text":""},{"location":"user-guide/leverage-cli/extending-leverage/how-to-extend/#override-defaults-via-buildenv-file","title":"Override defaults via <code>build.env</code> file","text":"<p>By utilizing the <code>build.env</code> capability, you can easily change some default behaviors of the CLI. This allows you to specify several configurations for the CLI,  such as the Leverage-Toolbox-Image that you want to use, ensuring that you are using the latest version or a specific version that you prefer based on your compatibility requirements.  This helps you avoid compatibility issues and ensures that your infrastructure deployments go smoothly. </p> <p>Read More about <code>build.env</code></p> <p>In order to further understand this mechanism and how to use it please visit the dedicated  build.env entry.</p>"},{"location":"user-guide/leverage-cli/extending-leverage/how-to-extend/#tfvars-config-files","title":"<code>.tfvars</code> config files","text":"<p>Using additional <code>.tfvars</code> configuration files at the account level or at the global level will allow you to extend your terraform configuration entries. Consider that using multiple <code>.tfvars</code> configuration files allows you to keep your  configuration entries well-organized. You can have separate files for different accounts or environments, making it easy to manage and maintain your infrastructure. This also makes it easier for other team members to understand and work with your configuration, reducing the risk of misconfigurations or errors.</p> <p>Read More about <code>.tfvars</code> config files</p> <p>In order to further understand this mechanism and how to use it please visit the dedicated .tfvars configs entry.</p>"},{"location":"user-guide/leverage-cli/extending-leverage/how-to-extend/#custom-tasks-with-buildpy","title":"Custom tasks with build.py","text":"<p>Leverage CLI has a native mechanism to allow customizing your workflow. With the custom tasks feature using <code>build.py</code>, you can write your own tasks using Python, tailoring the CLI to fit your specific workflow. This allows you to automate and streamline your infrastructure deployments, reducing the time and effort required to manage your infrastructure.  You can also easily integrate other tools and services into your workflow to further improve your productivity.</p> <p>Read More about <code>build.py</code> custom tasks</p> <p>In order to further understand this mechanism and how to use it please visit the dedicated build.py custom tasks entry.</p>"},{"location":"user-guide/leverage-cli/extending-leverage/how-to-extend/#fork-collaborate-and-improve","title":"Fork, collaborate and improve","text":"<p>By forking the leverage repository on GitHub and contributing to the project, you have the opportunity to make a positive impact on the product and the community. You can fix bugs, implement new  features, and contribute your ideas and feedback. This helps to ensure that the product continues to evolve and improve, serving the needs of the community and making infrastructure deployments easier for everyone.</p> <p>Read More about contributing with the project</p> <p>In order to further understand this mechanism and how to use it please visit the dedicated CONTRIBUTING.md entry.</p>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/","title":"Custom tasks","text":"<p>The same way we needed to automate or simplify certain tasks or jobs for the user, you may need to do the same in your project.</p> <p>Leverage CLI does not limit itself to provide only the core functionality required to create and manage your Leverage project, but also allows for the definition of custom tasks, at the <code>build.py</code> root context file, that can be used to add capabilities that are outside of Leverage CLI's scope.</p> <p>By implementing new auxiliary Leverage tasks you can achieve consistency and homogeneity in the experience of the user when interacting with your Leverage project and simplify the usage of any other tool that you may require.</p> <p>To check some common included tasks please see here</p>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#tasks","title":"Tasks","text":"<p>Tasks are simple python functions that are marked as such with the use of the <code>@task()</code> decorator. We call the file where all tasks are defined a 'build script', and by default it is assumed to be named <code>build.py</code>. If you use any other name for your build script, you can let Leverage know through the global option <code>--filename</code>.</p> <pre><code>from leverage import task\n\n@task()\ndef copy_file(src, dst):\n\"\"\"Copy src file to dst\"\"\"\n    print(f\"Copying {src} to {dst}\")\n</code></pre> <p>The contents in the task's docstring are used to provide a short description of what's the task's purpose when listing all available tasks to run.</p> <pre><code>$ leverage --list-tasks\nTasks in build file `build.py`:\n\n  copy_file               Copy src file to dst\n\nPowered by Leverage 1.0.10\n</code></pre> <p>Any argument that the task may receive are to be given when running the task. The syntax for passing arguments is similar to that of Rake.</p> <pre><code>$ leverage run copy_file[\"/path/to/foo\",\"/path/to/bar\"]\n[09:25:59.002] [ build.py - \u279c Starting task copy_file]\nCopying /path/to/foo to /path/to/bar\n[09:25:59.005] [ build.py - \u2714 Completed task copy_file ]\n</code></pre> <p>Keyworded arguments are also supported.</p> <pre><code>$ leverage run copy_file[\"/path/to/foo\",dst=\"/path/to/bar\"]\n</code></pre>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#dependencies","title":"Dependencies","text":"<p>The <code>task</code> decorator allows for the definition of dependencies. These are defined as positional arguments in the decorator itself. Multiple dependencies can be defined for each task.</p> <pre><code>from leverage import task\n@task()\ndef html(target=\".\"):\n\"\"\"Generate HTML.\"\"\"\n    print(f\"Generating HTML in directory \\\"{target}\\\"\")\n\n@task()\ndef images():\n\"\"\"Prepare images.\"\"\"\n    print(\"Preparing images...\")\n\n@task(html, images)\ndef start_server(host=\"localhost\", port=\"80\"):\n\"\"\"Start the server\"\"\"\n    print(f\"Starting server at {host}:{port}\")\n</code></pre> <p>We can see how the task <code>start_server</code> depends on both <code>html</code> and <code>images</code>. This means that both <code>html</code> and <code>images</code> will be executed before <code>start_server</code> and in that same order.</p> <pre><code>$ leverage run start_server\n[09:34:54.848] [ build.py - \u279c Starting task html ]\nGenerating HTML in directory \".\"\n[09:34:54.851] [ build.py - \u2714 Completed task html ]\n[09:34:54.852] [ build.py - \u279c Starting task images ]\nPreparing images...\n[09:34:54.854] [ build.py - \u2714 Completed task images ]\n[09:34:54.855] [ build.py - \u279c Starting task start_server ]\nStarting server at localhost:80\n[09:34:54.856] [ build.py - \u2714 Completed task start_server ]\n</code></pre>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#ignoring-a-task","title":"Ignoring a task","text":"<p>If you find yourself in the situation were there's a task that many other tasks depend on, and you need to quickly remove it from the dependency chains of all those tasks, ignoring its execution is a very simple way to achieve that end without having to remove all definitions and references across the code.</p> <p>To ignore or disable a task, simply set <code>ignore</code> to <code>True</code> in the task's decorator.</p> <p><pre><code>from leverage import task\n\n@task()\ndef html(target=\".\"):\n\"\"\"Generate HTML.\"\"\"\n    print(f\"Generating HTML in directory \\\"{target}\\\"\")\n\n@task(ignore=True)\ndef images():\n\"\"\"Prepare images.\"\"\"\n    print(\"Preparing images...\")\n\n@task(html, images)\ndef start_server(server=\"localhost\", port=\"80\"):\n\"\"\"Start the server\"\"\"\n    print(f\"Starting server at {server}:{port}\")\n</code></pre> <pre><code>$ leverage run start_server\n[09:38:32.819] [ build.py - \u279c Starting task html ]\nGenerating HTML in directory \".\"\n[09:38:32.822] [ build.py - \u2714 Completed task html ]\n[09:38:32.823] [ build.py - \u2933 Ignoring task images ]\n[09:38:32.824] [ build.py - \u279c Starting task start_server ]\nStarting server at localhost:80\n[09:38:32.825] [ build.py - \u2714 Completed task start_server ]\n</code></pre></p> <p>When listing the available tasks any ignored task will be marked as such.</p> <pre><code>$ leverage --list-tasks\nTasks in build file `build.py`:\n\n  html                      Generate HTML.\n  images        [Ignored]   Prepare images.\n  start_server              Start the server\n\nPowered by Leverage 1.0.10\n</code></pre>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#private-tasks","title":"Private tasks","text":"<p>Sometimes you may want to define auxiliary tasks that don't need to be shown as available to run by the user. For this scenario, you can make any task into a private one. There's two ways to accomplish this, either by naming the task with an initial underscore (<code>_</code>) or by setting <code>private</code> to <code>True</code> in the task's decorator.</p> <pre><code>from leverage import task\n\n@task(private=True)\ndef clean():\n\"\"\"Clean build directory.\"\"\"\n    print(\"Cleaning build directory...\")\n\n@task()\ndef _copy_resources():\n\"\"\"Copy resource files. This is a private task and will not be listed.\"\"\"\n    print(\"Copying resource files\")\n\n@task(clean, _copy_resources)\ndef html(target=\".\"):\n\"\"\"Generate HTML.\"\"\"\n    print(f\"Generating HTML in directory \\\"{target}\\\"\")\n\n@task(clean, _copy_resources, ignore=True)\ndef images():\n\"\"\"Prepare images.\"\"\"\n    print(\"Preparing images...\")\n\n@task(html, images)\ndef start_server(host=\"localhost\", port=\"80\"):\n\"\"\"Start the server\"\"\"\n    print(f\"Starting server at {host}:{port}\")\n</code></pre> <p>Private tasks will be executed, but not shown when tasks are listed.</p> <p><pre><code>$ leverage run start_server\n[09:40:33.535] [ build.py - \u279c Starting task clean ]\nCleaning build directory...\n[09:40:33.540] [ build.py - \u2714 Completed task clean ]\n[ build.py - \u279c Starting task _copy_resources ]\nCopying resource files\n[09:40:33.541] [ build.py - \u2714 Completed task _copy_resources ]\n[09:40:33.542] [ build.py - \u279c Starting task html ]\nGenerating HTML in directory \".\"\n[09:40:33.543] [ build.py - \u2714 Completed task html ]\n[09:40:33.544] [ build.py - \u279c Starting task images ]\nPreparing images...\n               [ build.py - \u2714 Completed task images ]\n[09:40:33.545] [ build.py - \u279c Starting task start_server ]\nStarting server at localhost:80\n[09:40:33.546] [ build.py - \u2714 Completed task start_server ]\n</code></pre> <pre><code>$ leverage --list-tasks\nTasks in build file `build.py`:\n\n  html              Generate HTML.\n  images            Prepare images.\n  start_server      Start the server\n\nPowered by Leverage 1.0.10\n</code></pre></p>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#default-task","title":"Default task","text":"<p>If you have a task that is run much more often than the rest, it can get tedious to always pass the name of that task to the <code>run</code> command. Leverage allows for the definition of a default task to address this situation. Thi task is executed when no task name is given.</p> <p>To define a default task, simply assign the already defined task to the special variable <code>__DEFAULT__</code>.</p> <pre><code>from leverage import task\n\n@task()\ndef html(target=\".\"):\n\"\"\"Generate HTML.\"\"\"\n    print(f\"Generating HTML in directory \\\"{target}\\\"\")\n\n@task(ignore=True)\ndef images():\n\"\"\"Prepare images.\"\"\"\n    print(\"Preparing images...\")\n\n@task(html, images)\ndef start_server(server=\"localhost\", port=\"80\"):\n\"\"\"Start the server\"\"\"\n    print(f\"Starting server at {server}:{port}\")\n\n__DEFAULT__ = start_server\n</code></pre> <p>The default task is marked as such when listing all available tasks.</p> <pre><code>$ leverage --list-tasks\nTasks in build file `build.py`:\n\n  html                      Generate HTML.\n  images        [Ignored]   Prepare images.\n  start_server  [Default]   Start the server\n\nPowered by Leverage 1.0.10\n</code></pre>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#build-scripts-lookup","title":"Build scripts lookup","text":"<p>Build scripts are not only looked up in the current directory but also in all parent directories up to the root of the Leverage project. This makes it possible to launch tasks form any directory of the project as long as any parent of the current directory holds a build script.</p>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#organizing-build-scripts","title":"Organizing build scripts","text":"<p>Leverage CLI treats the directory in which the build script is found as a python package. This means that you can break up your build files into modules and simply import them into your main build script, encouraging modularity and code reuse.</p> <p>Leverage CLI empowers you to create whole libraries of functionalities for your project. You can use it to better organize your tasks or implement simple auxiliary python functions.</p> <p>This way, given the following folder structure:</p> <pre><code>leverage_project\n\u251c\u2500\u2500 build.py\n\u251c\u2500\u2500 deployment_tasks.py\n\u251c\u2500\u2500 testing_tasks.py\n\u2514\u2500\u2500 auxiliary_library\n    \u251c\u2500\u2500 reports.py\n    \u2514\u2500\u2500 utils.py\n</code></pre> <p>The build script <code>build.py</code> can make use of definitions in the other files by means of importing them.</p> <pre><code>from .deployment_tasks import *\nfrom .testing_tasks import unit_tests, functional_tests\nfrom .auxiliary_library.reports import coverage_report\nfrom .auxiliary_library.utils import format_as_table\n</code></pre> <p>Importing user defined modules</p> <p>All import statements to user defined modules need to be relative to the main build script in order to function correctly.</p>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#known-issues","title":"Known issues","text":""},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#zsh-glob-patterns-zsh-no-matches-found","title":"Zsh Glob Patterns: <code>zsh: no matches found</code>","text":"<p>If you use <code>zsh</code> as your shell you might get the an error like this one: <code>zsh: no matches found: start_server[port=8000]</code></p> <p>The problem has to do with the square brackets, as zhs has glob patterns enabled by default which causes every input to be interpreted like that.</p> <p>The are a few workarounds:</p> <ol> <li> <p>Escape the square brackets: <code>leverage run start_server\\[port=8000\\]</code></p> </li> <li> <p>Enclose the entire task between double quotes: <code>leverage run \"start_server[port=8000]\"</code></p> </li> <li> <p>Disable glob patterns: <code>noglob leverage run start_server[port=8000]</code></p> </li> </ol> <p>An improvement over the last point is to create an alias for the leverage command: <code>alias leverage='noglob leverage'</code></p>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#folder-names-containing-periods","title":"Folder names containing periods","text":"<p>As mentioned in the Organizing build scripts section, Leverage CLI treats the directory in which the main build script is located as a python package in order to allow importing of user defined python modules. If this directory contains a period (<code>.</code>) in its name, this will create issues for the importing process. This is because the period is used by python to separate subpackages from their parents.</p> <p>For example, if the directory where the build script <code>build.py</code> is stored is named <code>local.assets</code>, at the time of loading the build script, python will try to locate <code>local.build</code> instead of locating <code>local.assets.build</code> and fail.</p> <p>The same situation will arise from any other subdirectory in the project. When importing modules from those directories, they wont be found.</p> <p>The simple solution to this is to avoid using periods when naming directories. If the build script is located in the project's root folder, this would also apply to that directory.</p>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#common-tasks","title":"Common tasks","text":"<p>These are the common tasks included with binbash Leverage:</p>"},{"location":"user-guide/leverage-cli/extending-leverage/tasks/#layer-dependency-check","title":"Layer Dependency Check","text":"<p>This tasks is aimed to help to determine the current layer dependencies.</p> <p>If the current layer is getting information from remote states in different layers, then these layers have to be run before the current layer, this is called a dependency.</p> <p>To run this task, <code>cd</code> into the desired layer and run:</p> <pre><code>leverage run layer_dependency\n</code></pre> <p>This is a sample output:</p> <pre><code>\u276f leverage run layer_dependency\n[10:37:41.817] [ build.py - \u279c Starting task _checkdir ]                                          [10:37:41.824] [ build.py - \u2714 Completed task _checkdir ]                                         [10:37:41.825] [ build.py - \u279c Starting task layer_dependency ]                                   \nNote layer dependency is calculated using remote states.\nNevertheless, other sort of dependencies could exist without this kind of resources,\ne.g. if you rely on some resource created in a different layer and not referenced here.\n{\n\"security\": {\n\"remote_state_name\": \"security\",\n  \"account\": \"apps-devstg\",\n  \"layer\": \"security-keys\",\n  \"key\": \"apps-devstg/security-keys/terraform.tfstate\",\n  \"key_raw\": \"${var.environment}/security-keys/terraform.tfstate\",\n  \"usage\": {\n\"used\": true,\n   \"files\": [\n\"/home/jdelacamara/Dev/work/BinBash/code/le-tf-infra-aws/apps-devstg/us-east-1/ec2-fleet-ansible --/ec2_fleet.tf\"\n]\n}\n},\n \"vpc\": {\n\"remote_state_name\": \"vpc\",\n  \"account\": \"apps-devstg\",\n  \"layer\": \"network\",\n  \"key\": \"apps-devstg/network/terraform.tfstate\",\n  \"key_raw\": \"${var.environment}/network/terraform.tfstate\",\n  \"usage\": {\n\"used\": true,\n   \"files\": [\n\"/home/jdelacamara/Dev/work/BinBash/code/le-tf-infra-aws/apps-devstg/us-east-1/ec2-fleet-ansible --/locals.tf\",\n    \"/home/jdelacamara/Dev/work/BinBash/code/le-tf-infra-aws/apps-devstg/us-east-1/ec2-fleet-ansible --/ec2_fleet.tf\"\n]\n}\n},\n \"vpc-shared\": {\n\"remote_state_name\": \"vpc-shared\",\n  \"account\": \"shared\",\n  \"layer\": \"network\",\n  \"key\": \"shared/network/terraform.tfstate\",\n  \"key_raw\": \"shared/network/terraform.tfstate\",\n  \"usage\": {\n\"used\": true,\n   \"files\": [\n\"/home/jdelacamara/Dev/work/BinBash/code/le-tf-infra-aws/apps-devstg/us-east-1/ec2-fleet-ansible --/ec2_fleet.tf\"\n]\n}\n}\n}\n[10:37:41.943] [ build.py - \u2714 Completed task layer_dependency ]\n</code></pre> <p>Data:</p> <ul> <li>\"remote_state_name\": the remote state name</li> <li>\"account\": the account the remote state belongs to</li> <li>\"layer\": the referenced layer</li> <li>\"key\": the key name (i.e. the <code>tfstate</code> file name for the remote state)</li> <li>\"key_raw\": the same as <code>key</code> but with variables not resolved</li> <li>\"usage\": if this remote state is used and in what files</li> </ul> <p>For a shorter version: <pre><code>\u276f leverage run layer_dependency\\['summary=True'\\]\n[10:47:00.461] [ build.py - \u279c Starting task _checkdir ]                                          [10:47:00.467] [ build.py - \u2714 Completed task _checkdir ]                                         [ build.py - \u279c Starting task layer_dependency ]                                   \nNote layer dependency is calculated using remote states.\nNevertheless, other sort of dependencies could exist without this kind of resources,\ne.g. if you rely on some resource created in a different layer and not referenced here.\n{\n\"this\": [\n\"apps-devstg/security-keys/terraform.tfstate\",\n  \"apps-devstg/network/terraform.tfstate\",\n  \"shared/network/terraform.tfstate\"\n]\n}\n[10:47:00.489] [ build.py - \u2714 Completed task layer_dependency ]  </code></pre></p> <p>If you already have a binbash Leverage project created, you can download this file into your project root dir and add this import to your <code>build.py</code>:</p> <pre><code>from build_deplayerchk import *\n</code></pre>"},{"location":"user-guide/leverage-cli/reference/aws/","title":"Command: <code>aws</code>","text":"<p>The <code>aws</code> command is a wrapper for a containerized installation of AWS CLI 2.0. All commands are passed directly to the AWS CLI and you should expect the same behavior from all of them, except for the few exceptions listed below.</p>"},{"location":"user-guide/leverage-cli/reference/aws/#configure-sso","title":"<code>configure sso</code>","text":""},{"location":"user-guide/leverage-cli/reference/aws/#usage","title":"Usage","text":"<pre><code>leverage aws configure sso\n</code></pre> <p>Extracts information from the project's Terraform configuration to generate the required profiles for AWS CLI to handle SSO.</p> <p>In the process, you will need to log in via your identity provider. To allow you to do this, Leverage will attempt to open the login page in the system's default browser.</p>"},{"location":"user-guide/leverage-cli/reference/aws/#sso-login","title":"<code>sso login</code>","text":""},{"location":"user-guide/leverage-cli/reference/aws/#usage_1","title":"Usage","text":"<pre><code>leverage aws sso login\n</code></pre> <p>It wraps <code>aws sso login</code> taking extra steps to allow <code>Leverage</code> to use the resulting token while is valid.</p>"},{"location":"user-guide/leverage-cli/reference/aws/#sso-logout","title":"<code>sso logout</code>","text":""},{"location":"user-guide/leverage-cli/reference/aws/#usage_2","title":"Usage","text":"<pre><code>leverage aws sso logout</code></pre> <p>It wraps <code>aws sso logout</code> taking extra steps to make sure that all tokens and temporary credentials are wiped from the system. It also reminds the user to log out form the AWS SSO login page and identity provider portal. This last action is left to the user to perform.</p> <p>Important</p> <p>Please keep in mind that this command will not only remove temporary credentials but also the AWS config file. If you use such file to store your own configuration please create a backup before running the <code>sso logout</code> command.</p>"},{"location":"user-guide/leverage-cli/reference/credentials/","title":"Command: <code>credentials</code>","text":"<p>The <code>credentials</code> command is used to set up and manage the AWS CLI credentials required to interact with the AWS environment.</p> <p>All <code>credentials</code>'s subcommands feed off the <code>project.yaml</code>, <code>build.env</code>, and Terraform configuration files to obtain the information they need. In case the basic required information is not found, the subcommands will prompt the user for it.</p>"},{"location":"user-guide/leverage-cli/reference/credentials/#configure","title":"<code>configure</code>","text":""},{"location":"user-guide/leverage-cli/reference/credentials/#usage","title":"Usage","text":"<pre><code>leverage credentials configure --type [BOOTSTRAP|MANAGEMENT|SECURITY] [options]\n</code></pre> <p>The <code>credentials configure</code> command sets up the credentials needed to interact with the AWS environment, from the initial deployment process (<code>BOOTSTRAP</code>) to everyday management (<code>MANAGEMENT</code>) and development or use (<code>SECURITY</code>) of it.</p> <p>It attempts to retrieve the structure of the organization in order to generate all the AWS CLI profiles required to interact with the environment and update the terraform configuration with the id of all relevant accounts.</p> <p>Backups of the previous configured credentials files are always created when overwriting or updating the current ones.</p>"},{"location":"user-guide/leverage-cli/reference/credentials/#options","title":"Options","text":"<ul> <li><code>--type</code>: Type of the credentials to set. Can be any of <code>BOOTSTRAP</code>, <code>MANAGEMENT</code> or <code>SECURITY</code>. This option is case insensitive. This option is required.</li> <li><code>--credentials-file</code>: Path to a <code>.csv</code> credentials file, as produced by the AWS Console, containing the user's programmatic access keys. If not given, the user will be prompted for the credentials.</li> <li><code>--fetch-mfa-device</code>: Retrieve an MFA device serial from AWS for the current user.</li> <li><code>--overwrite-existing-credentials</code>: If the type of credentials being configured is already configured, overwrite current configuration. Mutually exclusive option with <code>--skip-access-keys-setup</code>.</li> <li><code>--skip-access-keys-setup</code>: Skip the access keys configuration step. Continue on to setting up the accounts profiles. Mutually exclusive option with <code>--overwrite-existing-credentials</code>.</li> <li><code>--skip-assumable-roles-setup</code>: Don't configure each account profile to assume their specific role.</li> </ul> <p>If neither of <code>--overwrite-existing-credentials</code> or <code>--skip-access-keys-setup</code> is given, the user will be prompted to choose between both actions when appropriate.</p>"},{"location":"user-guide/leverage-cli/reference/kubectl/","title":"Command: <code>kubectl</code>","text":"<p>Regarding Leverage Toolbox versions</p> <p>To have this feature available, Leverage Toolbox versions <code>1.2.7-0.1.7</code> and up, or <code>1.3.5-0.1.7</code> and up must be used.</p> <p>The <code>kubectl</code> command is a wrapper for a containerized installation of kubectl. It provides the kubectl executable with specific configuration values required by Leverage.</p> <p>It transparently handles authentication, whether it is Multi-Factor or via Single Sign-On, on behalf of the user in the commands that require it. SSO Authentication takes precedence over MFA when both are active. </p> <p>The sub-commands can only be run at layer level and will not run anywhere else in the project. The sub-command <code>configure</code> can only be run at an EKS cluster layer level. Usually called <code>cluster</code>.</p> <p>The command can also be invoked via its shortened version <code>kc</code>.</p> <p>Configuring on first use</p> <p>To start using this command, you must first run <code>leverage kubectl configure</code> on a <code>cluster</code> layer,</p> <p>to set up the credentials on the proper config file.</p>"},{"location":"user-guide/leverage-cli/reference/kubectl/#run","title":"<code>run</code>","text":""},{"location":"user-guide/leverage-cli/reference/kubectl/#usage","title":"Usage","text":"<pre><code>leverage kubectl [commands] [arguments]\n</code></pre> <p>Equivalent to <code>kubectl</code>.</p> <p>All arguments given are passed as received to kubectl. </p> <p>Example:</p> <pre><code>leverage kubectl get pods --namespace monitoring\n</code></pre>"},{"location":"user-guide/leverage-cli/reference/kubectl/#shell","title":"<code>shell</code>","text":""},{"location":"user-guide/leverage-cli/reference/kubectl/#usage_1","title":"Usage","text":"<pre><code>leverage kubectl shell\n</code></pre> <p>Open a shell into the Kubectl container in the current directory.</p>"},{"location":"user-guide/leverage-cli/reference/kubectl/#configure","title":"<code>configure</code>","text":""},{"location":"user-guide/leverage-cli/reference/kubectl/#usage_2","title":"Usage","text":"<pre><code>leverage kubectl configure\n</code></pre> <p>Add the cluster from the EKS layer into your kubectl config file. Equivalent to <code>aws eks update-kubeconfig ...</code>.</p>"},{"location":"user-guide/leverage-cli/reference/project/","title":"Command: <code>project</code>","text":"<p>The <code>project</code> command is used to execute global operations on the project.</p>"},{"location":"user-guide/leverage-cli/reference/project/#init","title":"<code>init</code>","text":""},{"location":"user-guide/leverage-cli/reference/project/#usage","title":"Usage","text":"<pre><code>leverage project init\n</code></pre> <p>The <code>project init</code> subcommand initializes a Leverage project in the current directory. If not found, it also initializes the global config directory for Leverage CLI <code>~/.leverage/</code>, and fetches the template for the projects' creation.</p> <p>It then proceeds to drop a template file for the project configuration called <code>project.yaml</code> and initializes a <code>git</code> repository in the directory.</p>"},{"location":"user-guide/leverage-cli/reference/project/#create","title":"<code>create</code>","text":""},{"location":"user-guide/leverage-cli/reference/project/#usage_1","title":"Usage","text":"<pre><code>leverage project create\n</code></pre> <p>The <code>project create</code> subcommand creates the files structure for the architecture in the current directory and configures it based on the values set in the <code>project.yaml</code> file.</p> <p>It will then proceed to make sure all files follow the standard Terraform code style.</p>"},{"location":"user-guide/leverage-cli/reference/run/","title":"Command: <code>run</code>","text":"<p>The <code>run</code> command is used to execute user defined tasks and all of their dependencies.</p> <p> Custom tasks documentation</p>"},{"location":"user-guide/leverage-cli/reference/run/#usage","title":"Usage","text":"<pre><code>leverage run [tasks]\n</code></pre> <p>An arbitrary number of tasks can be given to the command. All tasks given must be in the form of the task name optionally followed by arguments that the task may require enclosed in square brackets, i.e. <code>TASK_NAME[TASK_ARGUMENTS]</code>. The execution respects the order in which they were provided.</p> <p>If no tasks are given, the default task will be executed. In case no default task is defined, the command will list all available tasks to run.</p> <p>Example: <pre><code>leverage run task1 task2[arg1,arg2] task3[arg1,kwarg1=val1,kwarg2=val2]\n</code></pre></p> <ul> <li> <p><code>task1</code> is invoked with no arguments, which is equivalent to <code>task1[]</code></p> </li> <li> <p><code>task2</code> receives two positional arguments <code>arg1</code> and <code>arg2</code></p> </li> <li> <p><code>task3</code> receives one positional argument <code>arg1</code> and two keyworded arguments <code>kwarg1</code> with value <code>val1</code> and <code>kwarg2</code> with value <code>val2</code></p> </li> </ul>"},{"location":"user-guide/leverage-cli/reference/shell/","title":"Command: <code>shell</code>","text":"<p>Run a shell in a generic container. It supports mounting local paths and injecting arbitrary environment variables. It also supports AWS credentials injection via mfa/sso.</p> <pre><code>&gt;&gt; leverage shell --help\n\nUsage: leverage shell [OPTIONS]\n\nRun a shell in a generic container. It supports mounting local paths and\n  injecting arbitrary environment variables. It also supports AWS credentials\n  injection via mfa/sso.\n\n  Syntax: leverage shell --mount &lt;local-path&gt; &lt;container-path&gt; --env-var &lt;name&gt; &lt;value&gt;\n  Example: leverage shell --mount /home/user/bin/ /usr/bin/ --env-var env dev\n\n  Both mount and env-var parameters can be provided multiple times.\n  Example: leverage shell --mount /home/user/bin/ /usr/bin/ --mount /etc/config.ini /etc/config.ini --env-var init 5 --env-var env dev\n\nOptions:\n  --mount &lt;TEXT TEXT&gt;...\n  --env-var &lt;TEXT TEXT&gt;...\n  --mfa                     Enable Multi Factor Authentication upon launching shell.\n  --sso                     Enable SSO Authentication upon launching shell.\n  --help                    Show this message and exit.\n</code></pre>"},{"location":"user-guide/leverage-cli/reference/terraform/","title":"Command: <code>terraform</code> | <code>tf</code>","text":"<p>The <code>terraform</code> command is a wrapper for a containerized installation of Terraform. It provides the Terraform executable with specific configuration values required by Leverage.</p> <p>It transparently manages authentication, either Multi-Factor or Single Sign-On, on behalf of the user on commands that require it. SSO authentication takes precedence over MFA when both are active.</p> <p>Some commands can only be run at layer level and will not run anywhere else in the project.</p> <p>The command can also be invoked via its shortened version <code>tf</code>.</p> <p>Since version 1.12, all the subcommands supports <code>--mount</code> and <code>--env-var</code> parameters in form of tuples:</p> <pre><code>leverage terraform --mount /home/user/bin/ /usr/bin/ --env-var FOO BAR apply\n</code></pre> <p>You can also provide them multiple times: <pre><code>leverage terraform --mount /usr/bin/ /usr/bin/ --mount /etc/config /config --env-var FOO BAR --env-var TEST OK init\n</code></pre></p>"},{"location":"user-guide/leverage-cli/reference/terraform/#init","title":"<code>init</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage","title":"Usage","text":"<pre><code>leverage terraform init [option] [arguments]\n</code></pre> <p>Equivalent to <code>terraform init</code>.</p> <p>All arguments given are passed as received to Terraform.</p> <p>Can only be run at layer level if <code>--layers</code> is not set, or at account or layers-container-directory if it is.</p> <p>Layout validation is performed before actually initializing Terraform unless explicitly indicated against via the <code>--skip-validation</code> flag.</p>"},{"location":"user-guide/leverage-cli/reference/terraform/#options","title":"Options","text":"<ul> <li><code>--skip-validation</code>: Skips layout validation.</li> <li><code>--layers</code>: Applies command to layers listed in this option. (see more info here)</li> </ul> <p>Regarding S3 backend keys</p> <p>If the S3 backend block is set, and no key was defined, Leverage CLI will try to create a new one autoatically and store it in the <code>config.tf</code> file. It will be based on the layer path relative to the account.</p>"},{"location":"user-guide/leverage-cli/reference/terraform/#plan","title":"<code>plan</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage_1","title":"Usage","text":"<pre><code>leverage terraform plan [arguments]\n</code></pre> <p>Equivalent to <code>terraform plan</code>.</p> <p>All arguments given are passed as received to Terraform.</p> <p>Can only be run at layer level if <code>--layers</code> is not set, or at account or layers-container-directory if it is.</p>"},{"location":"user-guide/leverage-cli/reference/terraform/#options_1","title":"Options","text":"<ul> <li><code>--layers</code>: Applies command to layers listed in this option. (see more info here)</li> </ul>"},{"location":"user-guide/leverage-cli/reference/terraform/#apply","title":"<code>apply</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage_2","title":"Usage","text":"<pre><code>leverage terraform apply [arguments]\n</code></pre> <p>Equivalent to <code>terraform apply</code>.</p> <p>All arguments given are passed as received to Terraform.</p> <p>Can only be run at layer level if <code>--layers</code> is not set, or at account or layers-container-directory if it is.</p>"},{"location":"user-guide/leverage-cli/reference/terraform/#options_2","title":"Options","text":"<ul> <li><code>--layers</code>: Applies command to layers listed in this option. (see more info here)</li> </ul>"},{"location":"user-guide/leverage-cli/reference/terraform/#destroy","title":"<code>destroy</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage_3","title":"Usage","text":"<pre><code>leverage terraform destroy [arguments]\n</code></pre> <p>Equivalent to <code>terraform destroy</code>.</p> <p>All arguments given are passed as received to Terraform.</p> <p>Can only be run at layer level if <code>--layers</code> is not set, or at account or layers-container-directory if it is.</p>"},{"location":"user-guide/leverage-cli/reference/terraform/#options_3","title":"Options","text":"<ul> <li><code>--layers</code>: Applies command to layers listed in this option. (see more info here)</li> </ul>"},{"location":"user-guide/leverage-cli/reference/terraform/#output","title":"<code>output</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage_4","title":"Usage","text":"<pre><code>leverage terraform output [arguments]\n</code></pre> <p>Equivalent to <code>terraform output</code>.</p> <p>All arguments given are passed as received to Terraform.</p> <p>Can only be run at layer level if <code>--layers</code> is not set, or at account or layers-container-directory if it is.</p>"},{"location":"user-guide/leverage-cli/reference/terraform/#options_4","title":"Options","text":"<ul> <li><code>--layers</code>: Applies command to layers listed in this option. (see more info here)</li> </ul>"},{"location":"user-guide/leverage-cli/reference/terraform/#version","title":"<code>version</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage_5","title":"Usage","text":"<pre><code>leverage terraform version\n</code></pre> <p>Equivalent to <code>terraform version</code>.</p> <p>Print Terraform version.</p>"},{"location":"user-guide/leverage-cli/reference/terraform/#shell","title":"<code>shell</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage_6","title":"Usage","text":"<pre><code>leverage terraform shell [option]\n</code></pre> <p>Open a shell into the Terraform container in the current directory. An authenticated shell can only be opened at layer level.</p> <p> Terraform shell environment documentation</p>"},{"location":"user-guide/leverage-cli/reference/terraform/#options_5","title":"Options","text":"<ul> <li><code>--mfa</code>: Authenticate via MFA upon launching shell.</li> <li><code>--sso</code>: Authenticate via SSO upon launching shell.</li> </ul> <p>Note: When <code>--sso</code> flag is used, the <code>--mfa</code> flag status is ignored.</p> <p>What if I want to run a Terraform command that is not supported by the CLI?</p> <p>One common error you could encounter is <code>\"Error acquiring the state lock\"</code>, where you might need to use <code>force-unlock</code>. You can do the following:</p> <ol> <li><code>leverage terraform shell --sso</code>.       </li> <li>Then from inside the container: <code>terraform force-unlock LOCK-ID</code>.</li> </ol>"},{"location":"user-guide/leverage-cli/reference/terraform/#format","title":"<code>format</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage_7","title":"Usage","text":"<pre><code>leverage terraform format [arguments]\n</code></pre> <p>Equivalent to <code>terraform fmt -recursive</code>.</p> <p>Recursively format all files in the architecture to the Terraform code style.</p> <p>All arguments given are passed as received to Terraform.</p>"},{"location":"user-guide/leverage-cli/reference/terraform/#validate","title":"<code>validate</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage_8","title":"Usage","text":"<pre><code>leverage terraform validate\n</code></pre> <p>Equivalent to <code>terraform validate</code>.</p> <p>Check the infrastructure definition's consistency.</p>"},{"location":"user-guide/leverage-cli/reference/terraform/#validate-layout","title":"<code>validate-layout</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage_9","title":"Usage","text":"<pre><code>leverage terraform validate-layout\n</code></pre> <p>Check the Terraform backend configuration in the code definition.</p> <p>When you are setting up the backend layer for the very first time, the S3 bucket does not yet exist. When running validations, Leverage CLI will detect that the S3 Key does not exist or cannot be generated. Therefore, it is necessary to first create the S3 bucket by using the init <code>--skip-validation</code> flag in the initialization process, and then move the \"tfstate\" file to it.</p> <p>Values checked:</p> <ul> <li>Environment name in account configuration</li> <li>S3 bucket key</li> <li>AWS CLI profile name prefix</li> <li>S3 Bucket name prefix</li> <li>DynamoDB locking table name prefix</li> </ul>"},{"location":"user-guide/leverage-cli/reference/terraform/#import","title":"<code>import</code>","text":""},{"location":"user-guide/leverage-cli/reference/terraform/#usage_10","title":"Usage","text":"<pre><code>leverage terraform import ADDRESS ID\n</code></pre> <p>Equivalent to <code>terraform import</code>.</p> <p>Import the resource with the given ID into the Terraform state at the given ADDRESS.</p> <p>Can only be run at layer level.</p> <p>zsh globbing</p> <p>Zsh users may need to prepend <code>noglob</code> to the import command for it to be recognized correctly, as an alternative, square brackets can be escaped as <code>\\[\\]</code></p> <p>Examples:</p> <ul> <li>Opt-1:  <code>leverage tf import module.s3_bucket.aws_s3_bucket.this\\[0\\] s3-bag-data-bucket</code></li> <li>Opt-2:  <code>noglob leverage tf import module.s3_bucket.aws_s3_bucket.this[0] s3-bag-data-bucket</code> </li> </ul>"},{"location":"user-guide/leverage-cli/reference/tfautomv/","title":"Command: <code>tfautomv</code>","text":"<p>Regarding Leverage Toolbox versions</p> <p>For using this feature Leverage Toolbox versions <code>1.2.7-0.0.5</code> and up, or <code>1.3.5-0.0.1</code> and up must be used.</p> <p>The <code>tfautomv</code> command is a wrapper for a containerized installation of tfautomv. It provides the tfautomv executable with specific configuration values required by Leverage.</p> <p>It transparently handles authentication, whether it is Multi-Factor or via Single Sign-On, on behalf of the user in the commands that require it. SSO Authentication takes precedence over MFA when both are active. </p> <p>This command can only be run at layer level and will not run anywhere else in the project.</p>"},{"location":"user-guide/leverage-cli/reference/tfautomv/#run","title":"<code>run</code>","text":""},{"location":"user-guide/leverage-cli/reference/tfautomv/#usage","title":"Usage","text":"<pre><code>leverage tfautomv run [arguments]\n</code></pre> <p>Equivalent to <code>tfautomv</code>.</p> <p>All arguments given are passed as received to tfautomv. </p> <p>Example:</p> <pre><code>leverage tfautomv run --show-analysis --dry-run\n</code></pre>"},{"location":"user-guide/leverage-cli/reference/terraform/layers/","title":"Layers parameter","text":"<p>This parameter can be used with the following Leverage CLI Terraform commands:</p> <ul> <li><code>init</code></li> <li><code>plan</code></li> <li><code>apply</code></li> <li><code>output</code></li> <li><code>destroy</code></li> </ul> <p>Value:</p> Parameter Type Description <code>--layers</code> string A comma serparated list of layer's relative paths"},{"location":"user-guide/leverage-cli/reference/terraform/layers/#common-workflow","title":"Common workflow","text":"<p>When using the <code>--layers</code> parameter, these commands should be run from <code>account</code> or <code>layers-container-directory</code> directories.</p> <p>Example:</p> <p>For this structure:</p> <pre><code> home\n \u251c\u2500\u2500 user\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 project\n \u2502\u00a0\u00a0     \u2514\u2500\u2500 management\n \u2502\u00a0\u00a0         \u251c\u2500\u2500 global\n \u2502\u00a0\u00a0         |   \u2514\u2500\u2500 security-base\n \u2502\u00a0\u00a0         |   \u2514\u2500\u2500 sso\n \u2502\u00a0\u00a0         \u2514\u2500\u2500 us-east-1\n \u2502\u00a0\u00a0             \u2514\u2500\u2500 terraform-backend\n</code></pre> <p>...any of the aforementioned commands, combined with <code>--layers</code>, can be called from <code>/home/user/project/management/</code>, <code>/home/user/project/management/global/</code> or <code>/home/user/project/management/us-east-1/</code>.</p> <p>The value for this parameter is a comma separated list of layer's relative paths.</p> <p>Leverage CLI will iterate through the layer's relative paths, going into each one, executing the command and going back to the original directory.</p> <p>Example:</p> <p>For this command, from <code>/home/user/project/management/</code>:</p> <pre><code>leverage tf plan --layers us-east-1/terraform-backend,global/security-base\n</code></pre> <p>...the Leverage CLI will:</p> <ul> <li>check each one of the layer's relative paths exists</li> <li>go into <code>us-east-1/terraform-backend</code> directory</li> <li>run the <code>plan</code> command</li> <li>go back to <code>/home/user/project/management/</code></li> <li>go into <code>global/security-base</code> directory</li> <li>run the <code>plan</code> command</li> <li>go back to <code>/home/user/project/management/</code></li> </ul>"},{"location":"user-guide/leverage-cli/reference/terraform/layers/#the-init-case","title":"The <code>init</code> case","text":"<p>When running <code>init</code> Leverage CLI runs a validation.</p> <p>When using the <code>--layers</code> option, the validation is run for every layer before the command itself is run.</p> <p>Example:</p> <p>For this command, from <code>/home/user/project/management/</code>:</p> <pre><code>leverage tf init --layers us-east-1/terraform-backend,global/security-base\n</code></pre> <p>...the Leverage CLI will:</p> <ul> <li>check each one of the layer's relative paths exists</li> <li>go into <code>us-east-1/terraform-backend</code> directory</li> <li>run the <code>validate-layout</code> command</li> <li>go back to <code>/home/user/project/management/</code></li> <li>go into <code>global/security-base</code> directory</li> <li>run the <code>validate-layout</code> command</li> <li>go back to <code>/home/user/project/management/</code></li> <li>go into <code>us-east-1/terraform-backend</code> directory</li> <li>run the <code>init</code> command</li> <li>go back to <code>/home/user/project/management/</code></li> <li>go into <code>global/security-base</code> directory</li> <li>run the <code>init</code> command</li> <li>go back to <code>/home/user/project/management/</code></li> </ul> <p>This is done this way to prevent truncated executions. Meaning, if any of the validation fails, the user will be able to fix whatever has to be fixed and run the command again as it is.</p> <p>Skipping the validation</p> <p>The <code>--skip-validation</code> flag still can be used here with <code>--layers</code>.</p>"},{"location":"user-guide/leverage-cli/reference/terraform/layers/#terraform-parameters-and-flags","title":"Terraform parameters and flags","text":"<p>Terraform parameters and flags can still be passed when using the <code>--layers</code> parameter.</p> <p>Example:</p> <pre><code>leverage tf apply --layers us-east-1/terraform-backend,global/security-base -auto-approve\n</code></pre>"},{"location":"user-guide/playbooks/","title":"Playbooks","text":"<ul> <li> VPC with no Landing Zone</li> <li> Start/Stop EC2/RDS instances using schedule or manual endpoint</li> <li> Calculate VPC subnet CIDRs</li> </ul>"},{"location":"user-guide/playbooks/VPC-subnet-calculator/","title":"How to calculate the VPC subnet CIDRs?","text":"<p>To calculate subnets this calculator can be used</p> <p>Note in this link a few params were added: the base network and mask, and the division number. In this case the example is for the <code>shared</code> account networking.</p> <p>This table will be shown:  </p> <p>Note how this information is set in the tf file:</p> <pre><code>  vpc_cidr_block = \"172.18.0.0/20\"\nazs = [\n\"${var.region}a\",\n\"${var.region}b\"\n]\n\nprivate_subnets_cidr = [\"172.18.0.0/21\"]\nprivate_subnets = [\n\"172.18.0.0/23\",\n\"172.18.2.0/23\"\n]\n\npublic_subnets_cidr = [\"172.18.8.0/21\"]\npublic_subnets = [\n\"172.18.8.0/23\",\n\"172.18.10.0/23\"\n]\n</code></pre> <p>Note the main CIDR is being used for the VPC. See on the left how the <code>/20</code> encompasses all the rows.</p> <p>Then two divisions for <code>/21</code>. Note the first subnet address of the first row for each one is being used for <code>private_subnets_cidr</code> and <code>public_subnets_cidr</code>.</p> <p>Finally the <code>/23</code> are being used for each subnet.</p> <p>Note we are using the first two subnet addresses for each <code>/21</code>. This is due to we are reserving the other two to allow adding more AZs in the future. (up to two in this case)</p> <p>If you want you can take as a reference this page to select CIDRs for each account.</p>"},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/","title":"VPC with no Landing Zone","text":""},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/#what","title":"What","text":"<p>Do you want to try binbash Leverage but you are not willing to transform yet your already existent infra to the binbash Leverage Landing Zone (honoring the AWS Well Architected Framework)?</p> <p>With this playbook you will create a VPC with all the benefits binbash Leverage network layer provides.</p> <p>If you want to use the Full binbash Leverage Landing Zone please visit the Try Leverage section</p> <p>This will give you the full power of binbash Leverage and the AWS Well Architected Framework.</p>"},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/#why","title":"Why","text":"<p>Maybe because you found binbash Leverage but you want to try it out first before you convert your base infra.</p>"},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/#how","title":"How","text":""},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/#objective","title":"Objective","text":"<p>We will create a simple VPC (with all its resources) and an will add an EC2 instance to it so we can test it for real.</p>"},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/#what-you-need","title":"What you need:","text":"<ul> <li>an AWS account</li> <li>a user with programmatic access keys and the keys</li> <li>binbash Leverage</li> </ul>"},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/#common-process","title":"Common Process","text":"<p>Ok, just install binbash Leverage and create the Leverage project. When creating credentials, do it for MANAGEMENT type.  Basically: <pre><code>mkdir project &amp;&amp; cd project\nleverage project init\n## edit the yaml file\nleverage project create\nleverage credentials configure --type MANAGEMENT\n</code></pre></p> <p>You end up with this structure: <pre><code>\u276f tree -L 2 .\n.\n\u251c\u2500\u2500 build.env\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 common.tfvars\n\u251c\u2500\u2500 management\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 global\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 us-east-1\n\u251c\u2500\u2500 Pipfile\n\u251c\u2500\u2500 Pipfile.lock\n\u251c\u2500\u2500 project.yaml\n\u251c\u2500\u2500 security\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 us-east-1\n\u2514\u2500\u2500 shared\n    \u251c\u2500\u2500 config\n    \u2514\u2500\u2500 us-east-1\n</code></pre></p> <p>Create a dummy account dir.</p> <p>Despite we won't create a real account (since there is no Landing Zone), we'll have to create a dir to hold all the layers we need.</p> <pre><code>mkdir -p apps-dummy/us-east-1/\n</code></pre> <p>Copy the config files:</p> <pre><code>cp -r shared/config apps-dummy/\n</code></pre> <p>In <code>config/account.tfvars</code> change this: <pre><code>## Environment Name\nenvironment = \"shared\"\n</code></pre> to this <pre><code>## Environment Name\nenvironment = \"apps-dummy\"\n</code></pre> (note the environment is the same as the created dir)</p> <p>In <code>config/backend.tfvars</code> change this: <pre><code>profile = \"bm-shared-oaar\"\n</code></pre> to this: <pre><code>profile = \"bm-management\"\n</code></pre></p>"},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/#vpc-process","title":"VPC Process","text":"<p>Copy the network layer:</p> <pre><code>cp -r shared/us-east-1/base-network apps-dummy/us-east-1/\n</code></pre> <p>Go into the layer:</p> <pre><code>cp -r shared/us-east-1/base-network apps-dummy/us-east-1/\ncd apps-dummy/us-east-1/base-network\n</code></pre> <p>Since we are testing we won't use the S3 backend (we didn't create the bucket, but you can do it easily with the <code>base-tf-backend</code> layer), so comment this line in <code>config.tf</code> file:</p> <pre><code>  #backend \"s3\" {\n#  key = \"shared/network/terraform.tfstate\"\n#}\n</code></pre> <p>Initialize the layer:</p> <pre><code>leverage tf init --skip-validation\n</code></pre> <p>Note the <code>skip-validation</code> flag. This is needed since we are using local tfstate.</p> <p>Plan it: <pre><code>leverage tf plan\n</code></pre></p> <p>If you are happy (or you are unhappy but you are ok with the plan), apply it: <pre><code>leverage tf apply\n</code></pre></p> <p>You should end up with something like this: <pre><code>Apply complete! Resources: 20 added, 0 changed, 0 destroyed.\n\nOutputs:\n\navailability_zones = [\n\"us-east-1a\",\n  \"us-east-1b\",\n]\nnat_gateway_ids = []\nprivate_route_table_ids = [\n\"rtb-065deXXXXXXX86b6d\",\n]\nprivate_subnets = [\n\"subnet-0aXXXXXXXXXXd80a6\",\n  \"subnet-0bXXXXXXXXXX0ff67\",\n]\nprivate_subnets_cidr = [\n\"172.18.0.0/21\",\n]\npublic_route_table_ids = [\n\"rtb-01XXXXXXXXXXXX887\",\n]\npublic_subnets = [\n\"subnet-0648XXXXXXXXX69\",\n  \"subnet-0297XXXXXXXXf10\",\n]\npublic_subnets_cidr = [\n\"172.18.8.0/21\",\n]\nvpc_cidr_block = \"172.18.0.0/20\"\nvpc_id = \"vpc-0aXXXXXXXXXX06d8f\"\nvpc_name = \"bm-apps-dummy-vpc\"\n</code></pre></p>"},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/#ec2-process","title":"EC2 Process","text":"<p>Great, now we can go for the EC2!</p>"},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/#get-the-layer","title":"Get the layer","text":"<p>For this step we'll go for a layer that can be found in the binbash Leverage RefArch under this directory.</p> <p>You can download a directory from a git repository using this Firefox addon or any method you want.</p> <p>Note when you copy the layer (e.g. with gitzip), the file <code>common-variables.tf</code> , which is a soft link, was probably copied as a regular file.  If this happens, delete it:</p> <pre><code>cd ec2-fleet-ansible\\ --\nrm common-variables.tf\n</code></pre>"},{"location":"user-guide/playbooks/VPC-with-no-LandingZone/#prepare-the-layer","title":"Prepare the layer","text":"<p>Again, since we are not running the whole binbash Leverage Landing Zone we need to comment out these lines in <code>config.tf</code>:</p> <pre><code>  #backend \"s3\" {\n#  key = \"apps-devstg/ec2-fleet-ansible/terraform.tfstate\"\n#}\n</code></pre> <p>Also in this file, comment out these two resources: <pre><code>data \"terraform_remote_state\" \"security\" {\ndata \"terraform_remote_state\" \"vpc-shared\" {\n</code></pre></p> <p>And change <code>vpc</code> to be like this: <pre><code>data \"terraform_remote_state\" \"vpc\" {\nbackend = \"local\"\nconfig = {\npath = \"../base-network/terraform.tfstate\"\n}\n}\n</code></pre> Again, since we are not using the full binbash Leverage capabilities, we are not using the S3 Terraform backend, thus the backend is local.</p> <p>In <code>ec2_fleet.tf</code> update module version like this: <pre><code>  source = \"github.com/binbashar/terraform-aws-ec2-instance.git?ref=v5.5.0\"\n</code></pre></p> <p>Init the layer: <pre><code>leverage tf init --skip-validation\n</code></pre> (same as before with the skip flag)</p> <p>Now, we need some common and specific vars that are not set.</p> <p>So, create a <code>variables.tf</code> file with this content:</p> <p><pre><code>variable \"environment\" {\ntype        = string\ndescription = \"Environment Name\"\n}\nvariable \"profile\" {\ntype        = string\ndescription = \"AWS Profile (required by the backend but also used for other resources)\"\n}\nvariable \"region\" {\ntype        = string\ndescription = \"AWS Region\"\n}\n##=============================#\n##  EC2 Attributes             #\n##=============================#\nvariable \"aws_ami_os_id\" {\ntype        = string\ndescription = \"AWS AMI Operating System Identificator\"\ndefault     = \"ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*\"\n}\n\nvariable \"aws_ami_os_owner\" {\ntype        = string\ndescription = \"AWS AMI Operating System Owner, eg: 099720109477 for Canonical \"\ndefault     = \"099720109477\"\n}\n\n## security.tf file\n##=============================#\n##  SSM Attributes             #\n##=============================#\nvariable \"instance_profile\" {\ntype        = string\ndescription = \"Whether or not to create the EC2 profile, use null or 'true'\"\ndefault     = \"true\"\n}\n\nvariable \"prefix\" {\ntype        = string\ndescription = \"EC2 profile prefix\"\ndefault     = \"fleet-ansible\"\n}\n\nvariable \"name\" {\ntype        = string\ndescription = \"EC2 profile name\"\ndefault     = \"ssm-demo\"\n}\n\nvariable \"enable_ssm_access\" {\ntype        = bool\ndescription = \"Whether or not to attach SSM policy to EC2 profile IAM role, use false or true\"\ndefault     = true\n}\n</code></pre> (set the Ubuntu image as per your needs)</p> <p>In <code>ec2_fleet.tf</code> file comment these lines:</p> <p><pre><code> # data.terraform_remote_state.vpc-shared.outputs.vpc_cidr_block\n\n# key_name               = data.terraform_remote_state.security.outputs.aws_key_pair_name\n</code></pre> ...again, due to the lack of the whole binbash Leverage Landing Zone... </p> <p>If you plan to access the instance from the Internet (EC2 in a public subnet)(e.g. to use Ansible), you change the first line to <code>\"0.0.0.0/0\"</code>. (or better, a specific public IP)</p> <p>If you want to add an SSH key (e.g. to use Ansible), you can generate a new SSH key, add a resource like this: <pre><code>resource \"aws_key_pair\" \"devops\" {\nkey_name   = \"devops-key\"\npublic_key = \"ssh-ed25519 AAAAC3N9999999999999999999999999eF Binbash-AWS-instances\"\n}\n</code></pre> And replace the line in <code>ec2_fleet.tf</code> with this one: <pre><code>  key_name               = aws_key_pair.devops.key_name\n</code></pre></p> <p>In the same file, change <code>instance_type</code> as per your needs.</p> <p>Also you can add this  * * *to the <code>ec2_ansible_fleet</code> resource: <pre><code>  create_spot_instance = true\n</code></pre> to create spot instances.... and this <pre><code>  create_iam_instance_profile = true\niam_role_description        = \"IAM role for EC2 instance\"\niam_role_policies = {\nAmazonSSMManagedInstanceCore = \"arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore\"\n}\n</code></pre> to add SSM access.</p> <p>In <code>locals.tf</code> file check the variable <code>multiple_instances</code>. There the EC2 instances are defined, by default there are four. Remember to set the subnets in which the instances will be created.</p> <p>Finally, apply the layer:</p> <pre><code>leverage tf apply\n</code></pre> <p>Check your public IP and try to SSH into your new instance!</p> <p>Have fun!</p>"},{"location":"user-guide/playbooks/schedule-start-stop-ec2/","title":"Start/Stop EC2/RDS instances using schedule or manual endpoint","text":""},{"location":"user-guide/playbooks/schedule-start-stop-ec2/#what","title":"What?","text":"<p>You have EC2 instances (or RDS) that are not being used all the time... so why to keep them up and running and billing? Here we'll create a simple schedule to turn them off/on. (also with an HTTP endpoint to do it so manually)</p>"},{"location":"user-guide/playbooks/schedule-start-stop-ec2/#why","title":"Why?","text":"<p>To keep your billing under control!</p>"},{"location":"user-guide/playbooks/schedule-start-stop-ec2/#how","title":"How?","text":""},{"location":"user-guide/playbooks/schedule-start-stop-ec2/#pre-requisites","title":"Pre-requisites","text":"<p>All the instances you want to start stop have to be tagged accordingly. For this example we'll use these tags:</p> <pre><code>    ScheduleStopDaily   = true\nScheduleStartManual = true\n</code></pre>"},{"location":"user-guide/playbooks/schedule-start-stop-ec2/#the-scheduler-layer","title":"The scheduler layer","text":"<p>In your  binbash Leverage  infra repository, under your desired account and region, copy this layer.</p> <p>You can download a directory from a git repository using this Firefox addon or any method you want.</p> <p>Remember, if the <code>common-variables.tf</code> file delete the file and soft-link it to the homonymous file in the root <code>config</code> dir: e.g. <code>common-variables.tf -&gt; ../../../config/common-variables.tf</code></p>"},{"location":"user-guide/playbooks/schedule-start-stop-ec2/#set-the-tags","title":"Set the tags","text":"<p>In the <code>tools-cloud-scheduler-stop-start</code> layer edit the <code>main.tf</code> file. There are two resources: - <code>schedule_ec2_stop_daily_midnight</code> to stop the instances - <code>schedule_ec2_start_daily_morning</code> to start the instances</p> <p>You can change these names. If you do so remember to change all the references to them.</p> <p>In the <code>resource_tags</code> element set the right tags. E.g. this: <pre><code>  resources_tag = {\nkey   = \"ScheduleStopDaily\"\nvalue = \"true\"\n}\n</code></pre> in the <code>schedule_ec2_stop_daily_midnight</code> resource means this resource will stop instances with tag: <code>ScheduleStopDaily=true</code>.</p>"},{"location":"user-guide/playbooks/schedule-start-stop-ec2/#set-the-schedule","title":"Set the schedule","text":"<p>Note this line: <pre><code>  cloudwatch_schedule_expression = \"cron(0 23 * * ? *)\"\n</code></pre></p> <p>Here you can set the schedule in a cron-like fashion.</p> <p>If it is <code>none</code> it won't create a schedule (e.g. if you only need http endpoint): <pre><code>  cloudwatch_schedule_expression = \"none\"\n</code></pre></p> <p>Then if you set this: <pre><code>  http_trigger = true\n</code></pre></p> <p>A HTTP endpoint will be created to trigger the corresponding action.</p> <p>If an endpoint was created then in the outputs the URL will be shown.</p>"},{"location":"user-guide/ref-architecture-ansible/overview/","title":"Ansible Reference Architecture","text":""},{"location":"user-guide/ref-architecture-ansible/overview/#overview","title":"Overview","text":"<p>This repository contains all the Ansible Playbooks configuration  files used to create binbash Leverage\u2122 Reference Architecture for AWS.</p>"},{"location":"user-guide/ref-architecture-ansible/overview/#ansible-playbook-documentation","title":"Ansible Playbook Documentation","text":"<p>Check out the README.md under contained under each repo</p> <p>Playbooks Documentation</p> <p> User Management &amp; Security </p> <ul> <li> sec-users</li> </ul> <p> VPN Server </p> <ul> <li> vpn-pritunl</li> </ul> <p> Monitoring &amp; Alerting </p> <ul> <li> prometheus-grafana</li> </ul> <p> Centralized Logs </p> <ul> <li> eskibana</li> </ul> <p> CI/CD </p> <ul> <li> jenkins</li> <li> spinnaker</li> <li> droneci</li> <li> webhook</li> </ul> <p> Secret Mgmt </p> <ul> <li> hashicorp-vault</li> </ul>"},{"location":"user-guide/ref-architecture-ansible/workflow/","title":"Workflow","text":"<p>Leverage CLI</p> <ul> <li> <p>We rely on the <code>Leverage CLI</code> as a wrapper to run ansible commands that consistently use the same config files and secrets.</p> </li> <li> <p>You are encouraged to read more about our <code>Leverage CLI</code> how it works section to better understand it.</p> </li> </ul> <p> Ansible Infra</p> <ol> <li>Get into the folder that you need to work with (e.g. <code>ansible-playbook-vpn-pritunl</code>)</li> <li>Run <code>leverage run init</code> to get all the necessary Ansible roles based on each <code>requirements.yml</code></li> <li>Make whatever changes you need to make as stated in each Playbook Documentation (check Documentation section above)</li> <li>For a dry run execution use <code>leverage run apply\\[--check\\]</code> if you only mean to preview those changes</li> <li>Run <code>leverage run apply</code> if you want to apply those changes</li> <li>If you want to target specific playbook tasks by tag (eg: common tag) you can run one of the following options:        <ul> <li>Opt-1:  <code>leverage run apply[\"--tags\",\"common\"]</code> </li> <li>Opt-2:  <code>noglob leverage run apply[\"--tags\",\"common\"]</code> </li> <li>Opt-3:  <code>leverage shell</code> and then <code>ansible-playbook setup.yml --tags common</code> </li> </ul> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/configuration/","title":"Configuration","text":""},{"location":"user-guide/ref-architecture-aws/configuration/#configuration-files","title":"Configuration Files","text":"<p>Config files can be found under each <code>config</code> folders</p> <ul> <li> Global config file <code>/config/common.tfvars</code>  contains global context TF variables that we inject to TF commands which are used by all sub-directories such as  <code>leverage terraform plan</code> or <code>leverage terraform apply</code> and which cannot be stored in <code>backend.tfvars</code> due to TF.</li> <li> Account config files <ul> <li><code>backend.tfvars</code>  contains TF variables that are mainly used to configure TF backend but since  <code>profile</code> and <code>region</code> are defined there, we also use them to inject those values into other TF commands.</li> <li><code>account.tfvars</code>  contains TF variables that are specific to an AWS account.</li> </ul> </li> <li> Global <code>common-variables.tf</code> file <code>/config/common-variables.tfvars</code> contains global context TF variables that we symlink to all terraform layers code e.g. shared/us-east-1/tools-vpn-server/common-variables.tf.</li> <li> <code>build.env</code> file<ul> <li>By utilizing the <code>build.env</code> capability,   you can easily change some default behaviors of the CLI. Read more in its dedicated   \"Override defaults via <code>build.env</code> file\" section.</li> </ul> </li> </ul>"},{"location":"user-guide/ref-architecture-aws/configuration/#setting-credentials-for-terraform-via-aws-profiles","title":"Setting credentials for Terraform via AWS profiles","text":"<ul> <li>File <code>backend.tfvars</code> will inject the profile name that TF will use to make changes on AWS.</li> <li>Such profile is usually one that relies on another profile to assume a role to get access to each corresponding account.</li> <li>Please read the credentials section to understand the alternatives supported by Leverage to authenticate with AWS.</li> <li>Read the following page leverage doc to understand how to set up a profile to assume  a role</li> </ul>"},{"location":"user-guide/ref-architecture-aws/credentials/","title":"Credentials","text":""},{"location":"user-guide/ref-architecture-aws/credentials/#overview","title":"Overview","text":"<p>Currently the following two methods are supported:</p> <ol> <li> AWS IAM: this is essentially using on-disk, permanent programmatic credentials that are tied to a given IAM User. This method can optionally support MFA which is highly recommended since using permanent credentials is discouraged, so at least with MFA you can counter-balance that. Keep reading...</li> <li> AWS IAM Identity Center (formerly known as AWS SSO): this one is more recent and it's the method recommeded by AWS since it uses roles (managed by AWS) which in turn enforce the usage of temporary credentials. Keep reading...</li> </ol>"},{"location":"user-guide/ref-architecture-aws/credentials/#next-steps","title":"Next Steps","text":"<p>If you are planning to choose SSO (highly recommended), check out this section.</p> <p>If you are instead interested in using IAM + MFA, refer to this other section instead.</p>"},{"location":"user-guide/ref-architecture-aws/dir-structure/","title":"Project Structure","text":""},{"location":"user-guide/ref-architecture-aws/dir-structure/#filesfolders-organization","title":"Files/Folders Organization","text":"<p>The following block provides a brief explanation of the chosen files/folders layout, under every account (<code>management</code>,  <code>shared</code>, <code>security</code>, etc) folder you will see a service layer structure similar to the following:</p> MyExample project file structure <pre><code>    ...\n    \u251c\u2500\u2500 \ud83d\udcc2 apps-devstg\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 config\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tfvars\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 backend.tfvars\n    |   \u251c\u2500\u2500 \ud83d\udcc2 global\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 base-identities\n    |   \u251c\u2500\u2500 \ud83d\udcc2 us-east-1\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 backups\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-certificates\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-network\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-tf-backend\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 cdn-s3-frontend\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 databases-aurora\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 databases-mysql\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 databases-pgsql\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 k8s-eks-demoapps\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 notifications\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-audit\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-base\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-certs\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-firewall\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 storage\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 tools-cloud-nuke\n    |   \u2514\u2500\u2500 \ud83d\udcc2 us-east-2\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 k8s-eks\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-compliance\n    |    \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 security-keys\n    \u251c\u2500\u2500 \ud83d\udcc2 apps-prd\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 config\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tfvars\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 backend.tfvars\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 global\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 base-identities\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 us-east-1\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 backups\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-network\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-tf-backend\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 cdn-s3-frontend\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 k8s-eks\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 notifications\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-audit\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-base\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-certs\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-compliance\n    |    \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 security-keys\n    \u251c\u2500\u2500 \ud83d\udcc4 build.env\n    \u251c\u2500\u2500 \ud83d\udcc4 build.py\n    \u251c\u2500\u2500 \ud83d\udcc2 config\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 common.tfvars\n    \u251c\u2500\u2500 \ud83d\udcc2 management\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 config\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tfvars\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 backend.tfvars\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 global\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-identities\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 cost-mgmt\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 organizations\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 sso\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 us-east-1\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 backups\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-tf-backend\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 notifications\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-audit\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-base\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-compliance\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-keys\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 us-east-2\n    |    \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 security-monitoring\n    \u251c\u2500\u2500 \ud83d\udcc2 network\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 config\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tfvars\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 backend.tfvars\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 global\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 base-identities\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 us-east-1\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-network\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-tf-backend\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 network-firewall\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 notifications\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-audit\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-base\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-compliance\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-keys\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 transit-gateway\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 us-east-2\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-network\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 network-firewall\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-compliance\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-keys\n    |    \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 transit-gateway\n    \u251c\u2500\u2500 \ud83d\udcc2 security\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 config\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tfvars\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 backend.tfvars\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 global\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 base-identities\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 us-east-1\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 base-tf-backend\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 firewall-manager\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 notifications\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-audit\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-base\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-compliance\n    |   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-keys\n    |   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 security-monitoring\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 us-east-2\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-audit\n    |    \u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc2 security-compliance\n    |    \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 security-monitoring\n    \u2514\u2500\u2500 \ud83d\udcc2 shared\n    \u251c\u2500\u2500 \ud83d\udcc2 config\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tfvars\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 backend.tfvars\n    \u251c\u2500\u2500 \ud83d\udcc2 global\n    |   \u251c\u2500\u2500 \ud83d\udcc2 base-dns\n    |   \u2514\u2500\u2500 \ud83d\udcc2 base-identities\n    \u251c\u2500\u2500 \ud83d\udcc2 us-east-1\n    |   \u251c\u2500\u2500 \ud83d\udcc2 backups\n    |   \u251c\u2500\u2500 \ud83d\udcc2 base-network\n    |   \u251c\u2500\u2500 \ud83d\udcc2 base-tf-backend\n    |   \u251c\u2500\u2500 \ud83d\udcc2 container-registry\n    |   \u251c\u2500\u2500 \ud83d\udcc2 ec2-fleet\n    |   \u251c\u2500\u2500 \ud83d\udcc2 k8s-eks\n    |   \u251c\u2500\u2500 \ud83d\udcc2 k8s-eks-demoapps\n    |   \u251c\u2500\u2500 \ud83d\udcc2 k8s-eks-prd\n    |   \u251c\u2500\u2500 \ud83d\udcc2 notifications\n    |   \u251c\u2500\u2500 \ud83d\udcc2 security-audit\n    |   \u251c\u2500\u2500 \ud83d\udcc2 security-base\n    |   \u251c\u2500\u2500 \ud83d\udcc2 security-compliance\n    |   \u251c\u2500\u2500 \ud83d\udcc2 storage\n    |   \u251c\u2500\u2500 \ud83d\udcc2 tools-cloud-scheduler-stop-start\n    |   \u251c\u2500\u2500 \ud83d\udcc2 tools-eskibana\n    |   \u251c\u2500\u2500 \ud83d\udcc2 tools-github-selfhosted-runners\n    |   \u251c\u2500\u2500 \ud83d\udcc2 tools-jenkins\n    |   \u251c\u2500\u2500 \ud83d\udcc2 tools-managedeskibana\n    |   \u251c\u2500\u2500 \ud83d\udcc2 tools-prometheus\n    |   \u251c\u2500\u2500 \ud83d\udcc2 tools-vault\n    |   \u251c\u2500\u2500 \ud83d\udcc2 tools-vpn-server\n    |   \u2514\u2500\u2500 \ud83d\udcc2 tools-webhooks\n    \u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc2 us-east-2\n    \u251c\u2500\u2500 \ud83d\udcc2 base-network\n    \u251c\u2500\u2500 \ud83d\udcc2 container-registry\n    \u251c\u2500\u2500 \ud83d\udcc2 security-compliance\n    \u251c\u2500\u2500 \ud83d\udcc2 security-keys\n    \u251c\u2500\u2500 \ud83d\udcc2 tools-eskibana\n    \u2514\u2500\u2500 \ud83d\udcc2 tools-prometheus\n</code></pre> <p>Configuration files are organized by environments (e.g. dev, stg, prd), and service type, which we call layers (identities, organizations, storage, etc) to keep any changes made to them separate. Within each of those layers folders you should find the Terraform files that are used to define all the  resources that belong to such account environment and specific layer.</p> <p>Project file structure </p> <p>An extended project file structure could be found  here While some other basic concepts and naming conventions in the context of Leverage like \"project\" and \"layer\"  here</p> <p></p> Figure: AWS Organization multi-account architecture diagram. (Source: binbash Leverage, \"Leverage Reference Architecture components\", binbash Leverage Doc, accessed August 4th 2021).  <p>NOTE: As a convention folders with the <code>--</code> suffix reflect that the resources are not currently created in AWS, basically they've been destroyed or not yet exist. </p> <p>Such layer separation is meant to avoid situations in which a single folder contains a lot of resources.  That is important to avoid because at some point, running <code>leverage terraform plan / apply</code> starts taking  too long and that becomes a problem.</p> <p>This organization also provides a layout that is easier to navigate and discover.  You simply start with the accounts at the top level and then you get to explore the resource categories within  each account.</p>"},{"location":"user-guide/ref-architecture-aws/overview/","title":"AWS Reference Architecture","text":""},{"location":"user-guide/ref-architecture-aws/overview/#overview","title":"Overview","text":"<p>The AWS Reference Architecture was created on a set of opinionated definitions and conventions on:</p> <ul> <li>how to organize files/folders,</li> <li>where to store configuration files,</li> <li>how to handle credentials,</li> <li>how to set up and manage state,</li> <li>which commands and workflows to run in order to perform different tasks,</li> <li>and more.</li> </ul> <p>Key Concept</p> <p>Although the Reference Architecture for AWS was initially designed to be compatible with web, mobile and microservices application stacks, it can also accommodate other types of workloads such as machine learning, blockchain, media, and more.</p> <p>It was designed with modularity in mind. A multi-accounts approach is leveraged in order to improve security isolation and resources separation. Furthermore each account infrastructure is divided in smaller units that we call layers. Each layer contains all the required resources and definitions for a specific service or feature to function.</p> <p>Key Concept</p> <p>The design is strongly based on the AWS Well Architected Framework.</p> <p>Each individual configuration of the Reference Architecture is referred to as a project. A Leverage project is comprised of all the relevant accounts and layers.</p>"},{"location":"user-guide/ref-architecture-aws/overview/#core-strengths","title":"Core Strengths","text":"<ul> <li> Faster updates (new features and bug fixes).</li> <li> Better code quality and modules maturity (proven and tested).</li> <li> Supported by binbash, and public modules even by 1000's of top talented Open Source community      contributors.</li> <li> Increase development cost savings.</li> <li> Clients keep full rights to all commercial, modification, distribution, and private use of the code      (No Lock-In) through forks inside their own projects' repositories (open-source and commercially reusable via license MIT and Apache 2.0.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/overview/#a-more-visual-example","title":"A More Visual Example","text":"<p>The following diagram shows the type of AWS multi-account setup you can achieve by using this Reference Architecture: </p> Figure: AWS Organization multi-account reference architecture diagram. (Source: binbash Leverage, \"Leverage Reference Architecture components\", binbash Leverage Doc, accessed August 4th 2021).  <p>Read more</p> <ul> <li> Don't get locked up into avoiding lock-in</li> <li> AWS Managed Services</li> </ul>"},{"location":"user-guide/ref-architecture-aws/references/","title":"References","text":"<p>The following are official AWS documentations, blog posts and whitepapers we have considered while building our Reference Solutions Architecture:</p> <ul> <li> CloudTrail for AWS Organizations</li> <li> Reserved Instances - Multi Account</li> <li> AWS Multiple Account Security Strategy</li> <li> AWS Multiple Account Billing Strategy</li> <li> AWS Secure Account Setup</li> <li> Authentication and Access Control for AWS Organizations</li> <li> AWS Regions</li> <li> VPC Peering</li> <li> Route53 DNS VPC Associations</li> <li> AWS Well Architected Framework</li> <li> AWS Tagging strategies</li> <li> Inviting an AWS Account to Join Your Organization</li> </ul>"},{"location":"user-guide/ref-architecture-aws/tf-state/","title":"Terraform - S3 &amp; DynamoDB for Remote State Storage &amp; Locking","text":""},{"location":"user-guide/ref-architecture-aws/tf-state/#overview","title":"Overview","text":"<p>Use this terraform configuration files to create the S3 bucket &amp; DynamoDB table needed to use Terraform Remote State Storage &amp; Locking.</p> <p>What is the Terraform Remote State?</p> <p>Read the official definition by Hashicorp.</p> <p></p> Figure: Terraform remote state store &amp; locking necessary AWS S3 bucket and DynamoDB table components. (Source: binbash Leverage,   \"Terraform Module: Terraform Backend\", Terraform modules registry, accessed December 3rd 2020)."},{"location":"user-guide/ref-architecture-aws/tf-state/#prerequisites","title":"Prerequisites","text":"<p>Terraform repo structure + state backend initialization</p> <ol> <li>Ensure you have <code>Leverage CLI</code> installed in your system</li> <li>Refer to Configuration Pre-requisites to understand how to set up the   configuration files required for this layer. Where you must build your   Terraform Reference Architecture account structure</li> <li>Leveraged by the Infrastructure as Code (IaC) Library through the  terraform-aws-tfstate-backend module<ul> <li>/management/base-tf-backend</li> <li>/security/base-tf-backend</li> <li>/shared/base-tf-backend</li> <li>/network/base-tf-backend</li> <li>/apps-devstg/base-tf-backend</li> <li>/apps-prd/base-tf-backend</li> </ul> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/tf-state/#set-up","title":"Set up","text":"<p>Steps to initialize your tf-backend</p> <ol> <li>At the corresponding account dir,    eg: /shared/base-tf-backend then,</li> <li>Run <code>leverage terraform init --skip-validation</code></li> <li>Run <code>leverage terraform plan</code>, review the output to understand the expected changes</li> <li>Run <code>leverage terraform apply</code>, review the output once more and type <code>yes</code> if you are okay with that</li> <li> <p>This should create a <code>terraform.tfstate</code> file in this directory but we don't want to push that to the repository so    let's push the state to the backend we just created</p> <ul> <li>Open <code>config.tf</code> and uncomment the following lines: <pre><code>  # backend \"s3\" {\n  #   key = \"shared/tf-backend/terraform.tfstate\"\n  # }\n</code></pre></li> <li>Run <code>leverage terraform init</code> and type <code>yes</code> when Terraform asks if you want to import the state to the S3 backend</li> <li>Done. You can remove <code>terraform.tfstate</code> now (and also <code>terraform.tfstate.backup</code> if available)</li> </ul> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/tf-state/#expected-workflow-after-set-up","title":"Expected workflow after set up","text":"<p> This video is outdated! </p>"},{"location":"user-guide/ref-architecture-aws/tf-state/#terraform-remote-state","title":"Terraform Remote State","text":"<p>In the <code>base-tf-backend</code> folder you should find the definition of the infrastructure that needs to be deployed before  you can get to work with anything else.</p> <p>IMPORTANT: THIS IS ONLY NEEDED IF THE BACKEND WAS NOT CREATED YET. IF THE BACKEND ALREADY EXISTS YOU JUST USE IT.</p>"},{"location":"user-guide/ref-architecture-aws/workflow/","title":"Workflow","text":""},{"location":"user-guide/ref-architecture-aws/workflow/#overview","title":"Overview","text":"<p>The sequence of commands that you run to operate on each layer is called the Terraform workflow. In other words, it's what you would typically run in order to create, update, or delete the resources defined in a given layer.</p>"},{"location":"user-guide/ref-architecture-aws/workflow/#the-basic-workflow","title":"The basic workflow","text":"<p>Assuming that you have everything configured, the frequent commands you'll need to run are these: <pre><code># 1. Initialize\nleverage terraform init\n\n# 2. Preview any changes\nleverage terraform plan\n\n# 3. Apply any changes\nleverage terraform apply\n</code></pre></p>"},{"location":"user-guide/ref-architecture-aws/workflow/#the-extended-workflow","title":"The extended workflow","text":"<p>Now, the extended workflow is annotated with more explanations and it is intended for users who haven't yet worked with Leverage on a daily basis:</p> <p>Terraform Workflow</p> <ol> <li>Make sure you understood the basic concepts:<ul> <li> Overview</li> <li> Configuration</li> <li> Directory Structure</li> <li> Remote State</li> </ul> </li> <li>Make sure you installed the Leverage CLI.</li> <li>Go to the layer (directory) you need to work with, e.g. <code>shared/global/base-identities/</code>.</li> <li>Run <code>leverage terraform init</code> -- only the first time you work on this layer, or if you upgraded modules or providers versions, or if you made changes to the Terraform remote backend configuration.</li> <li>Make any changes you need to make. For instance: modify a resource definition, add an output, add a new resource, etc.</li> <li>Run <code>leverage terraform plan</code> to preview any changes.</li> <li>Run <code>leverage terraform apply</code> to give it a final review and to apply any changes.</li> </ol> <p>Tip</p> <p>You can use the <code>--layers</code> argument to run Terraform commands on more than one layer. For more information see here</p> <p>Note</p> <p>If desired, at step #5 you could submit a PR, allowing you and the rest of the team to  understand and review what changes would be made to your AWS Cloud Architecture components before executing  <code>leverage terraform apply</code> (<code>terraform apply</code>). This brings the huge benefit of treating changes with a GitOps oriented  approach, basically as we should treat any other code &amp; infrastructure change, and integrate it with the  rest of our tools and practices like CI/CD, in</p>"},{"location":"user-guide/ref-architecture-aws/workflow/#running-in-automation","title":"Running in Automation","text":"Figure: Running terraform with AWS in automation (just as reference). <p>Read More</p> <ul> <li> Running Terraform in automation</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/","title":"Index","text":""},{"location":"user-guide/ref-architecture-aws/features/#features","title":"Features","text":""},{"location":"user-guide/ref-architecture-aws/features/#overview","title":"Overview","text":"<p>This reference architecture supports a growing number of AWS services. This section lists all of them and goes through each in depth.</p> <p>Governance | AWS Organizations</p> <ul> <li> Overview</li> <li> Configuration</li> <li> Invite pre-exiting accounts to AWS Organizations</li> </ul> <p>Identity Management</p> <ul> <li> GPG Keys</li> <li> Identities</li> <li> AWS Credentials</li> <li> Hashicorp Vault Credentials</li> </ul> <p>Single Sign-On (SSO)</p> <ul> <li> AWS SSO + Jumpcloud IdP</li> </ul> <p>Cost Monitoring &amp; Optimization</p> <ul> <li> Costs</li> </ul> <p>Security</p> <ul> <li> Security Services</li> <li> VPN | Pritunl</li> </ul> <p>Networking | VPC, TGW, NFW, DNS and NACLs</p> <ul> <li> VPC Addressing</li> <li> VPC Peering</li> <li> DNS</li> </ul> <p>Secrets Management</p> <ul> <li> Secrets</li> </ul> <p>Compute</p> <ul> <li> Compute</li> <li> K8s EKS</li> <li> K8s Kops</li> <li> Serverless</li> </ul> <p>Databases</p> <ul> <li> Databases</li> <li> RDS MySql</li> <li> RDS Postgres</li> </ul> <p>Storage</p> <ul> <li> Storage</li> </ul> <p>Content Delivery Network (CDN)</p> <ul> <li> AWS CloudFront</li> </ul> <p>CI/CD (Continuous Integration / Continuous Delivery)</p> <ul> <li> ArgoCD</li> <li> Jenkins &amp; ArgoCD</li> <li> Jenkins &amp; Spinnaker</li> </ul> <p>Monitoring | Metrics, Logs, APM and Tracing</p> <ul> <li> Monitoring</li> <li> Metrics</li> <li> Logs</li> <li> Tracing</li> <li> APM</li> </ul> <p>Reliability</p> <ul> <li> Bakcups</li> <li> Health-Checks</li> <li> Disaster Recovery</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/cdn/cdn/","title":"CDN","text":"<p> AWS Cloud Front</p> <p>Amazon CloudFront is a fast content delivery network (CDN) service that securely delivers data, videos,  applications, and APIs to customers globally with low latency, high transfer speeds, all within a developer-friendly environment. CloudFront is integrated with AWS \u2013 both physical locations that are directly connected to the AWS global infrastructure, as well as other AWS services. CloudFront works seamlessly with services including AWS Shield for DDoS mitigation,  Amazon S3, Elastic Load Balancing, API Gateway or Amazon EC2 as origins for your applications, and Lambda@Edge to run custom code closer to customers\u2019 users and to customize the user experience. Lastly, if you use AWS origins such as Amazon S3, Amazon EC2 or Elastic Load Balancing, you don\u2019t pay  for any data transferred between these services and CloudFront.</p>"},{"location":"user-guide/ref-architecture-aws/features/cdn/cdn/#load-balancer-alb-nlb-s3-cloudfront-origins","title":"Load Balancer (ALB | NLB) &amp; S3 Cloudfront Origins","text":"Figure: AWS CloudFront with ELB and S3 as origin diagram. (Source: Lee Atkinson,   \"How to Help Achieve Mobile App Transport Security (ATS) Compliance by Using Amazon CloudFront and AWS Certificate Manager\", AWS Security Blog, accessed November 17th 2020)."},{"location":"user-guide/ref-architecture-aws/features/cdn/cdn/#api-gateway-cloudfront-origins","title":"API Gateway Cloudfront Origins","text":"Figure: AWS CloudFront with API Gateway as origin diagram. (Source: AWS,   \"AWS Solutions Library, AWS Solutions Implementations Serverless Image Handler\", AWS Solutions Library Solutions Implementations, accessed November 17th 2020)."},{"location":"user-guide/ref-architecture-aws/features/ci-cd/argocd/","title":"ArgoCD","text":""},{"location":"user-guide/ref-architecture-aws/features/ci-cd/argocd/#argocd","title":"ArgoCD","text":""},{"location":"user-guide/ref-architecture-aws/features/ci-cd/argocd/#aws-apps-services-k8s-eks-accounts-diagram","title":"AWS Apps &amp; Services K8s EKS accounts diagram","text":"<p>The below diagram is based on our  binbash Leverage Reference Architecture CI-CD official documentation</p> <p></p> Figure: K8S reference architecture CI/CD with ArgoCD diagram. (Source: binbash Leverage Confluence Doc,   \"Implementation Diagrams\", binbash Leverage Doc, accessed August 4th 2021)."},{"location":"user-guide/ref-architecture-aws/features/ci-cd/jenkins-argocd/","title":"CI/CD","text":""},{"location":"user-guide/ref-architecture-aws/features/ci-cd/jenkins-argocd/#jenkins-argocd","title":"Jenkins + ArgoCD","text":"Figure: ACI/CD with Jenkins + ArgoCD architecture diagram. (Source: ArgoCD,   \"Overview - What Is Argo CD\", ArgoCD documentation, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-aws/features/ci-cd/jenkins-spinnaker/","title":"CI/CD","text":""},{"location":"user-guide/ref-architecture-aws/features/ci-cd/jenkins-spinnaker/#jenkins-spinnaker","title":"Jenkins + Spinnaker","text":"Figure: CI/CD with Jenkins + Spinnaker diagram. (Source: Irshad Buchh,   \"Continuous Delivery using Spinnaker on Amazon EKS\", AWS Open Source Blog, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-eks/","title":"AWS Elastic Kubernetes Service (EKS)","text":"<p>Important</p> <p>Please check the Reference Architecture for EKS to learn more details about this.</p>"},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-kops/","title":"AWS Kubernetes Kops Cluster","text":""},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-kops/#overview","title":"Overview","text":"<p>Kops is an official Kubernetes project for managing production-grade  Kubernetes clusters. Kops is currently the best tool to deploy Kubernetes clusters to Amazon Web Services.  The project describes itself as kubectl for clusters.</p> <p>Core Features</p> <ul> <li> Open-source &amp; supports AWS and GCE</li> <li> Deploy clusters to existing virtual private clouds (VPC) or create a new VPC from scratch</li> <li> Supports public &amp; private topologies</li> <li> Provisions single or multiple master clusters</li> <li> Configurable bastion machines for SSH access to individual cluster nodes</li> <li> Built on a state-sync model for dry-runs and automatic idempotency</li> <li> Direct infrastructure manipulation, or works with CloudFormation and Terraform</li> <li> Rolling cluster updates</li> <li> Supports heterogeneous clusters by creating multiple instance groups</li> </ul> <p></p> Figure: AWS K8s Kops architecture diagram (just as reference). (Source: Carlos Rodriguez,   \"How to deploy a Kubernetes cluster on AWS with Terraform &amp; kops\", Nclouds.com Blog post, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-kops/#kops-pre-requisites","title":"Kops Pre-requisites","text":"<p>Important consideration</p> <p>K8s clusters provisioned by Kops have a number of resources that need to be available before the cluster is created. These are Kops pre-requisites and they are defined in the <code>1-prerequisites</code> directory which includes all Terraform files used to create/modify these resources.</p> <p> The current code has been fully tested with the AWS VPC Network Module</p> <p>OS pre-req packages</p> <p>Ref Link: https://github.com/kubernetes/kops/blob/master/docs/install.md)</p> <ul> <li>kops &gt;= 1.14.0 <pre><code>\u2570\u2500\u25cb kops version                                                                                      \nVersion 1.15.0 (git-9992b4055)\n</code></pre></li> <li>kubectl &gt;= 1.14.0 <pre><code>\u2570\u2500\u25cb kubectl version --client\n+ kubectl version --client\nClient Version: version.Info{Major:\"1\", Minor:\"14\", GitVersion:\"v1.14.0\", GitCommit:\"641856db18352033a0d96dbc99153fa3b27298e5\", GitTreeState:\"clean\", BuildDate:\"2019-03-25T15:53:57Z\", GoVersion:\"go1.12.1\", Compiler:\"gc\", Platform:\"linux/amd64\"}\n</code></pre></li> <li>terraform &gt;= 0.12.0 <pre><code>\u2570\u2500\u25cb terraform version\nTerraform v0.12.24\n</code></pre></li> <li>NOTE1: Regarding Terraform versions please also consider https://github.com/binbashar/bb-devops-tf-aws-kops#todo</li> <li> <p>NOTE2: These dependencies will me mostly covered via <code>Makefile</code> w/ terraform dockerized cmds (https://hub.docker.com/repository/docker/binbash/terraform-awscli)</p> </li> <li> <p>jq &gt;= 1.5.0 <pre><code>\u2570\u2500\u25cb jq --version\njq-1.5-1-a5b5cbe\n</code></pre></p> </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-kops/#resulting-solutions-architecture","title":"Resulting Solutions Architecture","text":"Figure: AWS K8s Kops architecture diagram (just as reference)."},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-kops/#why-this-workflow","title":"Why this workflow","text":"<p>The workflow follows the same approach that is used to manage other terraform resources in your AWS accounts. E.g. network, identities, and so on.</p> <p>So we'll use existing AWS resources to create a <code>cluster-template.yaml</code> containing all the resource IDs that Kops needs to create a Kubernetes cluster.</p> <p>Why not directly use Kops CLI to create the K8s cluster as well as the VPC and its other dependencies?</p> <ol> <li> <p>While this is a valid approach, we want to manage all these building blocks independently and be able to fully customize any AWS component without having to alter our Kubernetes cluster definitions and vice-versa.</p> </li> <li> <p>This is a fully declarative coding style approach to manage your infrastructure so being able to declare the state of our cluster in YAML files fits 100% as code &amp; GitOps based approach.</p> </li> </ol> <p></p> Figure: [Workflow diagram](https://medium.com/bench-engineering/deploying-kubernetes-clusters-with-kops-and-terraform-832b89250e8e)."},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-kops/#kops-cluster-management","title":"Kops Cluster Management","text":"<p>The <code>2-kops</code> directory includes helper scripts and Terraform files in order to template our Kubernetes cluster definition. The idea is to use our Terraform outputs from <code>1-prerequisites</code> to construct a cluster definition.</p>"},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-kops/#overview_1","title":"Overview","text":"<p>Cluster Management via Kops is typically carried out through the kops CLI. In this case, we use a <code>2-kops</code> directory that contains a Makefile, Terraform files and other helper scripts that reinforce the workflow we use to create/update/delete the cluster.</p>"},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-kops/#workflow","title":"Workflow","text":"<p>This workflow is a little different to the typical Terraform workflows we use. The full workflow goes as follows:</p> <p>Cluster: Creation &amp; Update</p> <ol> <li>Modify files under <code>1-prerequisites</code></li> <li>Main files to update probably are <code>locals.tf</code> and <code>outputs.tf</code></li> <li>Mostly before the cluster is created but could be needed afterward</li> <li>Modify <code>cluster-template.yml</code> under <code>2-kops</code> folder</li> <li>E.g. to add or remove instance groups, upgrade k8s version, etc</li> <li>At <code>2-kops/</code> context run <code>make cluster-update</code> will follow the steps below</li> <li>Get Terraform outputs from <code>1-prerequisites</code></li> <li>Generate a Kops cluster manifest -- it uses <code>cluster-template.yml</code> as a template and the outputs from the point above as replacement values</li> <li>Update Kops state -- it uses the generated Kops cluster manifest in previous point (<code>cluster.yml</code>)</li> <li>Generate Kops Terraform file (<code>kubernetes.tf</code>) -- this file represents the changes that Kops needs to apply on the cloud provider.</li> <li>Run <code>make plan</code></li> <li>To preview any infrastructure changes that Terraform will make.</li> <li>If desired we could submit a PR, allowing you and the rest of the team to understand and review what changes would    be made to the Kubernetes cluster before executing <code>make apply</code> (<code>terraform apply</code>). This brings the huge benefit    of treating changes to our Kubernetes clusters with a GitOps oriented approach, basically like we treat any other    code &amp; infrastructure change, and integrate it with the rest of our tools and practices like CI/CD, integration    testing, replicate environments and so on.</li> <li>Run <code>make apply</code></li> <li>To apply those infrastructure changes on AWS.</li> <li>Run <code>make cluster-rolling-update</code></li> <li>To determine if Kops needs to trigger some changes to happen right now (dry run)</li> <li>These are usually changes to the EC2 instances that won't get reflected as they depend on the autoscaling</li> <li>Run <code>make cluster-rolling-update-yes</code></li> <li>To actually make any changes to the cluster masters/nodes happen</li> </ol> <p>Cluster: Deletion</p> <p>To clean-up any resources created for your K8s cluster, you should run:</p> <ol> <li>At <code>2-kops</code> folder context run <code>make destroy</code></li> <li>This will execute a <code>terraform destroy</code> of all the <code>kubernets.tf</code> declared AWS resources.</li> <li>At <code>2-kops</code> folder context run <code>cluster-destroy</code></li> <li>Will run Kops <code>destroy cluster</code> -- only dry run, no changes will be applied</li> <li>Exec <code>cluster-destroy-yes</code><ul> <li>Kops will effectively destroy all the remaining cluster resources.</li> </ul> </li> <li>Finally if at <code>1-prerequisites</code> exec <code>make destroy</code><ul> <li>This will remove Kops state S3 bucket + any other extra resources you've provisioned for your cluster.</li> </ul> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-kops/#typical-workflow","title":"Typical Workflow","text":"<p>The workflow may look complicated at first but generally it boils down to these simplified steps: 1. Modify <code>cluster-template.yml</code> 2. Run <code>make cluster-update</code> 3. Run <code>make apply</code> 4. Run <code>make cluster-rolling-update-yes</code></p> <p>What about persistent and stateful K8s resources?</p> <p>This approach will work better the more stateless your Kubernetes workloads are. Treating Kubernetes clusters as ephemeral and replaceable infrastructure requires to consider not to use persistent volumes or the drawback of difficulties when running workloads such as databases on K8s. We feel pretty confident that we can recreate our workloads by applying each of our service definitions, charts and manifests to a given Kubernetes cluster as long as we keep the persistent storage separately on AWS RDS, DynamoDB, EFS and so on. In terms of the etcd state persistency, Kops already provisions the etcd volumes (AWS EBS) independently to the master instances they get attached to. This helps to persist the etcd state after rolling update your master nodes without any user intervention. Moreover simplifying volume backups via EBS Snapshots (consider https://github.com/binbashar/terraform-aws-backup-by-tags). We also use a very valuable backup tool named Velero (formerly Heptio Ark - https://github.com/vmware-tanzu/velero) to o back up and restore our Kubernetes cluster resources and persistent volumes.</p> <p>TODO</p> <ol> <li>IMPORTANT: Kops terraform output (<code>kops update cluster --target terraform</code>) is still generated for Terraform <code>0.11.x</code>       (https://github.com/kubernetes/kops/issues/7052) we'll take care of the migration when <code>tf-0.12</code> gets fully supported.</li> <li>Create a binbash Leverage public Confluence Wiki entry detailing some more info about etcd, calico and k8s versions compatibilities</li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-service-mesh/","title":"Service Mesh","text":""},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-service-mesh/#overview","title":"Overview","text":"<p>Ultra light, ultra simple, ultra powerful. Linkerd adds security, observability, and  reliability to Kubernetes, without the complexity. CNCF-hosted and 100% open source.</p>"},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-service-mesh/#how-it-works","title":"How it works","text":"<p>How Linkerd works</p> <p>Linkerd works by installing a set of ultralight, transparent proxies next to each service instance. These proxies automatically handle all traffic to and from the service. Because they\u2019re transparent, these proxies act as highly instrumented out-of-process network stacks, sending telemetry to, and receiving control signals from, the control plane. This design allows Linkerd to measure and manipulate traffic to and from your service without introducing excessive latency.</p>"},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-service-mesh/#architecture","title":"Architecture","text":"Figure: Figure: Linkerd v2.10 architecture diagram. (Source: Linkerd official documentation,   \"High level Linkerd control plane and a data plane.\", Linkerd Doc, accessed June 14th 2021)."},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-service-mesh/#dashboard","title":"Dashboard","text":"Figure: Figure: Linkerd v2.10 dashboard. (Source: Linkerd official documentation,   \"Linkerd dashboard\", Linkerd Doc, accessed June 14th 2021)."},{"location":"user-guide/ref-architecture-aws/features/compute/k8s-service-mesh/#read-more","title":"Read more","text":"<p>Related resources</p> <ul> <li> Linkerd vs Istio benchmarks</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/compute/overview/","title":"Compute","text":""},{"location":"user-guide/ref-architecture-aws/features/compute/overview/#containers-and-serverless","title":"Containers and Serverless","text":"<p>Overview</p> <p>In order to serve Client application workloads we propose to implement Kubernetes, and proceed to containerize all application stacks whenever it\u2019s the best solution (we\u2019ll also consider AWS Lambda for a Serverless approach when it fits better). Kubernetes is an open source container orchestration platform that eases the process of running containers across many different machines, scaling up or down by adding or removing containers when demand changes and provides high availability features. Also, it serves as an abstraction layer that will give Client the possibility, with minimal effort, to move the apps to other Kubernetes clusters running elsewhere, or a managed Kubernetes service such as AWS EKS, GCP GKE or others.</p> <p>Clusters will be provisioned with Kops and/or AWS EKS, which are solutions meant to orchestrate this  compute engine in AWS. Whenever possible the initial version deployed will be the latest stable release.</p> <p></p> Figure: Kubernetes high level components architecture. (Source: Andrew Martin,   \"11 Ways (Not) to Get Hacked\", Kubernetes.io Blog post, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-aws/features/compute/overview/#kubernetes-addons","title":"Kubernetes addons","text":"<p>Some possible K8s addons could be</p> <p>Security</p> <ul> <li> IAM Authenticator</li> </ul> <p>Networking</p> <ul> <li> Kubernetes Nginx Ingress Controller</li> <li> Linked2 (Service Mesh)</li> </ul> <p>Monitoring &amp; Logs </p> <ul> <li> fluentd daemonset for elasticsearch logs</li> <li> kube-state-metrics</li> <li> prometheus node-exporter</li> </ul> <p>Distributed Tracing</p> <ul> <li> jaeger</li> <li> opencensus</li> </ul> <p>UI Dashboard </p> <ul> <li> kube-ops-view</li> <li> kubernetes-dashboard</li> <li> weave-scope</li> </ul> <p>Availability &amp; Reliability</p> <ul> <li> autoscaler</li> <li> Velero (Backups)</li> </ul> <p>Utilities </p> <ul> <li> onetimesecret </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/compute/serverless/","title":"Serverless Compute","text":"<p>As stated by AWS Serverless definitions</p> <p>What is serverless?</p> <p>Serverless is the native architecture of the cloud that enables you to shift more of your operational responsibilities to AWS, increasing your agility and innovation. Serverless allows you to build and run applications and services without thinking about servers. It eliminates infrastructure management tasks such as server or cluster provisioning, patching, operating system maintenance, and capacity provisioning. You can build them for nearly any type of application or backend service, and everything required to run and scale your application with high availability is handled for you.</p> <p>Why use serverless?</p> <p>Serverless enables you to build modern applications with increased agility and lower total cost of ownership.  Building serverless applications means that your developers can focus on their core product instead of worrying about managing and operating servers or runtimes, either in the cloud or on-premises. This reduced overhead lets developers reclaim time and energy that can be spent on developing great products which scale and that are reliable.</p> <p></p> Figure: AWS serverless architecture diagram (just as reference). (Source: Nathan Peck,   \"Designing a modern serverless application with AWS Lambda and AWS Fargate\", Containers-on-AWS Medium Blog post, accessed November 18th 2020).  <p>Serverless Compute  Services</p> <ul> <li> AWS Lambda lets you run code without provisioning or managing servers.  You pay only for the compute time you consume - there is no charge when your code is not running. </li> <li> Lambda@Edge allows you to run Lambda functions at AWS Edge locations in response to Amazon CloudFront events.</li> <li> AWS Fargate is a purpose-built serverless compute engine for containers.  Fargate scales and manages the infrastructure required to run your containers.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/compute/tools/","title":"Infrastructure Instances Tools","text":""},{"location":"user-guide/ref-architecture-aws/features/compute/tools/#overview","title":"Overview","text":"<p>Apart from the EC2 instances that are part of Kubernetes, there are going to be other instances running tools for  monitoring, logging centralization, builds/tests, deployment, among others. that are to be defined at this point.  Some of them can be replaced by managed services, like: CircleCI, Snyk, etc, and this can have cons and pros that will need to be considered at the time of implementation. Any OS that is provisioned will be completely reproducible as code, in the event of migration to another vendor.</p> <p>Other settings for all EC2 instances</p> <ul> <li> Ubuntu 18.04 based (Latest AMI)</li> <li> EBS volumes encrypted: Yes</li> <li> EBS volume type: gp2 (SSD)</li> <li> Termination protection: Yes</li> </ul> <p>Infrastructure EC2 instances</p> <ul> <li> VPN Server<ul> <li>Pritunl (https://vpn.domain.com) </li> </ul> </li> <li> Monitoring &amp; Alerting<ul> <li>Prometheus (https://prometheus.domain.com)  </li> <li>Grafana (https://grafana.domain.com) </li> </ul> </li> <li> Centralized Logs<ul> <li>Elasticsearch + Kibana (https://kibana.domain.com)  </li> </ul> </li> <li> CI/CD<ul> <li>Jenkins (https://jenkins.domain.com) </li> <li>Spinnaker (https://spinnaker.domain.com)</li> <li>Droneci (https://droneci.domain.com)</li> <li>Webhook (https://webhook.domain.com)  </li> </ul> </li> <li> Secret Mgmt<ul> <li>Hashicorp Vault (https://vault.domain.com) </li> </ul> </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/costs/costs/","title":"Cost Estimation &amp; Optimization","text":""},{"location":"user-guide/ref-architecture-aws/features/costs/costs/#opportunity-to-optimize-resources","title":"Opportunity to optimize resources","text":"<p> Compute</p> <ul> <li>Usage of reserved EC2 instances for stable workloads (AWS Cost Explorer Reserved Optimization | Compute  Optimizer - get a -$ of up to 42% vs On-Demand)</li> <li>Usage of Spot EC2 instances for fault-tolerant workloads (-$ by up to 90%).</li> <li>Use ASG to allow your EC2 fleet to \u00b1 based on demand.</li> <li>Id EC2 w/ low-utiliz and -$ by stop / rightsize them.</li> <li>Compute Savings Plans to reduce EC2, Fargate and Lambda $ (Compute Savings Plans OK regardless of EC2 family,  size, AZ, reg, OS or tenancy, OK for Fargate / Lambda too).</li> </ul> <p> Databases</p> <ul> <li>Usage of reserved RDS instances for stable workload databases.</li> </ul> <p> Monitoring &amp; Automation</p> <ul> <li>AWS billing alarms + AWS Budget (forecasted account cost / RI Coverage) Notifications to Slack</li> <li>Activate AWS Trusted Advisor cost related results<ul> <li>Id EBS w/ low-utiliz and -$ by snapshotting and then rm them</li> <li>Check underutilized EBS to be possibly shrunk or removed.</li> <li>Networking -&gt; deleting idle LB -&gt; Use LB check w/ RequestCount of &gt; 100 past 7d.</li> </ul> </li> <li>Setup Lambda nuke to automatically clean up AWS account resources.</li> <li>Setup lambda scheduler for stop and start resources on AWS (EC2, ASG &amp; RDS)</li> </ul> <p> Storage &amp; Network Traffic</p> <ul> <li>Check S3 usage and -$ by leveraging lower $ storage tiers.</li> <li>Use S3 Analytics, or automate mv for these objects into lower $ storage tier w/ Life Cycle Policies or w/ S3 Intelligent-Tiering.</li> <li>If DataTransferOut from EC2 to the public internet is significant $, consider implementing CloudFront.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/costs/costs/#consideration","title":"Consideration","text":"<p>Reserved Instances</p> <ul> <li>  Stable workloads will always run on reserved instances, the following calculation only considers 1yr. No Upfront mode, in which Client will not have to pay in advance but commits to this monthly usage and will be billed so, even if the instance type is not used. More aggressive Reservation strategies can be implemented to further reduce costs, these will have to be analyzed by business in conjunction with operations.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/costs/costs/#read-more","title":"Read more","text":"<p>Reference links</p> <p>Consider the following extra links as reference:</p> <ul> <li> AWS Ramp-Up Guide: Cost Management</li> <li> How is the pricing benefit of a RI applied across an organization's consolidated bill?</li> <li> A Guide to Cloud Cost Optimization with HashiCorp Terraform</li> <li> FinOps: How Cloud Finance Management Can Save Your Cloud Programme From Extinction</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/database/database/","title":"Databases","text":""},{"location":"user-guide/ref-architecture-aws/features/database/database/#overview","title":"Overview","text":"<p>Will implement AWS RDS databases matching the requirements of the current application stacks.  If the region selected is the same you're actually using for your legacy AWS RDS instances we will be able to create a peering connection to existing databases in order to migrate the application stacks first, then databases. </p> <p>AWS RDS Specs</p> <ul> <li> RDS Instance Size</li> <li> Multi AZ</li> <li> Encryption: Yes</li> <li> Auto Minor version update</li> <li> Automated snapshots</li> <li> Snapshot retention</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/database/mysql/","title":"RDS | MySQL","text":"<p>TODO Add this</p>"},{"location":"user-guide/ref-architecture-aws/features/database/postgres/","title":"RDS | PostgresSQL","text":"<p>TODO Add this</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/credentials-vault/","title":"Hashicorp Vault credentials","text":""},{"location":"user-guide/ref-architecture-aws/features/identities/credentials-vault/#hashicorp-vault-private-api-endpoint","title":"Hashicorp Vault private API endpoint","text":"<p>If you are on HCP, you can get this from the Admin UI. Otherwise, it will depend on how you set up DNS, TLS and port settings for your self-hosted installation. We always favours a private endpoint deployment only accessible from the VPN.</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/credentials-vault/#aws-self-hosted-vault-instance-endpoint","title":"AWS Self Hosted Vault Instance Endpoint","text":"<p><code>vault_address = \"https://vault.aws.binbash.co:8200\"</code></p>"},{"location":"user-guide/ref-architecture-aws/features/identities/credentials-vault/#hcp-vault-private-api-endpoint","title":"HCP Vault private API endpoint","text":"<p><code>vault_address = \"https://bb-le-shared-vault-cluster.private.vault.xxxxxxxxxx.aws.hashicorp.cloud:8200\"</code></p>"},{"location":"user-guide/ref-architecture-aws/features/identities/credentials-vault/#hashicorp-vault-token","title":"Hashicorp Vault token","text":"<p>We'll need to setup this Vault auth token in our [/config/common.config] file whenever we run the  Terraform Leverage Reference architecture for:</p> <ul> <li> le-tf-infra-aws</li> <li> le-tf-vault</li> </ul> <p>Vault token generation and authentication</p> <p>Vault token that will be used by Terraform, or vault cli to perform calls to Vault API. During the initial setup, you will have to use a root token. If you are using a self-hosted installation you will get such token after you initialize Vault; if you are using Hashicorp Cloud Platform you can get the token from HCP Admin UI.</p> <p>After the initial setup, and since we recommend integrating Vault to Github for authentication, you will have to follow these steps:</p> <ol> <li>Generate a GitHub Personal Access Token: https://github.com/settings/tokens</li> <li>Click \u201cGenerate new token\u201c</li> <li>Under scopes, only select <code>\"read:org\"</code>, under <code>\"admin:org\"</code></li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/identities/credentials-vault/#get-vault-token-from-your-gh-auth-token","title":"Get vault token from your GH auth token","text":"<ol> <li>Run vault cli v\u00eda docker: <code>docker run -it vault:1.7.2 sh</code></li> <li>Vault ENV vars setup ( NOTE: this will change a little bit between AWS self-hosted vs HCP vault deployment)       <pre><code>export VAULT_ADDR=\"https://vault-cluster.private.vault.XXXXXX.aws.hashicorp.cloud:8200\"; \\\nexport VAULT_NAMESPACE=\"admin\"\n</code></pre></li> <li><code>vault login -method=github</code> <pre><code>\u256d\u2500 \uf179 \ue0b1 \uf015 ~ \ue0b0\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\ue0b2 \u2714 \ue0b3 at 14:21:27 \uf017\n\u2570\u2500 docker run -it vault:1.7.2 sh\n/ # export VAULT_ADDR=\"https://bb-le-shared-vault-cluster.private.vault.xxxxxxx.a\nws.hashicorp.cloud:8200\"; export VAULT_NAMESPACE=\"admin\"\n\n/ # vault login -method=github\nGitHub Personal Access Token (will be hidden):\nSuccess! You are now authenticated. The token information displayed below\nis already stored in the token helper. You do NOT need to run \"vault login\"\nagain. Future Vault requests will automatically use this token.\n\nKey                    Value\n---                    -----\ntoken                  s.PNAXXXXXXXXXXXXXXXXXXX.hbtct\ntoken_accessor         KTqKKXXXXXXXXXXXXXXXXXXX.hbtct\ntoken_duration         1h\n...\n</code></pre></li> <li>input your GH personal access token</li> <li>Set the returned <code>token</code> in step 4) into <code>/config/common.config</code> -&gt; <code>vault_token=\"s.PNAXXXXXXXXXXXXXXXXXXX.hbtct\"</code></li> </ol> <p> NOTE: the admin token from https://portal.cloud.hashicorp.com/ will always work but it's use is discouraged for the nominated GH personal access token for security audit trail reasons</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/credentials-vault/#hashicorp-vault-ui-auth","title":"Hashicorp Vault UI Auth","text":"<p>You can also manage your Vault instance via its UI. We'll present below screenshot  to show an example using the Github personal access token, one of our supported auth methods. </p> <ol> <li>Generate a GitHub Personal Access Token: https://github.com/settings/tokens</li> <li>Click \u201cGenerate new token\u201c</li> <li>Under scopes, only select <code>\"read:org\"</code>, under <code>\"admin:org\"</code></li> </ol> <p>Open your preferred web browser choose Github auth method and paste your GH token and you'll be able to login to your instance.</p> <p></p> Figure: Vault HCP UI user authentication screen. (Source: binbash Leverage, \"Leverage Vault Reference Architecture auth method\", binbash Leverage Doc, accessed August 5th 2021)."},{"location":"user-guide/ref-architecture-aws/features/identities/credentials/","title":"AWS Credentials","text":"<p>Three main sets of credentials are used to interact with the AWS environment. We called them <code>bootstrap</code>, <code>management</code> and <code>security</code> credentials.</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/credentials/#bootstrap-credentials","title":"<code>bootstrap</code> credentials","text":"<p>These are temporary credentials used for the initial deployment of the architecture, and they should only be used for this purpose. Once this process is finished, <code>management</code> and <code>security</code> users should be the ones managing the environment.</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/credentials/#management-credentials","title":"<code>management</code> credentials","text":"<p><code>management</code> credentials are meant to carry the role of making all important administrative tasks in the environment (e.g. billing adjustments). They should be tied to a physical user in your organization.</p> <p>A user with these credentials will assume the role <code>OrganizationAccountAccessRole</code> when interacting the environment.</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/credentials/#security-credentials","title":"<code>security</code> credentials","text":"<p>These credentials are the ones to be used for everyday maintenance and interaction with the environment. Users in the role of DevOps | SecOps | Cloud Engineer in your organization should use these credentials.</p> <p>A user with these credentials will assume te role <code>DevOps</code> when interacting with the environment.</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/credentials/#read-more","title":"Read More","text":"<p>AWS reference links</p> <p>Consider the following AWS official links as reference:        </p> <ul> <li> Best practices for managing AWS access keys</li> <li> Cloud.gov | Secret key management - AWS credentials </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/identities/gpg/","title":"GPG Keys","text":""},{"location":"user-guide/ref-architecture-aws/features/identities/gpg/#why-do-we-use-gpg-keys","title":"Why do we use GPG keys?","text":"<p>By default our Leverage Reference Architectre base-identities layer  approach is to use IAM module  to manage AWS IAM Users credentials with encryption to grant strong security. </p> <p>This module outputs commands and GPG messages which can be decrypted either using command line to get AWS Web Console user's password and user's secret key.   </p> <p>Notes for keybase users</p> <p>If possible, always use GPG encryption to prevent Terraform from keeping unencrypted password and access secret key  in state file.</p> <p>Keybase pre-requisites</p> <p>When <code>gpg_key</code> is specified as <code>keybase:username</code>, make sure that the user public key has already been uploaded to  the Reference Architecture base-identities layer <code>keys</code> folder </p>"},{"location":"user-guide/ref-architecture-aws/features/identities/gpg/#managing-your-gpg-keys","title":"Managing your GPG keys","text":"<p>Create a key pair</p> <ul> <li>NOTE: the user for whom this account is being created needs to do this</li> <li>Install <code>gpg</code></li> <li>Run <code>gpg --version</code> to confirm</li> <li>Run <code>gpg --gen-key</code> and provide \"Your Name\" and \"Your Email\" as instructed -- you must also provide a passphrase</li> <li>Run <code>gpg --list-keys</code> to check that your key was generated</li> </ul> <p>Delete a key pair</p> <ul> <li>Run <code>gpg --list-keys</code> to check your key id</li> <li>Run <code>gpg --delete-secret-keys \"Your Name\"</code> to delete your private gpg key</li> <li>Run <code>gpg --delete-key \"Your Name\"</code> to delete your public gpg key</li> </ul> <p>Export your public key</p> <ul> <li>NOTE: the user must have created a key pair before doing this</li> <li>Run <code>gpg --export \"Your Name\" | base64</code></li> <li>Now the user can share her/his public key for creating her/his account</li> </ul> <p>Decrypt your encrypted password</p> <ol> <li>The user should copy the encrypted password from whatever media it was provided to her/him</li> <li>Run <code>echo \"YOUR ENCRYPTED STRING PASSWORD HERE\" | base64 --decode &gt; a_file_with_your_pass</code> <pre><code>$ echo \"wcBMA/ujy1wF7UPcAQgASLL/x8zz7OHIP+EHU7IAZfa1A9qD9ScP5orK1M473WlXVgPrded0iHpyZRwsJRS8Xe38AHZ65O6CnywdR522MbD\\\nRD6Yz+Bfc9NwO316bfSoTpyROXvMi+cfMEcihInHaCIP9YWBaI3eJ6VFdn90g9of00HYehBux7E2VitMuWo+v46W1p8/pw0b0H5qcppnUYYOjjSbjzzAuMF\\\nyNB5M1K8av61bPQPQTxBH3SFaM0B4RNmUl1bHKDIcdESYyIP/PRLQ45Rs5MzGgALIxBy24qdPNjHJQR48/5QV4nzB9qeEe4eWDB4ynSEfLsXggiz8fsbajV\\\ngSLNsdpqP9lYaueFdLgAeR6a+EjvqZfq0hZAgoiymsb4Qtn4A7gmeGmNeDE4td1mVfgzuTZ9zhnSbAYlXNIiM4b0MeX4HrjFkT/Aq+A/rvgBeKhszWD4Ibh\\\nA4PgC+QPiJRb5kQ/mX8DheQfAHJ24iUZk1jh6AsA\" | base64 --decode &gt; encrypted_pass\n</code></pre></li> <li>Run <code>gpg --decrypt a_file_with_your_pass</code> (in the path you've executed 2.) to effectively decrypt your pass using  your gpg key and its passphrase <pre><code>$ gpg --decrypt encrypted_pass\n\nYou need a passphrase to unlock the secret key for\nuser: \"Demo User (AWS org project-user acct gpg key w/ passphrase) &lt;username.lastname@domain.com&gt;\"\n2048-bit RSA key, ID 05ED43DC, created 2019-03-15 (main key ID D64DD59F)\n\ngpg: encrypted with 2048-bit RSA key, ID 05ED43DC, created 2019-03-15\n      \"Demo User (AWS org project-user acct gpg key w/ passphrase) &lt;username.lastname@domain.com&gt;\"\nVi0JA|c%fP*FhL}CE-D7ssp_TVGlf#%\n</code></pre>  Depending on your shell version an extra <code>%</code> character could appear as shown below, you must disregard this character since it's not part of the Initial (one time) AWS Web Console password. </li> <li>If all went well, the decrypted password should be there</li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/identities/gpg/#workaround-for-mac-users","title":"Workaround for Mac users","text":"<p>There are some situations where gpg keys generated on Mac don't work properly, generating errors like the following:</p> <pre><code>\u2577\n\u2502 Error: error encrypting password during IAM User Login Profile (user.lastname) creation: Error encrypting Password: error parsing given PGP key: openpgp: unsupported feature: unsupported oid: 2b060104019755010501\n\u2502 \n\u2502   with module.user[\"user.lastname\"].aws_iam_user_login_profile.this[0],\n\u2502   on .terraform/modules/user/modules/iam-user/main.tf line 12, in resource \"aws_iam_user_login_profile\" \"this\":\n\u2502   12: resource \"aws_iam_user_login_profile\" \"this\" {\n\u2502\n</code></pre> <p> Docker is required for this workaround.</p> <p>If you don't have docker on your PC, don't worry. You can easily install it following the steps on the official page.</p> <p>In these cases, execute the following steps:</p> <ol> <li> <p>Run an interactive console into an ubuntu container mounting your gpg directory. <pre><code>docker run --rm -it --mount type=bind,src=/Users/username/.gnupg,dst=/root/.gnupg ubuntu:latest\n</code></pre></p> </li> <li> <p>Inside the container, install required packages. <pre><code>apt update\napt install gnupg\n</code></pre></p> </li> <li> <p>Generate the key as described in previous sections, running <code>gpg --gen-key</code> at the interactive console in the ubuntu container.</p> </li> <li> <p>To fix permissions in your gpg directory, run these commands at the interactive console in the ubuntu container. <pre><code>find ~/.gnupg -type f -exec chmod 600 {} \\;\nfind ~/.gnupg -type d -exec chmod 700 {} \\;\n</code></pre></p> </li> <li> <p>Now you should be able to export the gpg key and decode the password from your mac, running <code>gpg --export \"Your Name\" | base64</code>.</p> </li> <li> <p>Finally, decrypt the password in your mac, executing: <pre><code>echo \"YOUR ENCRYPTED STRING PASSWORD HERE\" | base64 --decode &gt; a_file_with_your_pass\ngpg --decrypt a_file_with_your_pass\n</code></pre></p> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/identities/identities/","title":"Identity and Access Management (IAM) Layer","text":""},{"location":"user-guide/ref-architecture-aws/features/identities/identities/#setting-up-user-credentials","title":"Setting up user credentials","text":"<p>Please follow the steps below to orchestrate your <code>base-identities</code> layer 1<sup>st</sup> in your <code>project-root</code> AWS account and afterwards in your <code>project-security</code> account.</p> <p>IAM user standard creation workflow</p> <ol> <li>Pre-requisite add Public PGP Key following the documentation </li> <li>For steps 3. and 4. consider following  Leverage's Terraform workflow</li> <li>Update (add | remove) your IAM Users associated code and deploy  security/global/base-identities/users.tf<ul> <li> Consider customizing your account Alias and Password Policy</li> </ul> </li> <li>Update (add | remove | edit) your IAM Groups associated code and deploy  security/global/base-identities/groups.tf</li> <li>Get and share the IAM Users AWS Console user id and its OTP associated password from the  <code>make apply</code> outputs<ul> <li> temporally set <code>sensitive   = false</code> to get the encrypted outputs in your prompt output.</li> </ul> </li> <li>Each user will need to decrypt its AWS Console Password, you could share the associated documentation with them.</li> <li>Users must login to the AWS Web Console (https://project-security.signin.aws.amazon.com/console) with their  decrypted password and create new pass </li> <li>Activate MFA for Web Console (Optional but strongly recommended)</li> <li>User should  create his AWS ACCESS KEYS  if needed </li> <li>User could optionally set up\u00a0<code>~/.aws/project/credentials</code>\u00a0+\u00a0<code>~/.aws/project/config</code> following the immediately  below AWS Credentials Setup sub-section</li> <li>To allow users to  Access AWS Organization member account  consider repeating step 3. but for the corresponding member accounts:<ul> <li>shared/global/base-identities</li> <li>apps-devstg/global/base-identities</li> <li>app-prd/global/base-identities</li> </ul> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/identities/identities/#recommended-post-tasks","title":"Recommended Post-tasks","text":"<p>Deactivating AWS STS in not in use AWS Region</p> <p>When you activate STS endpoints for a Region, AWS STS can issue temporary credentials to users and roles in your account that make an AWS STS request. Those credentials can then be used in any Region that is enabled by default or is manually enabled. You must activate the Region in the account where the temporary credentials are generated.  It does not matter whether a user is signed into the same account or a different account when they make the request.</p> <p>To activate or deactivate AWS STS in a Region that is enabled by default (console)</p> <ol> <li>Sign in as a root user or an IAM user with permissions to perform IAM administration tasks.</li> <li>Open the IAM console and in the navigation pane choose Account settings.</li> <li>If necessary, expand Security Token Service (STS), find the Region that you want to activate, and then choose  Activate or Deactivate. For Regions that must be enabled, we activate STS automatically when you enable the Region.  After you enable a Region, AWS STS is always active for the Region and you cannot deactivate it. To learn how to  enable a Region, see Managing AWS Regions in the AWS General Reference.</li> </ol> <p> Source |  AWS Documentation IAM User Guide | Activating and deactivating AWS STS in an AWS Region</p> <p></p> <p>Figure: Deactivating AWS STS in not in use AWS Region. Only in used Regions must have STS activated.</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/identities/#next-steps","title":"Next Steps","text":"<p> Setup your AWS Credentials</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/overview/","title":"Identity and Access Management (IAM)","text":""},{"location":"user-guide/ref-architecture-aws/features/identities/overview/#overview","title":"Overview","text":"<p>Having this official AWS resource  as reference  we've define a security account structure for managing multiple accounts.</p> <p>User Management Definitions  </p> <ul> <li> IAM users will strictly be created and centralized in the Security account (member accounts IAM Users could be exceptionally created for very specific tools that still don\u2019t support IAM roles for cross-account auth). </li> <li> All access to resources within the Client organization will be assigned via policy documents attached to IAM roles or groups.</li> <li> All IAM roles and groups will have the least privileges required to properly work.</li> <li> IAM AWS and Customer managed policies will be defined, inline policies will be avoided whenever possible.</li> <li> All user management will be maintained as code and will reside in the DevOps repository.</li> <li> All users will have MFA enabled whenever possible (VPN and AWS Web Console).</li> <li> Root user credentials will be rotated and secured. MFA for root will be enabled. </li> <li> IAM Access Keys for root will be disabled.</li> <li> IAM root access will be monitored via CloudWatch Alerts.</li> </ul> <p>Why multi account IAM strategy?</p> <p>Creating a security relationship between accounts makes it even easier for companies to assess the security  of AWS-based deployments, centralize security monitoring and management, manage identity and access, and provide  audit and compliance monitoring services</p> <p></p> Figure: AWS Organization Security account structure for managing multiple accounts (just as reference). (Source: Yoriyasu Yano,   \"How to Build an End to End Production-Grade Architecture on AWS Part 2\", Gruntwork.io Blog, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-aws/features/identities/overview/#iam-groups-roles-definition","title":"IAM Groups &amp; Roles definition","text":"<p>AWS Org member accounts IAM groups :</p> Account Name AWS Org Member Accounts IAM Groups Admin Auditor DevOps DeployMaster project-management x     project-security x     x     x     x     <p>AWS Org member accounts IAM roles :</p> Account Name AWS Org Member Accounts IAM Roles Admin Auditor DevOps DeployMaster OrganizationAccountAccessRole project-management x     project-security x     x     x     x     project-shared x     x     x     x     x     project-legacy x     x     x     project-apps-devstg x     x     x     x     x     project-apps-prd x     x     x     x     x"},{"location":"user-guide/ref-architecture-aws/features/identities/roles/","title":"IAM Roles","text":"<p>What are AWS IAM Roles?  </p> <p>For the Leverage AWS Reference Architecture we heavily depend on AWS IAM roles, which is a standalone IAM entity  that:</p> <ul> <li>Allows you to attach IAM policies to it, </li> <li>Specify which other IAM entities to trust, and then </li> <li>Those other IAM entities can assume the IAM role to be temporarily get access to the permissions in those IAM     policies. </li> </ul> <p>The two most common use cases for IAM roles are</p> <ul> <li> Service roles: Whereas an IAM user allows a human being to access AWS resources, one of the most common use cases for an IAM  role is to allow a service\u2014e.g., one of your applications, a CI server, or an AWS service\u2014to access specific  resources in your AWS account. For example, you could create an IAM role that gives access to a specific S3 bucket  and allow that role to be assumed by one of your EC2 instances or Lambda functions. The code running on that AWS compute service will then be able to access that S3 bucket (or any other service you granted through this IAM roles) without you having to manually copy AWS credentials (i.e., access keys) onto that instance.</li> <li> Cross account access: Allow to grant an IAM entity in one AWS account access to specific resources in another AWS account. For example, if you have an IAM user in AWS account A, then by default, that IAM user cannot access anything in AWS account B. However, you could create an IAM role in account B that gives access to a specific S3 bucket (or any necessary AWS services) in  AWS account B and allow that role to be assumed by an IAM user in account A. That IAM user will then be able to access the contents of the S3 bucket by assuming the IAM role in account B. This ability to assume IAM roles across different  AWS accounts is the critical glue that truly makes a multi AWS account structure possible.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/identities/roles/#how-iam-roles-work","title":"How IAM roles work?","text":"Figure: Example of AWS cross-account AWS access. (Source: Kai Zhao,   \"AWS CloudTrail Now Tracks Cross-Account Activity to Its Origin\", AWS Security Blog, accessed November 17th 2020).  <p>Main IAM Roles related entities</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/roles/#iam-policies","title":"IAM policies","text":"<p>Just as you can attach IAM policies to an IAM user and IAM group, you can attach IAM policies to an IAM role.</p>"},{"location":"user-guide/ref-architecture-aws/features/identities/roles/#trust-policy","title":"Trust policy","text":"<p>You must define a trust policy for each IAM role, which is a JSON document (very similar to an IAM policy) that  specifies who can assume this IAM role. For example, we present below a trust policy that allows this IAM role to be  assumed by an IAM user named John in AWS account 111111111111: <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Action\": \"sts:AssumeRole\",\n\"Principal\": {\"AWS\": \"arn:aws:iam::111111111111:user/John\"}\n}\n]\n}\n</code></pre> Note that a trust policy alone does NOT automatically give John permissions to assume this IAM role.  Cross-account access always requires permissions in both accounts (2 way authorization). So, if John is in AWS account 111111111111 and you want him to have access to an IAM role called <code>DevOps</code> in account B ID 222222222222, then you need to configure permissions in both accounts:  1. In account 222222222222, the <code>DevOps</code> IAM role must have a trust policy that gives <code>sts:AssumeRole</code> permissions to  AWS account A ID 111111111111 (as shown above). 2. 2<sup>nd</sup>, in account A 111111111111, you also need to attach an IAM policy to John\u2019s IAM user that allows him to assume  the <code>DevOps</code> IAM role, which might look like this:</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Action\": \"sts:AssumeRole\",\n\"Resource\": \"arn:aws:iam::222222222222:role/DevOps\"\n}\n]\n}\n</code></pre>"},{"location":"user-guide/ref-architecture-aws/features/identities/roles/#assuming-an-aws-iam-role","title":"Assuming an AWS IAM role","text":"<p>How does it work?</p> <p>IAM roles do not have a user name, password, or permanent access keys. To use an IAM role, you must assume it by  making an <code>AssumeRole</code> API call (v\u00eda SDKs API,  CLI or  Web Console, which will return temporary access keys you can use in follow-up API calls to authenticate as the IAM role. The temporary  access keys will be valid for 1-12 hours (depending on your current validity expiration config), after which you must call <code>AssumeRole</code> again to fetch new temporary keys. Note that to make the <code>AssumeRole</code> API call, you must first authenticate to AWS using some other mechanism. </p> <p>For example, for an IAM user to assume an IAM role, the workflow looks like this: </p> Figure: Assuming an AWS IAM role. (Source: Gruntwork.io,   \"How to configure a production-grade AWS account structure using Gruntwork AWS Landing Zone\", Gruntwork.io Production deployment guides, accessed November 17th 2020).  <p>Basic AssumeRole workflow</p> <ol> <li>Authenticate using the IAM user\u2019s permanent AWS access keys</li> <li>Make the AssumeRole API call</li> <li>AWS sends back temporary access keys</li> <li>You authenticate using those temporary access keys</li> <li>Now all of your subsequent API calls will be on behalf of the assumed IAM role, with access to whatever     permissions are attached to that role</li> </ol> <p>IAM roles and AWS services</p> <p>Most AWS services have native support built-in for assuming IAM roles. </p> <p>For example: </p> <ul> <li>You can associate an IAM role directly with an EC2 instance (instance profile), and that instance will  automatically assume the IAM role every few hours, making the temporary credentials available in EC2 instance metadata. </li> <li>Just about every AWS CLI and SDK tool knows how to read and periodically update temporary credentials from EC2  instance metadata, so in practice, as soon as you attach an IAM role to an EC2 instance, any code running on that  EC2 instance can automatically make API calls on behalf of that IAM role, with whatever permissions are attached to that role. This allows you to give code on your EC2 instances IAM permissions without having to manually figure out how to copy credentials (access keys) onto that instance. </li> <li>The same strategy works with many other AWS services: e.g., you use IAM roles as a secure way to give your Lambda  functions, ECS services, Step Functions, and many other AWS services permissions to access specific resources in   your AWS account.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/identities/roles/#read-more","title":"Read more","text":"<p>AWS reference links</p> <p>Consider the following AWS official links as reference:</p> <ul> <li> AWS Identities | Roles terms and concepts</li> <li> AWS Identities | Common scenarios</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/apm/","title":"Application Performance Monitoring (APM) and Business Performance","text":"<p>Custom Prometheus BlackBox Exporter + Grafana &amp;  Elastic Application performance monitoring (APM)   delivers real-time and trending data about your web application's performance and the level of satisfaction that your end users experience. With end to end transaction tracing and a variety of color-coded charts and reports, APM visualizes your data, down to the deepest code levels. Your DevOps teams don't need to guess whether a performance blocker comes from the app itself, CPU availability, database loads, or something else entirely unexpected. With APM, you can quickly identify potential problems before they affect your end users.</p> <p>APM's user interface provides both current and historical information about memory usage, CPU utilization, database query performance, web browser rendering performance, app availability and error analysis, external services,  and other useful metrics.</p>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/apm/#slis-kpis","title":"SLIs / KPIs","text":"<p>Service Level Indicators (SLIs)</p> <ul> <li> latency</li> <li> throughput</li> <li> availability</li> <li> error rate</li> </ul> <p>KPI for business performance</p> <ul> <li> General <ul> <li>DOM readiness </li> <li>Page render </li> <li>Apdex </li> <li>Mobile crash rate</li> </ul> </li> <li> Web <ul> <li>Session count</li> <li>Session duration</li> <li>Page views </li> <li>Error % </li> </ul> </li> <li> Mobile <ul> <li>App launches</li> <li>User counts</li> <li>Load time</li> <li>Crash rates</li> <li>Crash locations </li> <li>Error rates </li> <li>API errors</li> </ul> </li> </ul> <p>KPI for app and infrastructure teams</p> <ul> <li> App/Infra <ul> <li>Availability</li> <li>Throughput </li> <li>App/Api/Db </li> <li>Response time </li> <li>Memory footprint </li> <li>CPU workload</li> </ul> </li> <li> DevOps <ul> <li>Builds </li> <li>Commits </li> <li>Deploys </li> <li>Errors </li> <li>Support incidents </li> <li>MTTR </li> </ul> </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/apm/#read-more","title":"Read More","text":"<ul> <li> NewRelic | Optimize customer experience (KPIs)</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/logs/","title":"Logs","text":""},{"location":"user-guide/ref-architecture-aws/features/monitoring/logs/#overview","title":"Overview","text":"<p>Centralized Logs Solution</p> <p>For this purpose we propose the usage of Elasticsearch + Kibana for database and visualization respectively.  By deploying the Fluentd daemonset on the Kubernetes clusters we can send all logs from running pods to Elasticsearch,  and with \u2018beat\u2019 we can send specific logs for resources outside of Kubernetes. There will be many components across the environment generating different types of logs: ALB access logs, s3 access logs, cloudfront access logs, application request logs, application error logs. Access logs on AWS based resources can be stored in a centralized bucket for that purpose, on the security account and given the need these can be streamed to Elasticsearch as well if needed.</p> <p></p> Figure: Monitoring metrics and log architecture diagram (just as reference). (Source: binbash Leverage,   \"AWS Well Architected Reliability Report example\", binbash Leverage Doc, accessed November 18th 2020).  <p>Alerting based on Logs</p> <p>Certain features that were only available under licence were recently made available by Elastic, and included in the open source project of Elasticsearch. Elastalert allow us to generate alerts based on certain log entries or even after counting a certain amount of a type of entry, providing great flexibility.</p> <p>--</p>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/logs/#alternatives-comparison-table","title":"Alternatives Comparison Table","text":"<p>Leverage Confluence Documentation</p> <p>You'll find here a detailed comparison table between EC2 Self-hosted and AWS ElasticSearch Elastic-Kibana Stack.</p>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/metrics/","title":"Metrics","text":"<p>There are metrics  that are going to be of interest both in the infrastructure itself (CPU, Memory, disk) and also on  application level (amount of non 200 responses, latency, % of errors) and we will have two key sources for this:  Prometheus and AWS CloudWatch metrics.</p> <p>Metric collectors</p> <ul> <li> CloudWatch metrics: Is where amazon stores a great number of default metrics for each of its services. Useful data here can be interpreted and alerts can be generated with Cloudwatch alerts and can also be used as a source for Grafana. Although this is a very good offering, we have found it to be incomplete and highly bound to AWS services but not integrated enough with the rest of the ecosystem.</li> <li> Prometheus: This is an open source tool (by Soundcloud) that is essentially a time-series database. It stores metrics, and it has the advantage of being highly integrated with all Kubernetes things. In fact, Kubernetes is already publishing various metrics in Prometheus format \u201cout of the box\u201d. It\u2019s alerting capabilities are also remarkable, and it can all be kept as code in a repository.  It has a big community behind it, and it\u2019s not far fetched at this point to include a library in your own application that provides you with the ability to create an endpoint that publishes certain metrics about your own application, that we can graph or alert based on them.</li> </ul> <p></p> Figure: Monitoring metrics and log architecture diagram (just as reference). (Source: binbash Leverage,   \"AWS Well Architected Reliability Report example\", binbash Leverage Doc, accessed November 18th 2020).  <p>Graphing metrics</p> <p>Grafana is the standard open source visualization tool which can be used on top of a variety of different data stores. It can use prometheus as a source, and there are many open source dashboards and plugins available that provide great visualization of how things are running, and we can also build our own if necessary. If something is left out of prometheus and already available in Cloudwatch metrics we can easily integrate it as a source for Grafana as well, and build dashboards that integrate these metrics and even do some intelligence on them coming from multiple origins.</p> <p></p> Figure: Grafana K8s cluster metrics monitoring dashboard reference screenshot. (Source: DevOpsProdigy,   \"Grafana DevOpsProdigy KubeGraf Plugin\", Grafana plugins, accessed November 18th 2020).  <p></p> Figure: Grafana K8s cluster metrics monitoring dashboard reference screenshot. (Source: DevOpsProdigy,   \"Grafana DevOpsProdigy KubeGraf Plugin\", Grafana plugins, accessed November 18th 2020).  <p>Alerting based on metrics</p> <p>Although Grafana already has alerting capabilities built in, we rather (most of the times) have Prometheus alerting engine configured, because we can have really customize and specify alerts. We can have them as code in their extremely readable syntax. Example:</p> <p></p> Figure: Prometheus Alert Manager `CriticalRamUsage` alert screenshot (just as reference). (Source: binbash Leverage)."},{"location":"user-guide/ref-architecture-aws/features/monitoring/monitoring/","title":"SRE &amp; Monitoring: Metrics, Logs &amp; Tracing","text":""},{"location":"user-guide/ref-architecture-aws/features/monitoring/monitoring/#overview","title":"Overview","text":"<p>There are two key approaches that we will cover with the proposed tools, Logs based monitoring and Metrics based monitoring. </p> <p>Monitoring tools</p> <p> Metrics: Prometheus     - node-exporter      - blackbox-exporter     - alert-manager </p> <p> Metrics Dashboard: Grafana</p> <ul> <li> Data Sources<ul> <li>Prometheus </li> <li>CloudWatch</li> </ul> </li> <li> Plugins <ul> <li>piechart-panel </li> <li>devopsprodigy-kubegraf-app</li> </ul> </li> </ul> <p> Centralized Logs: Elasticsearch-Fluent-Kibana (EFK) </p> <ul> <li> Query Logs </li> <li> Dashboards </li> <li> Alerts based on logs</li> </ul> <p> Distributed Tracing: Jaeger + Opensensus</p>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/notification_escalation/","title":"Notification &amp; Escalation Procedure","text":""},{"location":"user-guide/ref-architecture-aws/features/monitoring/notification_escalation/#overview","title":"Overview","text":"Urgency Service Notification Setting Use When Response High 24/7     High-priority PagerDuty Alert 24/7/365     <ul> <li>  Issue is in Production  <li>Or affects the applications/services and in turn affects the normal operation of the clinics  <li>Or prevents clinic patients to interact with the applications/services </li> <ul> <li>  Requires immediate human action  <li>Escalate as needed  <li>The engineer should be woken up </li> High during support hours     High-priority Slack Notifications during support hours     <ul> <li>  Issue impacts development team productivity  <li>Issue impacts the normal business operation </li> <ul> <li>  Requires immediate human action ONLY during business hours </li> </ul> Low     Low Priority Slack Notification     <ul> <li>  Any issue, on any environment, that occurs during working hours </li> </ul> <ul> <li>  Requires human action at some point  <li>Do not escalate  <li>An engineer should not be woken up </li>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/notification_escalation/#service-notification-settings","title":"Service Notification Settings","text":"Service Notification Setting Description High-priority PagerDuty Alert 24/7/365     <ul> <li> Notify on-call engineers --- At first, notify via SMS/Push --- Notify via Phone Call if after 10 minutes the previous has not acknowledged  <li>Notify person X (this is a person who needs to be aware of any of these issues always)  <li>Notify to Slack =&gt; engineering-urgent-alerts channel </li> High-priority Slack Notifications during support hours     <ul> <li> Notify to Slack =&gt; engineering-alerts channel </li> </ul> Low Priority Slack Notification     <ul> <li> Notify to Slack =&gt; engineering-alerts channel </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/notification_escalation/#alert-types","title":"Alert Types","text":"<p>UpTimeRobot (black box)</p> <ul> <li>https://uptimerobot.com/</li> <li>Sites or APIs are down</li> </ul> <p>Prometheus Alert Manager (black box, metrics-based)</p> <ul> <li>http://prometheus.aws.domain.com/</li> <li>Clusters issues (masters/nodes high resources usage)</li> <li>Instance issues (Pritunl VPN, Jenkins, Spinnaker, Grafana, Kibana, etc)</li> <li>Alerts from Prometheus Blackbox Exporter</li> </ul> <p>Kibana ElastAlert (black box, logs-based)</p> <ul> <li>Intended for applications/services logs</li> <li>Applications/services issues (frontends, backend services)</li> <li>Cluster components issues (nginx-ingress, cert-manager, linkerd, etc)</li> </ul> <p>PagerDuty</p> <ul> <li>https://domain.pagerduty.com/</li> <li>Incident management</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/notification_escalation/#implementation-reference-example","title":"Implementation Reference Example","text":"<p>Slack</p> <p>All alerts are sent to #engineering-urgent-alerts channel. Members that are online can have visibility from there. AlertManager takes care of sending such alerts according to the rules defined here: TODO</p> <p>Note: there is a channel named <code>engineering-alerts</code> but is used for Github notifications. It didn\u2019t make sense to mix real alerts with that, that is why a new <code>engineering-urgent-alerts</code> channel was created. As a recommendation, Github notifications should be sent to a channel named like #engineering-notifications and leave <code>engineering-alerts</code> for real alerts.</p> <p>PagerDuty</p> <p>AlertManager only sends to PagerDuty alerts that are labeled as severity: critical. PagerDuty is configured to  turn these into incidents according to the settings defined here for the Prometheus Critical Alerts service. The aforementioned service uses HiPriorityAllYearRound escalation policy to define who gets notified and how.</p> <p>Note: currently only the TechOwnership role gets notified as we don\u2019t have agreements or rules about on-call  support but this can be easily changed in the future to accommodate business decisions.</p> <p>UpTimeRobot</p> <p>We are doing basic http monitoring on the following sites: *   www.domain_1.com *   www.domain_2.com *   www.domain_3.com</p> <p>Note: a personal account has been set up for this. As a recommendation, an new account should be created using  an email account that belongs to your project.</p>"},{"location":"user-guide/ref-architecture-aws/features/monitoring/tracing/","title":"Distributed Tracing","text":"<p>Solution Design</p> <p>Distributed tracing, also called distributed request tracing, is a method used to profile and monitor applications, especially those built using a microservices architecture. Distributed tracing helps pinpoint where failures occur and what causes poor performance.</p> <p></p> Figure: Figure: Distributed tracing architecture diagram (just as reference). (Source: binbash Leverage,   \"AWS Well Architected Reliability Report example\", binbash Leverage Doc, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-aws/features/monitoring/tracing/#read-more","title":"Read more","text":"<p>Related resources</p> <ul> <li> Jaeger </li> <li> Opensensus</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/network/dns/","title":"Route53 DNS hosted zones","text":""},{"location":"user-guide/ref-architecture-aws/features/network/dns/#how-it-works","title":"How it works","text":"<p>  Route53 Considerations</p> <ul> <li> Route53 private hosted zone will have associations with VPCs on different AWS organization accounts</li> <li> Route53 should ideally be hosted in the Shared account, although sometimes Route53 is already deployed in a Legacy     account where it can be imported and fully supported as code.</li> <li> Route53 zero downtime migration      (active-active hosted zones) is completely possible and achievable with Leverage terraform code    </li> </ul> <p></p> Figure: AWS Organization shared account Route53 DNS diagram. (Source: Cristian Southall,   \"Using CloudFormation Custom Resources to Configure Route53 Aliases\", Abstractable.io Blog post, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-aws/features/network/dns/#user-guide","title":"User guide","text":"<p>pre-requisites</p> <ul> <li> Review &amp; update configs </li> <li> Review &amp; understand the workflow </li> </ul> <p>Steps</p> <ol> <li>DNS service has to be orchestrated from  <code>/shared/global/base-dns</code> layer  following the standard workflow</li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/network/dns/#migrated-aws-route53-hosted-zones-between-aws-accounts","title":"Migrated AWS Route53 Hosted Zones between AWS Accounts","text":"<p>We'll need to setup the Route53 DNS service with an active-active config to avoid any type of service disruption and  downtime. This would then allow the Name Servers of both AWS Accounts to be added to your domain provider (eg: namecheap.com) and have for example: </p> <ul> <li>4 x ns (<code>project-legacy</code> Route53 Account) </li> <li>4 x ns (<code>project-shared</code> Route53 Account) </li> </ul> <p>After the records have propagated and everything looks OK we could remove the <code>project-legacy</code> Route53 ns from your domain provider (eg: namecheap.com) and leave only the of <code>project-shared</code> ones.</p> <p>This official Migrating a hosted zone to a different AWS account - Amazon Route 53 article  explains this procedure step by step:</p> <p>AWS Route53 hosted zone migration steps</p> <ol> <li>Create records in the new hosted zone (bb-shared)</li> <li>Compare records in the old and new hosted zones (bb-legacy)</li> <li>Update the domain registration to use name servers for the new hosted zone (NIC updated to use both  bb-legacy + bb-shared)</li> <li>Wait for DNS resolvers to start using the new hosted zone</li> <li>(Optional) delete the old hosted zone (bb-legacy), remember you'll need to delete the ns delegation  records from your domain registration (NIC) too.</li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/network/network-nacl/","title":"Security in AWS with Leverage Reference Architecture and NACLs","text":"<p>When deploying an AWS Landing Zone resources, security is of fundamental importance. Network Access Control Lists (NACLs) play a crucial role in controlling traffic at the subnet level. In this section we'll describe the use of NACLs implementing with Terraform over the Leverage AWS Reference Architecture.</p>"},{"location":"user-guide/ref-architecture-aws/features/network/network-nacl/#understanding-network-access-control-lists-nacls","title":"Understanding Network Access Control Lists (NACLs)","text":"<p>Network Access Control Lists (NACLs) act as a virtual firewall for your AWS VPC (Virtual Private Cloud), controlling inbound and outbound traffic at the subnet level. They operate on a rule-based system, allowing or denying traffic based on defined rules.</p>"},{"location":"user-guide/ref-architecture-aws/features/network/network-nacl/#leverage-ref-arch-default-configuration-and-variables-setup-for-nacls","title":"Leverage Ref Arch: Default Configuration and Variables Setup for NACLs","text":"<p>In the Leverage Reference Architecture, we adopt the default NACLs approach. This foundational setup not only ensures a controlled security environment but also offers the flexibility for customization.</p> <p>This setup ensures that default NACLs are used, providing a baseline level of security.: <pre><code>manage_default_network_acl    = true\npublic_dedicated_network_acl  = false // use dedicated network ACL for the public subnets.\nprivate_dedicated_network_acl = false // use dedicated network ACL for the private subnets.\n</code></pre> To verify that default NACLs are enabled in your Leverage proyect, follow this steps:</p> <ol> <li> <p>Move into the <code>/shared/us-east-1/base-network/</code> directory.</p> </li> <li> <p>Open <code>network.tf</code> file:   The <code>network.tf</code> file defines the configuration for the VPC (Virtual Private Cloud) and NACL service using a terraform module.     <pre><code>module \"vpc\" {\nsource = \"github.com/binbashar/terraform-aws-vpc.git?ref=v3.18.1\"\n.\n.\n.\nmanage_default_network_acl    = var.manage_default_network_acl\npublic_dedicated_network_acl  = var.public_dedicated_network_acl  // use dedicated network ACL for the public subnets.\nprivate_dedicated_network_acl = var.private_dedicated_network_acl // use dedicated network ACL for the private subnets.\n.\n.\n.\n</code></pre></p> </li> <li> <p>Open <code>variable.tf</code> file:   The module allows customization of Network Access Control Lists (NACLs) through specified variables     <pre><code>variable \"manage_default_network_acl\" {\ndescription = \"Manage default Network ACL\"\ntype        = bool\n default     = true\n}\nvariable \"public_dedicated_network_acl\" {\ndescription = \"Manage default Network ACL\"\ntype        = bool\n  default     = false\n}\nvariable \"private_dedicated_network_acl\" {\ndescription = \"Manage default Network ACL\"\ntype        = bool\n  default     = false\n}\n</code></pre></p> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/network/network-nacl/#key-points-to-kae-into-account-for-a-robust-and-secure-setup","title":"Key Points to kae into account for a robust and secure setup:","text":"<ol> <li> <p>Explicit Approval Process for NACL Enablement: Enabling NACLs should not be taken lightly. Users or tech leads wishing to enable NACLs must undergo an explicit approval process. This additional step ensures that the introduction of NACLs aligns with the overall security policies and requirements of the organization.</p> </li> <li> <p>Feedback Mechanisms for NACL Status and Permissions: Communication is key when it comes to security configurations. Feedback mechanisms should be in place to inform users of the status of NACLs and any associated permissions. This ensures transparency and allows for prompt resolution of any issues that may arise.</p> </li> <li> <p>Comprehensive Testing for Non-disruptive Integration: Before enabling NACLs, comprehensive testing should be conducted to ensure that the default disabling of NACLs does not introduce new issues. This includes testing in different environments and scenarios to guarantee a non-disruptive integration. Automated testing and continuous monitoring can be valuable tools in this phase.</p> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/network/network-nacl/#conclusion","title":"Conclusion","text":"<p>We prioritize operational simplicity to provide an efficient deployment process; however, it's essential for users to conduct a review process align with their specific security and compliance requirements.</p> <p>This approach allows users to benefit from initial ease of use while maintaining the flexibility to customize and enhance security measures according to their unique needs and compliance standards</p> <p>In this code, we ensure that default NACLs are enabled. Users can later seek approval and modify these variables if enabling dedicated NACLs becomes necessary.</p>"},{"location":"user-guide/ref-architecture-aws/features/network/tgw-topology/","title":"Network Topology with AWS Transit Gateway","text":""},{"location":"user-guide/ref-architecture-aws/features/network/tgw-topology/#transit-gateway","title":"Transit Gateway","text":""},{"location":"user-guide/ref-architecture-aws/features/network/tgw-topology/#dedicated-tgw-network-account-architecture","title":"Dedicated TGW Network Account Architecture","text":"Figure: Multi-account dedicated network transit gateway architecture diagram. (Source: binbash Leverage, \"Leverage Reference Architecture dedicated network account TGW implementation\", binbash Leverage Doc, accessed August 4th 2021)."},{"location":"user-guide/ref-architecture-aws/features/network/vpc-addressing/","title":"Network Layer","text":"<p>In this section we detail all the network design related specifications</p> <ul> <li> VPCs CIDR blocks</li> <li> VPC Gateways:  Internet, NAT, VPN.</li> <li> VPC Peerings</li> <li> VPC DNS Private Hosted Zones Associations.</li> <li> Network ACLS (NACLs)</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-addressing/#vpcs-ip-addressing-plan-cidr-blocks-sizing","title":"VPCs IP Addressing Plan (CIDR blocks sizing)","text":"<p>Introduction</p> <p>VPCs can vary in size from 16 addresses (/28 netmask) to 65,536 addresses (/16 netmask).  In order to size a VPC correctly, it is important to understand the number, types, and sizes of workloads  expected to run in it, as well as workload elasticity and load balancing requirements. </p> <p>Keep in mind that there is no charge for using Amazon VPC (aside from EC2 charges), therefore cost  should not be a factor when determining the appropriate size for your VPC, so make sure you size your  VPC for growth.</p> <p>Moving workloads or AWS resources between networks is not a trivial task, so be generous in your  IP address estimates to give yourself plenty of room to grow, deploy new workloads, or change your  VPC design configuration from one to another. The majority of AWS customers use VPCs with a /16  netmask and subnets with /24 netmasks. The primary reason AWS customers select smaller VPC and  subnet sizes is to avoid overlapping network addresses with existing networks. </p> <p>So having AWS single VPC Design we've chosen a Medium/Small VPC/Subnet addressing plan which would probably fit a broad range variety of use cases</p>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-addressing/#networking-ip-addressing","title":"Networking - IP Addressing","text":"<p>Starting CIDR Segment (AWS Org)</p> <ul> <li> AWS Org IP Addressing calculation is presented below based on segment <code>172.16.0.0/12</code></li> <li> We started from <code>172.16.0.0/12</code> and subnetted to <code>/20</code></li> <li> Resulting in Total Subnets: 256<ul> <li>2 x AWS Account with Hosts/SubNet: 4094</li> <li>1ry VPC + 2ry VPC</li> <li>1ry VPC DR + 2ry VPC DR</li> </ul> </li> </ul> <p>Individual CIDR Segments (VPCs)</p> <p> Then each of these are /20 to /24</p> <ul> <li> <p> Considering the whole Starting CIDR Segment (AWS Org) before declared, we'll start at <code>172.18.0.0/20</code></p> <ul> <li>shared<ul> <li>1ry VPC CIDR: <code>172.18.0.0/24</code></li> <li>2ry VPC CIDR: <code>172.18.16.0/24</code></li> <li>1ry VPC DR CIDR: <code>172.18.32.0/24</code></li> <li>2ry VPC DR CIDR: <code>172.18.48.0/24</code></li> </ul> </li> <li>apps-devstg<ul> <li>1ry VPC CIDR: <code>172.18.64.0/24</code></li> <li>2ry VPC CIDR: <code>172.18.80.0/24</code></li> <li>1ry VPC DR CIDR: <code>172.18.96.0/24</code></li> <li>2ry VPC DR CIDR: <code>172.18.112.0/24</code></li> </ul> </li> <li>apps-prd<ul> <li>1ry VPC CIDR: <code>172.18.128.0/24</code></li> <li>2ry VPC CIDR: <code>172.18.144.0/24</code></li> <li>1ry VPC DR CIDR: <code>172.18.160.0/24</code></li> <li>2ry VPC DR CIDR: <code>172.18.176.0/24</code></li> </ul> </li> </ul> </li> <li> <p> Resulting in Subnets: 16 x VPC</p> <ul> <li>VPC Subnets with Hosts/Net: 256.</li> <li>Eg: apps-devstg account \u2192 us-east-1 w/ 3 AZs \u2192 3 x Private Subnets /az + 3 x Public Subnets /az<ul> <li>1ry VPC CIDR: <code>172.18.64.0/24</code>Subnets:<ul> <li>Private <code>172.18.64.0/24, 172.18.66.0/24 and 172.18.68.0/24</code></li> <li>Public <code>172.18.65.0/24, 172.18.67.0/24 and 172.18.69.0/24</code></li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-addressing/#planned-subnets-per-vpc","title":"Planned Subnets per VPC","text":"<p>Having defined the initial VPC that will be created in the different accounts that were defined, we are going to create subnets in each of these VPCs defining Private and Public subnets split among different availability zones:</p> Subnet address Range of addresses Hosts Assignment 172.18.0.0/20 172.18.0.0 - 172.18.15.255 4094 1ry VPC: shared 172.18.16.0/20 172.18.16.0 - 172.18.31.255 4094 2ry VPC: shared 172.18.32.0/20 172.18.32.0 - 172.18.47.255 4094 1ry VPC DR: shared 172.18.48.0/20 172.18.48.0 - 172.18.63.255 4094 2ry VPC DR: shared 172.18.64.0/20 172.18.64.0 - 172.18.79.255 4094 1ry VPC: apps-devstg 172.18.80.0/20 172.18.80.0 - 172.18.95.255 4094 2ry VPC: apps-devstg 172.18.96.0/20 172.18.96.0 - 172.18.111.255 4094 1ry VPC DR: apps-devstg 172.18.112.0/20 172.18.112.0 - 172.18.127.255 4094 2ry VPC DR: apps-devstg 172.18.128.0/20 172.18.128.0 - 172.18.143.255 4094 1ry VPC: apps-prd 172.18.144.0/20 172.18.144.0 - 172.18.159.255 4094 2ry VPC: apps-prd 172.18.160.0/20 172.18.160.0 - 172.18.175.255 4094 1ry VPC DR: apps-prd 172.18.176.0/20 172.18.176.0 - 172.18.191.255 4094 2ry VPC DR: apps-prd"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-addressing/#considerations","title":"Considerations","text":"<ul> <li>Kubernetes on EKS General Requirements for Network Layer: K8s EKS Networking |\u00a0VPC Adressing</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-addressing/#user-guide","title":"User guide","text":"<p>Please follow the steps below to orchestrate your <code>base-network</code> layer, 1<sup>st</sup> in your <code>project-shared</code> AWS account and afterwards in the necessary member accounts which will host network connected resources (EC2, Lambda, EKS, RDS, ALB, NLB, etc):  </p> <ul> <li> <code>project-apps-devstg</code> account.</li> <li> <code>project-apps-prd</code> account.</li> </ul> <p>Network layer standard creation workflow</p> <ol> <li>Please follow  Leverage's Terraform workflow for each of your accounts.</li> <li>We'll start by <code>project-shared</code> AWS Account Update (add | remove | customize) your VPC associated code before  deploying this layer shared/base-network     Main files<ul> <li> network.tf</li> <li> locals.tf</li> </ul> </li> <li>Repeat for every AWS member Account that needs its own VPC  Access AWS Organization member account  consider repeating step 3. but for the corresponding member accounts.</li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-addressing/#next-steps","title":"Next Steps","text":"<p> AWS VPC Peering</p>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-peering/","title":"Diagram: Network Service (cross-account VPC peering)","text":""},{"location":"user-guide/ref-architecture-aws/features/network/vpc-peering/#how-it-works","title":"How it works","text":"<p>TODO</p>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-peering/#user-guide","title":"User guide","text":"<p>TODO</p>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-peering/#diagram-network-service-cross-account-vpc-peering_1","title":"Diagram: Network Service (cross-account VPC peering)","text":"Figure: AWS multi account Organization VPC peering diagram. (Source: AWS,   \"Amazon Virtual Private Cloud VPC Peering\", AWS Documentation Amazon VPC User Guide, accessed November 18th 2020).  Figure: AWS multi account Organization peering detailed diagram. (Source: AWS,   \"Amazon Virtual Private Cloud VPC Peering\", AWS Documentation Amazon VPC User Guide, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-aws/features/network/vpc-topology/","title":"Network Layer","text":""},{"location":"user-guide/ref-architecture-aws/features/network/vpc-topology/#network-topology","title":"Network Topology","text":"<p>VPC with public and private subnets (NAT)</p> <ul> <li> <p> The configuration for this scenario includes a virtual private cloud (VPC) with public subnets and a private  subnets (it's number will change depending on our specific needs). We recommend this scenario if you want  to run a public-facing web application, while maintaining back-end servers that aren't publicly accessible.  A common example is a multi-tier website, with a Load Balancer (ALB | NLB) in a public subnet, or other public facing routing service like AWS CloudFront or Api Gateway, and our web servers (Lambda, EKS, ECS, EC2) and  database (RDS, DynamoDB, etc) servers in private subnets. You can set up security (SGs, ACLs, WAF) and routing  so that the web servers can communicate internally (even between VPC accounts or VPN Endpoints) with all necessary  services and components such as databases, cache, queues, among others.</p> </li> <li> <p> The services running in the public subnet, like an ALB or NLB can send outbound traffic directly to the Internet,  whereas the instances in the private subnet can't. Instead, the instances in the private subnet can access the  Internet by using a network address translation (NAT) gateway that resides in the public subnet. The database  servers can connect to the Internet for software updates using the NAT gateway (if using RDS this is transparently provided by AWS), but the Internet cannot establish connections to the database servers.</p> </li> <li> <p> So, whenever possible all our AWS resources like EC2, EKS, RDS, Lambda, SQS will be deployed in VPC private  subnets and we'll use a NAT device (Nat Gateway) to enable instances in a private subnet to connect to the   internet (for example, for software updates) or other AWS services, but prevent the internet from initiating  connections with the instances. </p> </li> <li> <p> A NAT device forwards traffic from the instances in the private subnet to the internet (via the VPC Internet Gateway) or other AWS services, and then sends the response back to the instances. When traffic goes to the  internet, the source IPv4 address is replaced with the NAT device\u2019s address and similarly, when the response traffic goes to those instances, the NAT device translates the address back to those instances\u2019 private IPv4 addresses.</p> </li> </ul> <p></p> Figure: VPC topology diagram. (Source: AWS,   \"VPC with public and private subnets (NAT)\", AWS Documentation Amazon VPC User Guide, accessed November 18th 2020).  <p></p> Figure: VPC topology diagram with multiple Nat Gateways for HA. (Source: Andreas Wittig,   \"Advanced AWS Networking: Pitfalls That You Should Avoid\", Cloudonaut.io Blog, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-aws/features/network/vpc-topology/#read-more","title":"Read more","text":"<p>AWS reference links</p> <p>Consider the following AWS official links as reference:</p> <ul> <li> VPC with public and private subnets (NAT)</li> <li> AWS Elastic Load Balancing</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-traffic-out/","title":"Network Security","text":""},{"location":"user-guide/ref-architecture-aws/features/network/vpc-traffic-out/#control-internet-access-outbound-traffic","title":"Control Internet access outbound traffic","text":""},{"location":"user-guide/ref-architecture-aws/features/network/vpc-traffic-out/#goals","title":"Goals","text":"<ul> <li> Review and analyse available alternatives for controlling outbound traffic in VPCs.</li> <li> All possible candidates need to offer a reasonable balance between features and pricing.</li> </ul> <p>Solutions</p>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-traffic-out/#leverage-currently-supports","title":"Leverage currently supports","text":"<ul> <li>Network ACL (Subnet firewall)</li> <li>Security Groups (Instance firewall)</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-traffic-out/#what-alternatives-do-we-have","title":"What alternatives do we have?","text":""},{"location":"user-guide/ref-architecture-aws/features/network/vpc-traffic-out/#pre-considerations","title":"Pre-considerations","text":"<p>First of all, keep in mind the following points before and while you go through the data in the table:</p> <ul> <li>1 EBS pricing at the moment of this writing:</li> <li>GP2: $0.10 per GB-month</li> <li> <p>GP3: $0.08 per GB-month)</p> </li> <li> <p>2 DataTransfer costs will be incurred in all options</p> </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/network/vpc-traffic-out/#dedicated-network-nat-gw-network-firewall-account","title":"Dedicated Network NAT-GW + Network Firewall Account","text":"<p>Centralized Network Firewall deployment model, North-South: Centralized internet egress (VPC to internet via Transit Gateway) and NAT gateway.</p> <p></p> Figure: Multi-account dedicated network transit gateway + network firewall architecture diagram. (Source: binbash Leverage, \"Leverage Reference Architecture dedicated network account TGW + NFW implementation\", binbash Leverage Doc, accessed August 4th 2021)."},{"location":"user-guide/ref-architecture-aws/features/network/vpc-traffic-out/#comparison-of-the-alternatives-analysed","title":"Comparison of the alternatives analysed","text":"<p>Leverage Confluence Documentation</p> <p>You'll find here  a detailed comparison table including the alternative product and solution types, pricing model, features, pros &amp; cons.</p>"},{"location":"user-guide/ref-architecture-aws/features/organization/accounts/","title":"Managing Accounts","text":"<p>Our default AWS Organizations terraform layout solution includes <code>5 accounts + 1</code> or N accounts (if you invite pre-existing AWS Accounts).</p> Account Description Management (Root) Used to manage configuration and access to AWS Org managed accounts. The AWS Organizations account provides the ability to create and financially manage member accounts, it contains AWS Organizations Service Control Policies(SCPs). Shared Services / Resources Reference for creating infrastructure shared services such as directory services, DNS, VPN Solution, Monitoring tools like Prometheus and Grafana, CI/CD server (Jenkins, Drone, Spinnaker, etc), centralized logging solution like ELK  and Vault Server (Hashicorp Vault) Security Intended for centralized user management via IAM roles based cross-org auth approach (IAM roles per account to be assumed still needed. Also to centralize AWS CloudTrail and AWS Config logs, and used as the master AWS GuardDuty Account Network Intended for centralized networking management via Transit Gateway (TGW), supports a centralized outbound traffic setup and the integration of AWS Network Firewall (NFW) Legacy Your pre existing AWS Accounts to be invited as members of the new AWS Organization, probably several services and workloads are going to be progressively migrated to your new Accounts. Apps DevStg Host your DEV, QA and STG environment workloads Compute / Web App Servers (K8s Clusters and Lambda Functions), Load Balancers, DB Servers, Caching Services, Job queues &amp; Servers, Data, Storage, CDN Apps Prod Host your PROD environment workloads Compute / Web App Servers (K8s Clusters and Lambda Functions), Load Balancers, DB Servers, Caching Services, Job queues &amp; Servers, Data, Storage, CDN"},{"location":"user-guide/ref-architecture-aws/features/organization/billing/","title":"Billing","text":""},{"location":"user-guide/ref-architecture-aws/features/organization/billing/#overview","title":"Overview","text":"<p>Each month AWS charges your payer Root Account for all the linked accounts in a consolidated bill.  The following illustration shows an example of a consolidated bill.</p> <p></p> Figure: AWS Organization Multi-Account structure (just as reference). (Source: Andreas Wittig,   \"AWS Account Structure: Think twice before using AWS Organizations\", Cloudonaut.io Blog, accessed November 18th 2020).  <p></p> Figure: AWS Organization Multi-Account billing structure (just as reference). (Source: AWS,   \"Consolidated billing process\", AWS Documentation AWS Billing and Cost Management User Guide, accessed November 18th 2020).  <p>Reference Architecture AWS Organizations features</p> <ul> <li> AWS Multiple Account Billing Strategy: consolidated billing for all your accounts within organization, enhanced per account cost  filtering and RI usage </li> <li> A single monthly bill accumulates the spending among many AWS accounts.</li> <li> Benefit from volume pricing across more than one AWS account. </li> </ul> <p>AWS Organizations Billing FAQs</p> <ul> <li> <p> What does AWS Organizations cost?</p> <p>AWS Organizations is offered at no additional charge.</p> </li> <li> <p> Who pays for usage incurred by users under an AWS member account in my organization?</p> <p>The owner of the master account is responsible for paying for all usage, data, and resources used by the  accounts in the organization.</p> </li> <li> <p> Will my bill reflect the organizational unit structure that I created in my organization?</p> <p>No. For now, your bill will not reflect the structure that you have defined in your organization.  You can use cost allocation tags in individual AWS accounts to categorize and track your AWS costs, and this allocation will be visible in the consolidated bill for your organization.</p> </li> </ul> <p> Source | AWS Organizations FAQs</p>"},{"location":"user-guide/ref-architecture-aws/features/organization/billing/#read-more","title":"Read more","text":"<p>Reference links</p> <p>Consider the following extra links as reference:</p> <ul> <li> Cloudnout.io | AWS Account Structure</li> <li> AWS Ramp-Up Guide: Cost Management</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/organization/configuration/","title":"Configuration","text":""},{"location":"user-guide/ref-architecture-aws/features/organization/configuration/#user-guide","title":"User guide","text":""},{"location":"user-guide/ref-architecture-aws/features/organization/configuration/#pre-requisites","title":"Pre-requisites","text":"<p>You'll need an email to create and register your AWS Organization Management Account. For this purpose we recommend to avoid using a personal email account.  Instead, whenever possible, it should ideally be associated, with a distribution list email such as a  GSuite Group to ensure the proper admins member's team  (DevOps | SecOps | Cloud Engineering Team) to manage its notifications avoiding a single point of contact (constraint).</p>"},{"location":"user-guide/ref-architecture-aws/features/organization/configuration/#email-setup-example","title":"Email setup example","text":"<p>GSuite Group Email address: <code>aws@domain.com</code> (to which admins / owners belong), and then using the <code>+</code> we generate the aliases automatically implicitly when running Terraform's Leverage code.</p> <ul> <li> <code>aws+security@binbash.com.ar</code></li> <li> <code>aws+shared@binbash.com.ar</code></li> <li> <code>aws+network@binbash.com.ar</code></li> <li> <code>aws+apps-devstg@binbash.com.ar</code></li> <li> <code>aws+apps-prd@binbash.com.ar</code></li> </ul> <p>Reference Code as example</p> <pre><code>#\n# Project Prd: services and resources related to production are placed and\n#  maintained here.\n#\nresource \"aws_organizations_account\" \"apps_prd\" {\nname      = \"apps-prd\"\nemail     = \"aws+apps-prd@domain.ar\"\nparent_id = aws_organizations_organizational_unit.apps_prd.id\n}\n</code></pre>"},{"location":"user-guide/ref-architecture-aws/features/organization/configuration/#reference-aws-organization-init-workflow","title":"Reference AWS Organization init workflow","text":"<p>Steps for initial AWS Organization setup</p> <ol> <li> <p>Create a brand new AWS Account,  intended to be our AWS Organization Management (root) Account</p> <ul> <li> Name: <code>project_name-management</code>, eg: <code>leverage-management</code></li> <li> MFA: Enable MFA for your root user</li> <li> Billing: review billing setup as pre-requisite to deploy the AWS Org.    At your Management account billing setup    check<ul> <li>Activate IAM User and Role Access to Billing Information</li> <li>If needed Update Alternate Contacts </li> </ul> </li> </ul> </li> <li> <p>Via AWS Web Console: in <code>project_name-management</code> previously created account (eg, name: <code>leverage-management</code>, email: <code>aws@binbash.com.ar</code>) create the <code>mgmt-org-admin</code> IAM user with Admin privileges (attach the <code>AdministratorAccess</code> IAM managed policy and enable Web Console and programmatic access), which will be use for the initial AWS Org bootstrapping.</p> <ul> <li> NOTE: After it\u2019s 1<sup>st</sup> execution only nominated Org admin users will persist in the <code>project-management</code> account.</li> </ul> </li> <li> <p>Via AWS Web Console: in <code>project-management</code> account create <code>mgmt-org-admin</code> IAM user AWS ACCESS KEYS</p> <ul> <li> NOTE: This could be created all in one in the previous step (N\u00ba 2).</li> </ul> <p> Figure: AWS Web Console screenshot. (Source: binbash, \"AWs Organization management account init IAM admin user\", accessed June 16<sup>th</sup> 2021). </p> <p> Figure: AWS Web Console screenshot. (Source: binbash, \"AWs Organization management account init IAM admin user\", accessed June 16<sup>th</sup> 2021). </p> </li> <li> <p>Set your IAM credentials in the machine your're going to exec the <code>Leverage CLI</code> (remember this are the <code>mgmt-org-admin</code> temporary user credentials shown in the screenshot immediately above).</p> </li> <li> <p>Set up your Leverage reference architecture configs in order to work with your new account and  `org-mgmt-admin IAM user</p> <ul> <li>common config</li> <li>account configs</li> </ul> </li> <li> <p>Setup and create the terraform remote state for the new AWS Org Management account</p> <ul> <li> terraform remote state config </li> <li> terraform remote state workflow</li> <li> terraform remote state ref code</li> <li> You'll 1<sup>st</sup> get a local state and then you'll need to move your tf state to s3; validate it and finally delete local state files</li> </ul> </li> <li> <p>The AWS Organization from the Reference Architecture /le-tf-infra-aws/root/global/organizations will be orchestrated using the <code>Leverage CLI</code> following the standard workflow.</p> <ul> <li> the Management account has to be imported into de the code.</li> </ul> </li> <li> <p>Verify your Management account email address in order to invite existing (legacy) AWS accounts to  join your organization.</p> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/organization/configuration/#organization-setup-post-steps","title":"Organization setup post-steps","text":"<p>AWS Organization setup post-steps</p> <ol> <li> <p>Following the doc orchestrate v\u00eda the <code>Leverage CLI</code> workflow the Mgmt Account IAM layer (<code>base-identities</code>) with the admin IAM Users (consider this/these users will have admin privileges over the entire AWS Org assuming the <code>OrganizationAccountAccessRole</code>) -&gt; le-tf-infra-aws/root/global/base-identities</p> <ul> <li> The IAM role: <code>OrganizationAccessAccountRole</code> =&gt; does not exist in the initial Management (root) account, this will be created by the code in this layer.</li> </ul> </li> <li> <p>Mgmt account admin user permanent credentials set up =&gt;  setup in your workstation the AWS credentials) for the <code>OrganizationAccountAccessRole</code> IAM role (<code>project_short-root-oaar</code>, eg: <code>bb-root-oaar</code>). Then validate within each initial mgmt account layer that the profile <code>bb-root-oaar</code> is correctly configured  at the below presented config files, as well as any other necessary setup.</p> <ul> <li><code>/config/common.config</code> </li> <li><code>/root/config/account.config</code></li> <li><code>/root/config/backend.config</code></li> </ul> </li> <li> <p>Setup (code and config files) and Orchestrate the <code>/security/global/base-identities</code> layer via <code>Leverage CLI</code> on your security account for consolidated and centralized User Mgmt and access to the AWS Org.    </p> </li> <li> <p>AWS Organizations: invite pre-existing (legacy) accounts</p> </li> <li> <p> Pending to document the debug mode for the mfa script</p> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/organization/legacy-accounts/","title":"Managing legacy (pre-existing) accounts","text":"<p>How it works</p> <p> documentation: organization</p> <p> documentation: organization accounts</p>"},{"location":"user-guide/ref-architecture-aws/features/organization/legacy-accounts/#user-guide","title":"User guide","text":""},{"location":"user-guide/ref-architecture-aws/features/organization/legacy-accounts/#pre-requisites","title":"Pre-requisites","text":"<p>You must have your AWS Organization deployed and access to your Management account as  described in the /user-guide/user-guide/organization/organization-init section.</p>"},{"location":"user-guide/ref-architecture-aws/features/organization/legacy-accounts/#invite-aws-pre-existing-legacy-accounts-to-your-aws-organization","title":"Invite AWS pre-existing (legacy) accounts to your AWS Organization","text":"<p>AWS Org pre-existing accounts invitation</p> <ol> <li> <p>Via AWS Web Console: from your <code>project-root</code> account  invite the  pre-existing <code>project-legacy</code> (1 to n accounts).</p> </li> <li> <p>Via AWS Web Console: in <code>project-legacy</code> create the <code>OrganizationAccountAccessRole</code> IAM Role with Admin  permissions.</p> <ul> <li> Should follow Creating the OrganizationAccountAccessRole in an invited member account section.</li> </ul> </li> <li> <p>Import your <code>project-legacy</code> account as code.</p> <ul> <li>Update the following variables in <code>./@bin/makefiles/terraform12/Makefile.terraform12-import-rm</code> <pre><code>TF_IMPORT_RESOURCE                := \"aws_organizations_organizational_unit.bbl_apps_devstg\"\nTF_IMPORT_RESOURCE_ID             := \"ou-oz9d-yl3npduj\"\nTF_RM_RESOURCE                    := \"aws_organizations_organizational_unit.bbl_apps_devstg\"\n</code></pre></li> <li>Then from the root context -&gt; <code>cd ./root/organization make import</code></li> <li> TODO THIS STEP MUST BE UPDATED WITH THE <code>Leverage CLI</code> WORKFLOW</li> </ul> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/organization/overview/","title":"AWS Organizations","text":""},{"location":"user-guide/ref-architecture-aws/features/organization/overview/#overview","title":"Overview","text":"<p>This repository contains all Terraform configuration files used to create binbash Leverage Reference  AWS Organizations Multi-Account baseline layout.</p> <p>Why AWS Organizations?</p> <p>This approach allows it to have a hierarchical structure of AWS accounts, providing additional security isolation and the ability to separate resources into Organizational Units with it associated Service Control Policies (SCP). </p> <p>Considering that a current AWS account/s was/were  already active (Client AWS Legacy Account), this one will then be invited to be a \u201cmember  account\u201d of the AWS Organization architecture. In the future, once all Client\u2019s Legacy dev,  stage, prod and other resources for the Project applications are running in the new accounts  architecture, meaning a full AWS Organizations approach, all the already migrated assets from  the \u2018Legacy\u2019 account should be decommissioned. This account will remain with the necessary  services, such as DNS, among others. </p>"},{"location":"user-guide/ref-architecture-aws/features/organization/overview/#aws-organization-accounts-layout","title":"AWS Organization Accounts Layout","text":"<p>The following block provides a brief explanation of the chosen AWS Organization Accounts layout:</p> MyExample project file structure <pre><code>    +\ud83d\udcc2 management/      (resources for the management account)\n    ...\n    +\ud83d\udcc2 security/        (resources for the security + users account)\n    ...\n    +\ud83d\udcc2 shared/          (resources for the shared account)\n    ...\n    +\ud83d\udcc2 network/         (resources for the centralized network account)\n    ...\n    +\ud83d\udcc2 apps-devstg/     (resources for apps dev &amp; stg account)\n    ...\n    +\ud83d\udcc2 apps-prd/        (resources for apps prod account)\n    ...\n</code></pre> <p></p> Figure: AWS Organization multi-account architecture diagram (just as reference). (Source: binbash Leverage, \"Leverage Reference Architecture components\", binbash Leverage Doc, accessed August 4th 2021).  <p>Benefits of AWS Organizations</p> <ul> <li> Billing: Consolidated billing for all your accounts within organization, enhanced per account cost  filtering and RI usage </li> <li> Security I: Extra security layer: You get fully isolated infrastructure for different organizations  units in your projects, eg: Dev, Prod, Shared Resources, Security, Users, BI, etc.</li> <li> Security II: Using AWS Organization you may use Service Control Policies (SCPs) to control which  AWS services are available within different accounts.</li> <li> Networking: Connectivity and access will be securely setup via VPC peering + NACLS + Sec Groups  everything with private endpoints only accessible v\u00eda Pritunl VPN significantly reducing the surface of attack.</li> <li> User Mgmt: You can manage all your IAM resources (users/groups/roles) and policies in one  place (usually, security/users account) and use AssumeRole to works with org accounts.</li> <li> Operations: Will reduce the blast radius to the maximum possible.   </li> <li> Compatibility: Legacy accounts can (probably should) be invited       as a member of the new Organization       and afterwards even imported into your terraform code.</li> <li> Migration: After having your baseline AWS Org reference cloud solutions architecture deployed     (IAM, VPC, NACLS, VPC-Peering, DNS Cross-Org,     CloudTrail, etc) you're ready to start progressively orchestrating new resources in order to segregate different     Environment and Services per account.     This approach will allow you to start a 1 by 1 Blue/Green (Red/Black) migration without affecting any of your      services at all. You would like to take advantage of an Active-Active DNS switchover approach (nice as DR exercise too). <ul> <li> EXAMPLE: Jenkins CI Server Migration steps:<ol> <li>Let's say you have your EC2_A (<code>jenkins.aws.domain.com</code>) in Account_A (Legacy), so you could deploy a      brand new EC2_B Jenkins Instance in Account_B (Shared Resources).</li> <li>Temporally associated with <code>jenkins2.aws.domain.com</code></li> <li>Sync it's current data (<code>/var/lib/jenkins</code>)</li> <li>Test and fully validate every job and pipeline works as expected.</li> <li>In case you haven't finished your validations we highly recommend to declare everything as code and      fully automated so as to destroy and re-create your under development env on demand to save costs.</li> <li>Finally switch <code>jenkins2.aws.domain.com</code> -&gt; to -&gt; <code>jenkins.aws.domain.com</code></li> <li>Stop your old EC2_A.</li> <li>If everything looks fine after after 2/4 weeks you could terminate your EC2_A (hope everything is as      code and just <code>terraform destroy</code>)</li> <li>Considering the previously detailed steps plan your roadmap to move forward with every other component     to be migrated.</li> </ol> </li> </ul> </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/organization/overview/#read-more","title":"Read more","text":"<p>AWS reference links</p> <p>Consider the following AWS official links as reference:</p> <ul> <li> Why should I set up a multi-account AWS environment? </li> <li> AWS Multiple Account User Management Strategy</li> <li> AWS Muttiple Account Security Strategy</li> <li> AWS Multiple Account Billing Strategy</li> <li> AWS Secure Account Setup</li> <li> Authentication and Access Control for AWS Organizations (keep in mind EC2 and other services can also use AWS IAM Roles to get secure cross-account access)</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/reliability/backups/","title":"Backups","text":""},{"location":"user-guide/ref-architecture-aws/features/reliability/backups/#aws-backup","title":"AWS Backup","text":"<p>As defined by AWS</p> <p>AWS Backup is a fully managed backup service that makes it easy to centralize and automate the backup of data across AWS services. Using AWS Backup, you can centrally configure backup policies and monitor backup activity for AWS resources, such as:</p> <ul> <li> Amazon EBS volumes, </li> <li> Amazon EC2 instances, </li> <li> Amazon RDS databases, </li> <li> Amazon DynamoDB tables, </li> <li> Amazon EFS file systems,</li> <li> and AWS Storage Gateway volumes. </li> </ul> <p>AWS Backup automates and consolidates backup tasks previously performed service-by-service, removing the need to  create custom scripts and manual processes.  With just a few clicks in the AWS Backup console, you can create backup policies that automate backup schedules and retention management. AWS Backup provides a fully managed, policy-based backup solution, simplifying your backup management, enabling you to meet your business and regulatory backup compliance requirements.</p> <p></p> Figure: AWS Backup service diagram (just as reference). (Source: AWS,  \"AWS Backup - Centrally manage and automate backups across AWS services\", AWS Documentation, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-aws/features/reliability/backups/#s3-bucket-region-replication","title":"S3 bucket region replication","text":"<ul> <li> Buckets that hold data critical to business or to application operation can be replicated to another region almost  synchronously. </li> <li> This can be setup on request to increase durability and along with database backup can constitute the base for a  Business Continuity strategy.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/reliability/backups/#comparison-of-the-backup-and-retention-policies-strategies","title":"Comparison of the backup and retention policies strategies","text":"<p>In this sub-section you'll find the resources to review and adjust your backup retention policies to  adhere to compliance rules that govern your specific institutions regulations. This post is a summarised write-up of how we approached this sensitive task, the alternatives we analysed and the recommended  solutions we provided in order to meet the requirements. We hope it can be useful for others as well.</p> <p>Leverage Confluence Documentation</p> <p>You'll find here a detailed comparison including the alternative product and solution types, pricing model, features, pros &amp; cons.</p>"},{"location":"user-guide/ref-architecture-aws/features/reliability/dr/","title":"Disaster Recovery &amp; Business Continuity Plan","text":""},{"location":"user-guide/ref-architecture-aws/features/reliability/dr/#overview","title":"Overview","text":"<p>Applications that are business critical should always have a plan in place to recover in case of a catastrophic failure or disaster. There are many strategies that can be implemented to achieve this, and deciding between them is a matter of analyzing how much is worth to invest based on calculation of damages suffered if the application is not available for a given period of time. It is based on this factor (time) that disaster recovery plans are based on. Factors that need to be determined per application are:</p> <p>RTO and RPO</p> <ul> <li> Recovery time objective (RTO): This represents the time it takes after a disruption to restore a business process to its service level. For example, if a disaster occurs at 12:00 PM (noon) and the RTO is eight hours, the DR process should restore the business process to the acceptable service level by 8:00 PM. </li> <li> Recovery point objective (RPO): This is the acceptable amount of data loss measured in time. For example, if a  disaster occurs at 12:00 PM (noon) and the RPO is one hour, the system should recover all data that was in the   system before that hour.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/reliability/dr/#high-availability-configuration-strategies","title":"High Availability Configuration Strategies","text":"<p>After deciding RTO and RPO we have options available to achieve the time objectives:</p> <p>HA Strategies</p> <ul> <li> Backup and restore: In most traditional environments, data is backed up to tape and sent off-site regularly.  The equivalent in AWS would be to take backups in the form of snapshots and copy them to another region for RDS  instances, EBS volumes, EFS and S3 buckets. The plan details the step-by-step procedure to recover a fully working  production environment based on these backups being restored on freshly provisioned infrastructure, and how to  rollback to a regular production site once the emergency is over.</li> <li> Pilot Light Method: The term pilot light is often used to describe a DR scenario in which a minimal version of  an environment is always running in AWS. Very similar to \u201cBackup and restore\u201d except a minimal version of key  infrastructure components is provisioned in a separate region and then scaled up in case of disaster declaration.</li> <li> Warm standby active-passive method: The term warm-standby is used to describe a DR scenario in which a  scaled-down version of a fully-functional environment is always running in the cloud. Enhancement of Pilot Light  in which a minimal version is created of all components, not just critical ones.</li> <li> Multi-Region active-active method: By architecting multi region applications and using DNS to balance  between them in normal production status, you can adjust the DNS weighting and send all traffic to the AWS region  that is available, this can even be performed automatically with Route53 or other DNS services that provide health  check mechanisms as well as load balancing.</li> </ul> <p></p> Figure: 2 sets of app instances, each behind an elastic load balancer in two separate regions (just as reference). (Source: Randika Rathugamage,   \"High Availability with Route53 DNS Failover\", Medium blogpost, accessed December 1st 2020).  <p></p> Figure: AWS calculated \u2014 or parent \u2014 health check, we can fail on any number of child health checks (just as reference). (Source: Simon Tabor,   \"How to implement the perfect failover strategy using Amazon Route53\", Medium blogpost, accessed December 1st 2020)."},{"location":"user-guide/ref-architecture-aws/features/reliability/dr/#read-more","title":"Read more","text":"<p>AWS reference links</p> <p>Consider the following AWS official links as reference:</p> <ul> <li> AWS Documentation Amazon Route 53 Developer Guide | Configuring DNS failover</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/reliability/high-availability/","title":"High Availability &amp; Helthchecks","text":""},{"location":"user-guide/ref-architecture-aws/features/reliability/high-availability/#recovery-from-failures","title":"Recovery from Failures","text":"<p>Automatic recovery from failure</p> <p>It keeps an AWS environment reliable. Using logs and metrics from CloudWatch, designing a system where the failures themselves trigger recovery is the way to move forward.</p> <p></p> Figure: AWS HA architecture diagrams (just as reference)."},{"location":"user-guide/ref-architecture-aws/features/reliability/high-availability/#recovery-procedures","title":"Recovery Procedures","text":"<p>Test recovery procedures</p> <p>The risks faced by cloud environment and systems, the points of failure for systems and ecosystems, as well as details about the most probable attacks are known and can be simulated. Testing recovery procedures are something that can be done using these insights. Real points of failure are exploited and the way the environment reacts to the emergency shows just how reliable the system it.</p> <p></p> Figure: AWS HA architecture diagrams (just as reference)."},{"location":"user-guide/ref-architecture-aws/features/reliability/high-availability/#scalability-and-availability","title":"Scalability and Availability","text":"<p>Scale horizontally to increase aggregate system availability</p> <p>The cloud environment needs to have multiple redundancies and additional modules as added security measures. Of course, multiple redundancies require good management and maintenance for them to remain active through the environment\u2019s lifecycle.</p> <p></p> Figure: AWS HA scalable architecture diagrams (just as reference)."},{"location":"user-guide/ref-architecture-aws/features/reliability/high-availability/#healthchecks-self-healing","title":"Healthchecks &amp; Self-healing","text":""},{"location":"user-guide/ref-architecture-aws/features/reliability/high-availability/#k8s-and-containers","title":"K8s and containers","text":"<p>K8s readiness and liveness probes</p> <p>Distributed systems can be hard to manage. A big reason is that there are many moving parts that all need to work for the system to function. If a small part breaks, the system has to detect it, route around it, and fix it.  And this all needs to be done automatically! Health checks are a simple way to let the system know if an instance of your app is working or not working. </p> <p>If an instance of your app is not working, then other services should not access it or send a request to it.  Instead, requests should be sent to another instance of the app that is ready, or re-tried at a later time. The  system should also bring your app back to a healthy state.</p> <p>By default, Kubernetes starts to send traffic to a pod when all the containers inside the pod start, and restarts containers when they crash. While this can be \u201cgood enough\u201d when you are starting out, you can make your deployments more robust by creating custom health checks. Fortunately, Kubernetes make this relatively straightforward, so there is no excuse not to!\u201d    </p> <p>So aside from the monitoring and alerting that underlying infrastructure will have, application container will have   their own mechanisms to determine readiness and liveness. These are features that our scheduler of choice Kubernetes  natively allows, to read more click here.</p>"},{"location":"user-guide/ref-architecture-aws/features/secrets/secrets/","title":"Secrets and Passwords Management","text":""},{"location":"user-guide/ref-architecture-aws/features/secrets/secrets/#overview","title":"Overview","text":"<p>Ensure scalability, availability and persistence, as well as secure, hierarchical storage to manage configuration and secret data for:</p> <p>Secret Managers</p> <ul> <li> AWS KMS</li> <li> AWS SSM Parameter Store</li> <li> Ansible Vault</li> <li> Hashicorp Vault</li> </ul> <p>Strengths</p> <ul> <li> Improve the level of security by validating separation of environment variables and code secrets.</li> <li> Control and audit granular access in detail</li> <li> Store secure chain and configuration data in hierarchies and track versions.</li> <li> Configure integration with AWS KMS, Amazon SNS, Amazon CloudWatch, and AWS CloudTrail to notify, monitor, and audit functionality.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/secrets/secrets/#read-more","title":"Read more","text":"<p>Related articles</p> <ul> <li> A Comparison of Secrets Managers for AWS</li> <li> Clean Up Your Secrets &amp; Credential Management</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/security/audit-cloudtrail/","title":"Audit | CloudTrail","text":""},{"location":"user-guide/ref-architecture-aws/features/security/audit-cloudtrail/#overview","title":"Overview","text":"<p>AWS CloudTrail monitors and records account activity across your AWS infrastructure,  giving you control over storage, analysis, and remediation actions.</p> <p>AWS CloudTrail overview</p> <p>This service will be configured to enable auditing of all AWS services in all accounts. Once enabled, as shown in the below presented figure, CloudTrail will deliver all events  from all accounts to the Security account in order to have a centralized way to audit  operations on AWS resources. Audit events will be available from CloudTrail for 90 days but a longer retention  time will be available through a centralized S3 bucket.</p> <p> Figure: AWS CloudTrail components architecture diagram (just as reference).     (Source: binbash Leverage diagrams, accessed July 6<sup>th</sup> 2022).     </p> <p> IaC Terraform Codebase &lt;&gt;</p> <ul> <li> <code>binbash-management</code> account | Audit: Cloudtrail<ul> <li>Code: management/us-east-1/security-audit</li> </ul> </li> <li> <code>binbash-security</code> account | Audit: Cloudtrail &amp; S3 Bucket<ul> <li>Code: security/us-east-1/security-audit</li> </ul> </li> <li> <code>binbash-shared</code> account | Audit: Cloudtrail<ul> <li>Code: shared/us-east-1/security-audit</li> </ul> </li> <li> <code>binbash-apps-devstg</code> account | Audit: Cloudtrail<ul> <li>Code: apps-devstg/us-east-1/security-audit</li> </ul> </li> <li> <code>binbash-apps-prd</code> account | Audit: Cloudtrail<ul> <li>Code: apps-prd/us-east-1/security-audit</li> </ul> </li> <li> <code>binbash-network</code> account | Audit: Cloudtrail<ul> <li>Code: network/us-east-1/security-audit</li> </ul> </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/security/audit-cloudtrail/#read-more","title":"Read more","text":"<p>AWS reference links</p> <p>Consider the following AWS official links as reference:</p> <ul> <li> AWS Cloudtrail Overview</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/security/certificates/","title":"Certificate Management","text":""},{"location":"user-guide/ref-architecture-aws/features/security/certificates/#aws-certificate-manager","title":"AWS Certificate Manager","text":"<p>Why AWS Certificate Manager (ACM)\u2753</p> <p>As stated at the official AWS website</p> <p>\"AWS Certificate Manager is a service that lets you easily provision, manage, and deploy public and  private Secure Sockets Layer/Transport Layer Security (SSL/TLS) certificates for use with AWS services and your internal connected resources. SSL/TLS certificates are used to secure network communications and establish the identity of websites over the Internet as well as resources on private networks.  AWS Certificate Manager removes the time-consuming manual process of purchasing, uploading, and renewing SSL/TLS certificates.\"</p> <p>\"With AWS Certificate Manager, you can quickly request a certificate, deploy it on  ACM-integrated AWS resources,  such as:</p> <ul> <li>Elastic Load Balancers, </li> <li>Amazon CloudFront distributions, </li> <li>and APIs on API Gateway,</li> </ul> <p>and let AWS Certificate Manager handle certificate renewals. It also enables you to create private  certificates for your internal resources and manage the certificate lifecycle centrally.  Public and private certificates provisioned through AWS Certificate Manager for use with ACM-integrated services are free. You pay only for the AWS resources you create to run your application.  With AWS Certificate Manager Private Certificate Authority, you pay monthly for the operation of the private CA and for the private certificates you issue.\"</p> <p></p> Figure: AWS certificate manager (ACM) service integration diagram. (Source: AWS,   \"Amazon Certificate Manager intro diagram\", AWS Documentation Amazon ACM User Guide, accessed August 4th 2021)."},{"location":"user-guide/ref-architecture-aws/features/security/certificates/#cert-manager-lets-encrypt","title":"Cert-manager + Let's Encrypt","text":"<p>Why Cert-manager + Let's Encrypt\u2753</p> <ul> <li> <p> cert-manager adds certificates and certificate issuers as resource types in Kubernetes clusters, and  simplifies the process of obtaining, renewing and using those certificates.</p> </li> <li> <p> It can issue certificates from a variety of supported sources, including Let\u2019s Encrypt, HashiCorp Vault, and Venafi as well as private PKI.</p> </li> <li> <p> It will ensure certificates are valid and up to date, and attempt to renew certificates at a configured time before expiry.</p> </li> <li> <p> It is loosely based upon the work of kube-lego and has borrowed some wisdom from other similar projects such as kube-cert-manager.</p> </li> </ul> <p></p> Figure: Certificate manager high level components architecture diagram. (Source: Cert-manager official documentation,   \"Cert-manager manager intro overview\", Cert-manager Documentation main intro section, accessed August 4th 2021)."},{"location":"user-guide/ref-architecture-aws/features/security/firewall-manager/","title":"Firewall Manager","text":""},{"location":"user-guide/ref-architecture-aws/features/security/firewall-manager/#use-cases","title":"Use Cases","text":"<ul> <li> Network Firewall rules: Security administrators will be able to deploy firewall rules for AWS Network Firewall to control traffic leaving and entering your network across accounts and Amazon VPCs, from the Security account.</li> <li> WAF &amp; WAF v2: Your security administrators will able to deploy WAF and WAF v2 rules, and Managed rules for WAF to be used on Application Load Balancers, API Gateways and Amazon CloudFront distributions.</li> <li> Route 53 Resolver DNS Firewall rules: Deploy Route 53 Resolver DNS Firewall rules from the Security account to enforce firewall rules across your organization.</li> <li> Audit Security Groups: You can create policies to set guardrails that define what security groups are allowed/disallowed across your VPCs. AWS Firewall Manager continuously monitors security groups to detect overly permissive rules, and helps improve firewall posture. You can get notifications of accounts and resources that are non-compliant or allow AWS Firewall Manager to take action directly through auto-remediation.</li> <li> Security Groups: Use AWS Firewall Manager to create a common primary security group across your EC2 instances in your VPCs.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/security/firewall-manager/#read-more","title":"Read More","text":"<ul> <li> AWS Firewall Manager</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/security/iam-access-analyzer/","title":"IAM Access Analyzer","text":""},{"location":"user-guide/ref-architecture-aws/features/security/iam-access-analyzer/#overview","title":"Overview","text":"<p>Access Analyzer analyzes the resource-based policies that are applied to AWS resources in the  Region where you enabled Access Analyzer. Only resource-based policies are analyzed. </p> <p>Supported resource types:</p> <ul> <li> Amazon Simple Storage Service buckets</li> <li> AWS Identity and Access Management roles</li> <li> AWS Key Management Service keys</li> <li> AWS Lambda functions and layers</li> <li> Amazon Simple Queue Service queues</li> <li> AWS Secrets Manager secrets</li> </ul> <p></p> Figure: AWS IAM access analysis features. (Source: AWS,   \"How it works - monitoring external access to resources\", AWS Documentation, accessed June 11th 2021)."},{"location":"user-guide/ref-architecture-aws/features/security/iam-access-analyzer/#aws-organizations","title":"AWS Organizations","text":"<p>CONSIDERATION: AWS Organization integration</p> <p>In order to enable AccessAnalyzer with the Organization at the zone of of trust in the Security account, this account needs to be set as a delegated administrator. </p> <p>Such step cannot be performed by Terraform yet so it was set up manually as described below: https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-settings.html</p> <p>If you're configuring AWS IAM Access Analyzer in your AWS Organizations management account,  you can add a member account in the organization as the delegated administrator to manage  Access Analyzer for your organization. The delegated administrator has permissions to create  and manage analyzers with the organization as the zone of trust. Only the management account  can add a delegated administrator.</p>"},{"location":"user-guide/ref-architecture-aws/features/security/iam-access-analyzer/#reference-architecture-implementation-code","title":"Reference Architecture implementation code","text":"<p>Reference Architecture Code: le-tf-infra-aws/security/security-base/iam_access_analizer.tf</p> <p> <pre><code>resource \"aws_accessanalyzer_analyzer\" \"default\" {\n    analyzer_name = \"ConsoleAnalyzer-bc3bc4d6-09cb-XXXX-XXXX-XXXXXXXXXX\"\n    type          = \"ORGANIZATION\"\n    tags          = local.tags\n}\n</code></pre></p>"},{"location":"user-guide/ref-architecture-aws/features/security/iam-access-analyzer/#aws-web-console","title":"AWS Web Console","text":"Figure: AWS Web Console screenshot. (Source: binbash, \"IAM access analyzer service\", accessed June 11th 2021)."},{"location":"user-guide/ref-architecture-aws/features/security/overview/","title":"Security","text":""},{"location":"user-guide/ref-architecture-aws/features/security/overview/#supported-aws-security-services","title":"Supported AWS Security Services","text":"<ul> <li> AWS IAM Access Analyzer: Generates comprehensive findings that identify resources policies for public or      cross-account accessibility, monitors and helps you refine permissions. Provides the highest levels of security assurance.</li> <li> AWS Config: Tracks changes made to AWS resources over time, making possible to return to a previous state.         Monitors and records your AWS resource configurations and allows you to automate the evaluation of recorded         configurations against desired compliance rule set. Adds accountability factor.</li> <li> AWS Cloudtrail: Stores logs over all calls made to AWS APIs, coming from web console, command line or any         other. Allowing us to monitor it via CW Dashboards and notifications.</li> <li> AWS VPC Flow Logs: Enables us to examine individual Network Interfaces logs, to address network issues and         also monitor suspicious behavior.</li> <li> AWS Web Application Firewall: Optional but if not used, it is recommended that a similar service is used,         such as Cloudflare. When paired to an Application Load Balancer or Cloudfront distribution, it checks incoming         requests to detect and block OWASP Top10 attacks, such as SQL injection, XSS and others. </li> <li> AWS Inspector:  Is an automated security assessment service that helps improve the security and compliance         of infrastructure and applications deployed on AWS. </li> <li> AWS GuardDuty: Is a managed threat detection service that         continuously monitors for malicious or unauthorized behavior to help you protect your AWS accounts and         workloads. Detects unusual API calls or potentially unauthorized deployments (possible account compromise)         and potentially compromised instances or reconnaissance by attackers.</li> <li> AWS Security Logs Other access logs from client-facing resources will be stored in the Security account.</li> <li> AWS Firewall Manager Is a security management service which allows you to centrally configure and manage firewall rules across your accounts and applications in AWS Organizations. This service lets you build firewall rules, create security policies, and enforce them in a consistent, hierarchical manner across your entire infrastructure, from a central administrator account.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/security/vpn/","title":"VPN Server","text":""},{"location":"user-guide/ref-architecture-aws/features/security/vpn/#to-securely-and-scalable-privately-access-aws-cross-organization-resources-well-implement-pritunl-vpn-server","title":"To securely and scalable privately access AWS Cross Organization resources we\u2019ll implement Pritunl VPN Server","text":"<p>Security Directives</p> <ol> <li>Private HTTP endpoints for Applications (FrontEnd + APIs), SSH, monitoring &amp; logging (UI / Dashboards) among others. Eg: Jenkins, DroneCI, EFK, Prometheus, Spinnaker, Grafana.</li> <li>K8s API via kubectl private endpoint eg: avoiding emergency K8s API vulnerability patching. </li> <li> <p>Limit exposure: Limit the exposure of the workload to the internet and internal networks by only allowing minimum required access -&gt; Avoiding exposure for Dev/QA/Stg http endpoints</p> <ol> <li>The Pritunl OpenVPN Linux instance is hardened and only runs this VPN solution. All other ports/access is restricted.</li> <li>Each VPN user can be required to use MFA to connect via VPN (as well as strong passwords). This combination makes almost impossible for an outsider to gain access via VPN.</li> <li>Centralized access and audit logs.</li> </ol> </li> </ol> <p></p> Figure: Securing access to a private network with Pritunl diagram. (Source: Pritunl,   \"Accessing a Private Network\", Pritunl documentation v1 Guides, accessed November 17th 2020)."},{"location":"user-guide/ref-architecture-aws/features/security/vpn/#read-more","title":"Read More","text":"<ul> <li> Pritunl - Open Source Enterprise Distributed OpenVPN, IPsec and WireGuard Server Specifications </li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/sso/configuration/","title":"Configuration","text":""},{"location":"user-guide/ref-architecture-aws/features/sso/configuration/#authentication","title":"Authentication","text":"<p>Before deploying your AWS SSO definition in the project, it will first have to be manually enabled in the AWS Management Console.</p> <p> Prerequisites</p> <p> Enable AWS SSO</p> <p>After that, choosing and configuring an Identity Provider (IdP) is the next step. For this, we will make use of JumpCloud, as described in the how it works section. These resources point to all requirements and procedures to have your JumpCloud account setup and synched with AWS SSO:</p> <p> AWS JumpCloud support guide</p> <p> JumpCloud guide on how to configure as IdP for AWS SSO</p> <p>Once this is set up, the SSO layer can be safely deployed.</p>"},{"location":"user-guide/ref-architecture-aws/features/sso/configuration/#preparing-the-project-to-use-aws-sso","title":"Preparing the project to use AWS SSO","text":"<p>To implement SSO authentication in your IaC definition, some configuration values need to be present in your project.</p>"},{"location":"user-guide/ref-architecture-aws/features/sso/configuration/#global-configuration","title":"Global configuration","text":"<p>In the global configuration file, or <code>common.tfvars</code>, found in the root of the project, under the <code>config</code> directory</p> <pre><code>...\n\u251c\u2500\u2500 \ud83d\udcc2 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 common.tfvars\n...\n</code></pre> <p>Three values will govern the behavior of SSO: <pre><code># AWS SSO\nsso_enabled   = true\nsso_start_url = \"https://myexample.awsapps.com/start\"\nsso_region    = \"us-east-1\"\n</code></pre></p> <ul> <li><code>sso_enabled</code> determines whether leverage will attempt to use credentials obtained via SSO to authenticate against AWS</li> <li><code>sso_start_url</code> and <code>sso_region</code> are necessary to configure AWS CLI correctly in order to be able to get the credentials</li> </ul> <p>When configuring AWS CLI, a <code>default</code> profile is created containing region and output default settings. The region value is obtained from the previously mentioned <code>sso_region</code>, however, you can override this behavior by configuring a <code>region_primary</code> value in the same global configuration file, as so: <pre><code>region_primary = \"us-west-2\"\n</code></pre></p>"},{"location":"user-guide/ref-architecture-aws/features/sso/configuration/#account-configuration","title":"Account configuration","text":"<p>In every account configuration file, namely <code>account.tfvars</code>, found in the <code>config</code> directory under the account's folder</p> <pre><code>...\n\u251c\u2500\u2500 \ud83d\udcc2 account\n|   \u251c\u2500\u2500 \ud83d\udcc2 config\n|   \u2502\u00a0\u00a0 \u251c\u2500\u2500 \ud83d\udcc4 account.tfvars\n|   \u2502\u00a0\u00a0 \u2514\u2500\u2500 \ud83d\udcc4 backend.tfvars\n...\n</code></pre> <p>The role to be assumed via SSO is configured: <pre><code># SSO\nsso_role = \"DevOps\"\n</code></pre></p> <p>This is the role for which credentials will be obtained via SSO when operating in the current layer.</p>"},{"location":"user-guide/ref-architecture-aws/features/sso/configuration/#authentication-via-sso","title":"Authentication via SSO","text":""},{"location":"user-guide/ref-architecture-aws/features/sso/configuration/#1-configuring-aws-sso","title":"1. Configuring AWS SSO","text":"<p>Once the project has been set up to use SSO, the profiles that AWS CLI will use to authenticate against the service need to be created.</p> <p>To do this, simply run <code>leverage aws configure sso</code>.</p> <p>Attention</p> <p>This step simply writes over the credentials files for AWS CLI without asking for confirmation from the user. So it's recommended to backup/wipe old credentials before executing this step in order to avoid loss of credentials or conflicts with profiles having similar names to the ones generated by Leverage. </p>"},{"location":"user-guide/ref-architecture-aws/features/sso/configuration/#2-logging-in","title":"2. Logging in","text":"<p>This step is executed as part of the previous one. So if the user has just configured SSO, this step is not required.</p> <p>Having SSO configured, the user will proceed to log in.</p> <p>This is achieved by running <code>leverage aws sso login</code>.</p> <p>In this step, the user is prompted to manually authorize the log in process via a web console.</p> <p>When logging in, Leverage obtains a token from SSO. This token is later used to obtain the credentials needed for the layer the user is working on. This token has a relatively short life span to strike a balance between security and convenience for the user.</p>"},{"location":"user-guide/ref-architecture-aws/features/sso/configuration/#3-working-on-a-layer","title":"3. Working on a layer","text":"<p>When SSO is enabled in the project, Leverage will automatically figure out the required credentials for the current layer, and attempt to get them from AWS every time the user executes a command on it.</p> <p>These credentials are short lived (30 minutes) for security reasons, and will be refreshed automatically whenever they expire.</p>"},{"location":"user-guide/ref-architecture-aws/features/sso/configuration/#4-logging-out","title":"4. Logging out","text":"<p>When the user has finished working, running <code>leverage sso logout</code> wipes out all remaining valid credentials and voids the token obtained from logging in.</p>"},{"location":"user-guide/ref-architecture-aws/features/sso/managing-users/","title":"Managing users","text":""},{"location":"user-guide/ref-architecture-aws/features/sso/managing-users/#onboarding-users-and-groups","title":"Onboarding Users and Groups","text":""},{"location":"user-guide/ref-architecture-aws/features/sso/managing-users/#addremove-users","title":"Add/remove users","text":"<ol> <li>Open this file: <code>management/global/sso/locals.tf</code></li> <li>Locate the users map within the local variables definition</li> <li>Add an entry to the users map with all the required data, including the groups the user should belong to</li> <li>Apply your changes</li> <li>Additional steps are required when creating a new user:<ol> <li>The user's email needs to be verified. Find the steps for that in this section.</li> <li>After the user has verified his/her email he/she should be able to use the Forgot Password flow to generate its password. The steps for that can be found in this section.</li> </ol> </li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/sso/managing-users/#addremove-groups","title":"Add/remove groups","text":"<ol> <li>Open this file: <code>management/global/sso/locals.tf</code></li> <li>Find the groups variable within the local variables definition</li> <li>Add an entry to the groups variable with the group name and description</li> <li>Apply your changes</li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/sso/managing-users/#edit-usergroup-membership","title":"Edit user/group membership","text":"<ol> <li>Open this file: <code>devops-tf-infra/management/global/sso/locals.tf</code></li> <li>Find the users map within the local variables definition</li> <li>Update the groups attribute to add/remove groups that user belongs to</li> <li>Apply your changes</li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/sso/managing-users/#trigger-user-email-activation","title":"Trigger user email activation","text":"<ol> <li>Log in to management account through the AWS console</li> <li>Go to AWS IAM Identity Center</li> <li>Go to the users section</li> <li>Locate the user whose email you want to active</li> <li>Click on the user to view the user details</li> <li>There should be a \"Send verification email\" or \"Send email verification link\" button at the top. Click on it.</li> <li>Notify the user, confirm that he/she got the email and that he/she clicked on the activation link.</li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/sso/managing-users/#reset-a-user-password","title":"Reset a user password","text":"<p>Follow the steps in the official documentation</p>"},{"location":"user-guide/ref-architecture-aws/features/sso/overview/","title":"AWS SSO","text":"<p>Important</p> <p>Parts of this documentation are outdated. JumpCloud is no longer part of our reference architecture.</p>"},{"location":"user-guide/ref-architecture-aws/features/sso/overview/#single-sign-on-sso","title":"Single Sign-On (SSO)","text":"<p>JumpCloud will be configured as the Identity Provider (IdP) that we will integrate with AWS SSO in order to grant users access to AWS resources from a centralized service. Users will be able to log in to JumpCloud in order to access AWS accounts, using specific permission sets that will in turn determine what kind of actions they are allowed on AWS resources.</p> <p></p> Figure: AWS Organization with SSO + JumpCloud IdP diagram. (Source: binbash Leverage, \"Leverage Reference Architecture components\", binbash Leverage Doc, accessed January 4th 2022)."},{"location":"user-guide/ref-architecture-aws/features/sso/overview/#sso-strengths","title":"SSO Strengths","text":"<ul> <li> 100% cloud-based</li> <li> Secure directory services</li> <li> Unified device management</li> <li> SSO and user lifecycle management</li> <li> Secure app and server authentication with cloud LDAP</li> <li> Event logging, reporting, and monitoring</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/sso/overview/#sso-users","title":"SSO Users","text":"<p>Users will be defined in JumpCloud and used for deploying AWS resources with scoped permissions.</p>"},{"location":"user-guide/ref-architecture-aws/features/sso/overview/#sso-groups","title":"SSO Groups","text":"Account / Groups Administrators DevOps FinOps SecurityAuditors Management x x x x <p>Consideration<p>This definition could be fully customized based on the project specific needs</p> </p>"},{"location":"user-guide/ref-architecture-aws/features/sso/overview/#sso-permission-sets-w-account-associations","title":"SSO Permission Sets (w/ Account Associations)","text":"Account / Permission Sets Administrator DevOps FinOps SecurityAuditors Management x x Security x x x Shared x x x Network x x x Apps-DevStg x x x Apps-Prd x x x <p>Considerations</p> <ol> <li>Devops Engineers will assume this permission set through JumpCloud + AWS SSO.</li> <li>Developers could have their specific SSO Group + Permission Set policy association.</li> <li>This definition could be fully customized based on the project specific needs</li> </ol>"},{"location":"user-guide/ref-architecture-aws/features/storage/storage/","title":"Storage","text":""},{"location":"user-guide/ref-architecture-aws/features/storage/storage/#overview","title":"Overview","text":"<p>We will review all S3 buckets in the existing account to determine if it\u2019s necessary to copy over to the new account,  evaluate existing bucket policy and tightening permissions to be absolutely minimum required for users and applications. As for EBS volumes, our recommendation is to create all encrypted by default. Overhead created by this process is negligible. </p>"},{"location":"user-guide/ref-architecture-aws/features/storage/storage/#s3-buckets","title":"S3 buckets","text":"<p>Tech specs</p> <ul> <li> Encryption: Yes (by default)</li> <li> Object versioning: TBD per bucket</li> <li> Access logs enabled: TBD per bucket</li> <li> MFA delete: Yes on critical buckets</li> <li> Replication to another region: TBD per bucket</li> </ul> Storage class Designed for Durability (designed for) Availability (designed for) Availability Zones Min storage duration Min billable object size Other considerations S3 Standard Frequently accessed data 99.999999999% 99.99% &gt;= 3 None None None S3 Standard-IA Long-lived, infrequently accessed data 99.999999999% 99.9% &gt;= 3 30 days 128 KB Per GB retrieval fees apply. S3 Intelligent-Tiering Long-lived data with changing or unknown access patterns 99.999999999% 99.9% &gt;= 3 30 days None Monitoring and automation fees per object apply. No retrieval fees. S3 One Zone-IA Long-lived, infrequently accessed, non-critical data 99.999999999% 99.5% 1 30 days 128 KB Per GB retrieval fees apply. Not resilient to the loss of the Availability Zone. S3 Glacier Long-term data archiving with retrieval times ranging from minutes to hours 99.999999999% 99.99% (after you restore objects) &gt;= 3 90 days 40 KB Per GB retrieval fees apply. You must first restore archived objects before you can access them. For more information, see Restoring archived objects. S3 Glacier Deep Archive Archiving rarely accessed data with a default retrieval time of 12 hours 99.999999999% 99.99% (after you restore objects) &gt;= 3 180 days 40 KB Per GB retrieval fees apply. You must first restore archived objects before you can access them. For more information, see Restoring archived objects. RRS (Not recommended) Frequently accessed, non-critical data 99.99% 99.99% &gt;= 3 None None None"},{"location":"user-guide/ref-architecture-aws/features/storage/storage/#ebs-volumes","title":"EBS Volumes","text":"<p>Tech specs</p> <ul> <li> Backups: Periodic EBS snapshots with retention policy</li> <li> Encryption: Yes (by default)</li> <li> Type: SSD (gp2) by default, Throughput Optimized HDD (st1) for some database workloads, if needed.</li> </ul>"},{"location":"user-guide/ref-architecture-aws/features/storage/storage/#read-more","title":"Read more","text":"<p>Reference links</p> <p>Consider the following extra links as reference:</p> <ul> <li> Amazon S3 FAQs</li> <li> Amazon S3 storage classes - Developer Guide</li> <li> Amazon S3 Storage Classes</li> </ul>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/","title":"Upgrading EKS","text":""},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#brief","title":"Brief","text":"<p>This guideline includes considerations and steps that should be performed when upgrading a cluster to a newer version.</p>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#upgrade-plan-overview","title":"Upgrade Plan Overview","text":"<ol> <li>General considerations</li> <li>Preparation Steps<ol> <li>Understand what changed</li> <li>Plan a maintenance window for the upgrade</li> <li>Rehearse on a non-Production cluster first</li> <li>Ensure you have proper visibility on the cluster</li> </ol> </li> <li>Upgrade Steps<ol> <li>Upgrade Control Plane</li> <li>Upgrade Managed Node Groups</li> <li>Upgrade Cluster AutoScaler version</li> <li>Upgrade EKS Add-ons</li> </ol> </li> <li>Closing Steps<ol> <li>Migration Notes</li> </ol> </li> </ol>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#detailed-upgrade-plan","title":"Detailed Upgrade Plan","text":""},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#1-general-considerations","title":"1) General considerations","text":"<ul> <li>Ensure your sensitive workloads are deployed in a highly available manner to reduce downtime as much as possible</li> <li>Ensure Pod Disruption Budgets are set in your deployments to ensure your application pods are evicted in a controlled way (e.g. leave at least one pod active at all times)</li> <li>Ensure Liveness and Readiness probes are set so that Kubernetes can tell whether your application is healthy to start receiving traffic or needs a restart</li> <li>Plan the upgrade during off hours so that unexpected disruptions have even less impact on end-users</li> </ul>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#2-preparation-steps","title":"2) Preparation Steps","text":""},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#understand-what-changed","title":"Understand what changed","text":"<p>Here you need to get a good understanding of the things that changed between the current version and the version you want to upgrade to. For that, it is highly recommended to go to the AWS EKS official documentation as it is frequently being updated.</p> <p>Another documentation you should refer to is the Kubernetes official documentation, specially the Kubernetes API Migration Guide which explains in great detail what has been changed.</p> <p>For instance, typical changes include:</p> <ul> <li>Removed/deprecated Kubernetes APIs: this one may require that you also upgrade the resources used by your applications or even base components your applications rely on. E.g. cert-manager, external-dns, etc.</li> <li>You can use tools such as kubent to find deprecated API versions. That should list the resources that need to be upgraded however you may still need to figure out if it's an EKS base component or a cluster component installed via Terraform &amp; Helm.</li> <li>Base component updates: this is about changes to control plane components. components that run on the nodes. An example of that would be the deprecation and removal of Docker as a container runtime.</li> </ul>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#plan-a-maintenance-window-for-the-upgrade","title":"Plan a maintenance window for the upgrade","text":"<p>Keep in mind that, at the very least, you will be upgrading the control plane and the data plane; and in some cases you would also need to upgrade components and workloads. So, although Kubernetes has a great development team and automation; and even though we rely on EKS for which AWS performs additional checks and validations, we are still dealing with a complex, evolving piece of software, so planning for the upgrade is still a reasonable move.</p> <p>Upgrading the control plane should not affect the workloads but you should still bear in mind that the Kubernetes API may become unresponsive during the upgrade, so anything that talks to the Kubernetes API might experience delays or even timeouts.</p> <p>Now, upgrading the nodes is the more sensitive task and, while you can use a rolling-update strategy, that still doesn't provide any guarantees on achieving a zero down-time upgrade so, again, planning for some maintenance time is recommended.</p>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#rehearse-on-a-non-production-cluster-first","title":"Rehearse on a non-Production cluster first","text":"<p>Perform the upgrade on a non-Production to catch up and anticipate any issues before you upgrade the Production cluster. Also take notes and reflect any important updates on this document.</p>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#ensure-you-have-proper-visibility-on-the-cluster","title":"Ensure you have proper visibility on the cluster","text":"<p>Monitoring the upgrade is important so make sure you have monitoring tools in-place before attempting the upgrade. Such tools include the AWS console (via AWS EKS Monitoring section) and also tools like Prometheus/Grafana and ElasticSearch/Kibana. Make sure you are familiar with those before the upgrade.</p>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#3-upgrade-steps","title":"3) Upgrade Steps","text":""},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#1-upgrade-control-plane","title":"1) Upgrade Control Plane","text":"<p>This is simply about updating the <code>cluster_version</code> variable in the <code>variables.tf</code> file within the <code>cluster</code> layer of the cluster you want to upgrade and then applying that change. However, the current version of the Terraform EKS module, when modifying the cluster version input, it will show that it needs to upgrade the control plane and the nodes which may not follow the expected order (first cluster, then nodes). Another thing that could go wrong is Terraform ending up in an unfinished state due to the upgrade taking too long to complete (or, what happened to me, the cluster gets upgraded but somehow the launch template used for the nodes is deleted and thus the upgraded nodes cannot be spun up).</p> <p>The alternative to all of that is to perform the upgrade outside Terraform and, after it is complete, to update the <code>cluster_version</code> variable in <code>variables.tf</code> file. Then you can run a Terraform Plan to verify the output shows no changes. This should be the method that provides a good degree of control over the upgrade.</p> <p>Having said that, go ahead and proceed with the upgrade, either via the AWS console, the AWS CLI or the EKS CLI and watch the upgrade as it happens. As it was stated in a previous step, the Kubernetes API may evidence some down-time during this operation so make sure you prepare accordingly.</p>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#2-upgrade-managed-node-groups","title":"2) Upgrade Managed Node Groups","text":"<p>Once the control plane is upgraded you should be ready to upgrade the nodes. There are 2 strategies you could use here: rolling-upgrade or recreate. The former is recommended for causing the minimal disruption. Recreate could be used in an environment where down-time won't be an issue.</p> <p>As it was mentioned in the previous step, the recommendation is to trigger the upgrade outside Terraform so please proceed with that and monitor the operation as it happens (via AWS EKS console, via Kubectl, via Prometheus/Grafana).</p> <p>If you go with the AWS CLI, you can use the following command to get a list of the clusters available to your current AWS credentials: <pre><code>aws eks list-clusters --profile [AWS_PROFILE]\n</code></pre> Make a note of the cluster name as you will be using that in subsequent commands.</p> <p>Now use the following command to get a list of the node groups: <pre><code>aws eks list-nodegroups --cluster-name [CLUSTER_NAME] --profile [AWS_PROFILE]\n</code></pre></p> <p>After that you need to identify the appropriate release version for the upgrade. Use the official documentation to find that: https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html</p> <p>With that information you should be ready to trigger the update with the command below: <pre><code>aws eks update-nodegroup-version \\\n    --cluster-name [CLUSTER_NAME] \\\n    --nodegroup-name [NODE_GROUP_NAME] \\\n    --release-version [RELEASE_VERSION] \\\n    --force \\\n    --profile [AWS_PROFILE]\n</code></pre> The <code>--force</code> flag is generally useful to bypass pod eviction failures.</p> <p>Once you are done with the upgrade you can continue with the rest of the node groups.</p>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#3-upgrade-cluster-autoscaler-version","title":"3) Upgrade Cluster AutoScaler version","text":"<p>Modify scaling.tf per the official Kubernetes autoscaler chart and apply with Terraform. The version of the cluster autoscaler should at least match the cluster version you are moving to. A greater version of the autoscaler might work with earlier version of Kubernetes but the opposite most likely won't be the case.</p>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#4-upgrade-eks-base-components","title":"4) Upgrade EKS base components","text":"<p>Namely these components are:</p> <ul> <li>Kube-Proxy</li> <li>CoreDNS</li> <li>VPC CNI</li> </ul> <p>In recent versions EKS is able to manage these components as add-ons which makes their upgrades less involved and which can even be performed through a recent version of the Terraform EKS module. However, we are not currently using EKS Add-ons to manage the installation of these components, we are using the so called self-managed approach, so the upgrade needs to be applied manually.</p> <p>Generally speaking, the upgrade procedure could be summed up as follows:</p> <ol> <li>Determine current version</li> <li>Determine the appropriate version you need to upgrade to</li> <li>Upgrade each component and verify</li> </ol> <p>Now, the recommendation is to refer to the following guides which carefully describe the steps that need to be performed:</p> <ol> <li>Kube-proxy: check here</li> <li>CoreDNS: check here</li> <li>VPC CNI: check here</li> </ol> <p>IMPORTANT: be extremely careful when applying these updates, specially with the VPC CNI as the instructions are not easy to follow.</p>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#4-closing-steps","title":"4) Closing Steps","text":"<p>Make sure you notify the team about the upgrade result. Also, do not forget about committing/pushing all code changes to the repository and creating a PR for them.</p>"},{"location":"user-guide/ref-architecture-eks/cluster-upgrade/#migration-notes","title":"Migration Notes","text":"<p>If you found any information you consider it should be added to this document, you are welcome to reflect that here.</p> <p>Migration to v1.21</p> <p>VPC CNI: The latest available version was v1.11.4 but I was only able to upgrade to v1.9.3. I couldn't move further because v1.10.3 wasn't able to run as it keep throwing the following errors: <pre><code>{\"level\":\"info\",\"ts\":\"2022-10-07T15:42:01.802Z\",\"caller\":\"entrypoint.sh\",\"msg\":\"Retrying waiting for IPAM-D\"}\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x39 pc=0x560d2186d418]\n</code></pre></p> <p>Cluster Autoscaler: it is already at v1.23.0. The idea is that this should match with the Kubernetes version but since the version we have has been working well so far, we can keep it and it should cover us until we upgrade Kubernetes to a matching version.</p> <p>Managed Nodes failures due to PodEvictionFailure: this one happened twice during a Production cluster upgrade. It seemed to be related to Calico pods using tolerations that are not compatible with Kubernetes typical node upgrade procedure. In short, the pods tolerate the NoSchedule taint and thus refuse to be evicted from the nodes during a drain procedure. The workaround that worked was using a forced upgrade. That is esentially a flag that can be passed via Terraform (or via AWS CLI). A more permanent solution would involve figuring out a proper way to configure Calico pods without the problematic toleration; we just need to keep in mind that we are deploying Calico via the Tigera Operator.</p> <p>Migration to v1.22</p> <p>Control plane and managed nodes: no issues. Cluster Autoscaler: already at v1.23.0. Kube-proxy: no issues. Upgraded to v1.22.16-minimal-eksbuild.3. CodeDNS: no issues. Upgraded to v1.8.7-eksbuild.1. VPC CNI: no issues. Upgraded to latest version available, v1.12.1.</p> <p>Outstanding issue: Prometheus/Grafana instance became unresponsive right during the upgrade of the control plane. It was fully inaccessible. A stop and start was needed to bring it back up.</p> <p>Official AWS procedure</p> <p>A step-bystep instructions guide for upgrading an EKS cluster can be found at the following link: https://repost.aws/knowledge-center/eks-plan-upgrade-cluster</p>"},{"location":"user-guide/ref-architecture-eks/components/","title":"Components","text":""},{"location":"user-guide/ref-architecture-eks/components/#overview","title":"Overview","text":"Figure: K8S EKS reference architecture components diagram. (Source: binbash Leverage Confluence Doc,  \"Implementation Diagrams\", binbash Leverage Doc, accessed January 5th 2022)."},{"location":"user-guide/ref-architecture-eks/components/#components-list","title":"Components List","text":"Figure: K8S EKS reference architecture detailed components diagram. (Source: binbash Leverage Confluence Doc,   \"Implementation Diagrams\", binbash Leverage Doc, accessed January 5th 2022)."},{"location":"user-guide/ref-architecture-eks/credentials/","title":"Credentials","text":""},{"location":"user-guide/ref-architecture-eks/credentials/#overview","title":"Overview","text":"<p>Access to EKS is usually achieved via IAM roles. These could be either custom IAM roles that you define, or SSO roles that AWS takes care of creating and managing.</p>"},{"location":"user-guide/ref-architecture-eks/credentials/#configuration","title":"Configuration","text":"<p>Granting different kinds of access to IAM roles can be done as shown here where you can define classic IAM roles or SSO roles. Note however that, since the latter are managed by AWS SSO, they could change if they are recreated or reassigned.</p> <p>Now, even though granting access to roles is the preferred way, keep in mind that that is not the only way you can use. You can also grant access to specific users or to specific accounts.</p>"},{"location":"user-guide/ref-architecture-eks/overview/","title":"AWS EKS Reference Architecture","text":""},{"location":"user-guide/ref-architecture-eks/overview/#overview","title":"Overview","text":"<p>Amazon Elastic Kubernetes Services (EKS) is a managed service that makes it easy for you  to run Kubernetes on AWS without needing to install and operate your own Kubernetes control plane or worker nodes. </p> <p>Core Features</p> <ul> <li> Highly Secure: EKS automatically applies the latest security patches to your cluster control plane. </li> <li> Multiple Availability Zones: EKS auto-detects and replaces unhealthy control plane nodes and provides on-demand,  zero downtime upgrades and patching.</li> <li> Serverless Compute: EKS supports AWS Fargate to remove the need to provision and manage servers, improving  security through application isolation by design. </li> <li> Built with the Community: AWS actively works with the Kubernetes community, including making contributions to the  Kubernetes code base helping you take advantage of AWS services.</li> </ul> Figure: AWS K8s EKS architecture diagram (just as reference). (Source: Jay McConnell,   \"A tale from the trenches: The CloudBees Core on AWS Quick Start\", AWS Infrastructure &amp; Automation Blog post, accessed November 18th 2020)."},{"location":"user-guide/ref-architecture-eks/overview/#version-support","title":"Version Support","text":"<p>At Leverage we support the last 3 latest stable  Kubernetes version releases (at best effort) within our Reference Architecture EKS layer  and IaC Library EKS module</p> <p>We think this is a good balance between management overhead and an acceptable level of  supported versions (at best effort). If your project have and older legacy version we could work along your CloudOps team to safely migrate it to a Leverage supported EKS version.</p>"},{"location":"user-guide/ref-architecture-eks/overview/#resources","title":"Resources","text":""},{"location":"user-guide/ref-architecture-eks/overview/#control-plane","title":"Control Plane","text":"<p>This is the primary resource which defines the cluster. We will create one cluster on each account:</p> <ul> <li> apps-devstg/us-east-1/k8s-eks</li> <li> apps-devstg/us-east-1/k8s-eks-demoapps</li> </ul> <p>Important</p> <p>In case of multiple environments hosted in the same cluster as for the one with Apps Dev and Stage, the workload isolation will be achieved through Kubernetes features such as namespaces, network policies, RBAC, and others.</p>"},{"location":"user-guide/ref-architecture-eks/overview/#data-plane","title":"Data Plane","text":"<p>We have 3 options here: </p> <ul> <li>Managed Nodes</li> <li>Fargate</li> <li>Fargate Spot </li> </ul> <p>Considerations</p> <p>Each option has its pros and cons with regard to cost, operation complexity, extensibility, customization capabilities, features, and management.</p> <p>In general we implement Managed Nodes. The main reasons being:</p> <ol> <li>They allow a high degree of control in terms of the components we can deploy and the features those components can provide to us. For instance we can run ingress controllers and service mesh, among other very customizable resources.</li> <li>AWS takes care of provisioning and lifecycle management of nodes which is one less task to worry about.</li> <li>Upgrading Kubernetes versions becomes much simpler and quicker to perform.</li> <li>We still can, at any time, start using Fargate and Fargate Spot by simply creating a profile for one or both of them, then we only need to move the workloads that we want to run on Fargate profiles of our choice.</li> </ol>"},{"location":"user-guide/ref-architecture-eks/vpc/","title":"Kubernetes AWS EKS","text":""},{"location":"user-guide/ref-architecture-eks/vpc/#network-layer-eks-network-requirements","title":"Network Layer: EKS Network Requirements","text":"<p>In this section we detail all the network design related specifications</p> <ul> <li> VPCs CIDR blocks</li> <li> Private &amp; Public Subnets IP Ranges</li> </ul>"},{"location":"user-guide/ref-architecture-eks/vpc/#considerations","title":"Considerations","text":"<p>Design considerations</p> <ul> <li> AWS EKS: Docker runs in the 172.17.0.0/16 CIDR range in Amazon EKS clusters.   We recommend that your cluster's VPC subnets do not overlap this range. Otherwise, you will   receive the following error:   <pre><code>Error: : error upgrading connection: error dialing backend: dial tcp 172.17.nn.nn:10250:\ngetsockopt: no route to host\n</code></pre>   Read more: AWS EKS network requirements</li> <li> Reserved IP Addresses The first four IP addresses and the last IP address in each subnet CIDR block are not available for you to use, and cannot be assigned to an instance. For example, in a subnet with CIDR block 10.0.0.0/24, the following five IP addresses are reserved. For more AWS VPC Subnets IP addressing</li> </ul>"},{"location":"user-guide/ref-architecture-eks/vpc/#vpcs-ip-addressing-plan-cidr-blocks-sizing","title":"VPCs IP Addressing Plan (CIDR blocks sizing)","text":"<p>Introduction</p> <p>VPCs can vary in size from 16 addresses (/28 netmask) to 65,536 addresses (/16 netmask).  In order to size a VPC correctly, it is important to understand the number, types, and sizes of workloads  expected to run in it, as well as workload elasticity and load balancing requirements. </p> <p>Keep in mind that there is no charge for using Amazon VPC (aside from EC2 charges), therefore cost  should not be a factor when determining the appropriate size for your VPC, so make sure you size your  VPC for growth.</p> <p>Moving workloads or AWS resources between networks is not a trivial task, so be generous in your  IP address estimates to give yourself plenty of room to grow, deploy new workloads, or change your  VPC design configuration from one to another. The majority of AWS customers use VPCs with a /16  netmask and subnets with /24 netmasks. The primary reason AWS customers select smaller VPC and  subnet sizes is to avoid overlapping network addresses with existing networks. </p> <p>So having AWS single VPC Design we've chosen a Medium/Small VPC/Subnet addressing plan which would probably fit a broad range variety of use cases</p>"},{"location":"user-guide/ref-architecture-eks/vpc/#networking-ip-addressing","title":"Networking - IP Addressing","text":"<p>Starting CIDR Segment (AWS EKS clusters)</p> <ul> <li> AWS EKS clusters IP Addressing calculation is presented below based on segment <code>10.0.0.0/16</code> (starts at /16 due to AWS VPC limits)</li> <li> We started from <code>10.0.0.0/16</code> and subnetted to <code>/19</code></li> <li> Resulting in Total Subnets: 8</li> <li>Number of available hosts for each subnet: 8190</li> <li>Number of available IPs (AWS) for each subnet: 8187</li> </ul> <p>Individual CIDR Segments (VPCs)</p> <p> Then each of these are /16 to /19</p> <ul> <li> <p> Considering the whole Starting CIDR Segment (AWS EKS clusters) before declared, we'll start at <code>10.0.0.0/16</code></p> <ul> <li>apps-devstg<ul> <li>1ry VPC CIDR: <code>10.0.0.0/16</code></li> <li>1ry VPC DR CIDR: <code>10.20.0.0/16</code></li> </ul> </li> <li>apps-prd<ul> <li>1ry VPC CIDR: <code>10.10.0.0/16</code></li> <li>1ry VPC DR CIDR: <code>10.30.0.0/16</code></li> </ul> </li> </ul> </li> <li> <p> Resulting in Subnets: 4 x VPC</p> <ul> <li>VPC Subnets with Hosts/Net: 16.</li> <li>Eg: apps-devstg account \u2192 us-east-1 w/ 3 AZs \u2192 3 x Private Subnets /az + 3 x Public Subnets /az<ul> <li>1ry VPC CIDR: <code>10.0.0.0/16</code>Subnets:<ul> <li>Private <code>10.0.0.0/19, 10.0.32.0/19 and 10.0.64.0/19</code></li> <li>Public <code>10.0.96.0/19, 10.0.128.0/19 and 10.0.160.0/19</code></li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"user-guide/ref-architecture-eks/vpc/#planned-subnets-per-vpc","title":"Planned Subnets per VPC","text":"<p>Having defined the initial VPC that will be created in the different accounts that were defined, we are going to create subnets in each of these VPCs defining Private and Public subnets split among different availability zones:</p> Subnet address Range of addresses Hosts Assignment 10.0.0.0/19 10.0.0.0 - 10.0.31.255 8190 1ry VPC: apps-devstg AZ: us-east-1a 10.0.32.0/19 10.0.32.0 - 10.0.63.255 8190 1ry VPC: apps-devstg AZ: us-east-1b 10.0.64.0/19 10.0.64.0 - 10.0.95.255 8190 1ry VPC: apps-devstg AZ: us-east-1c 10.0.96.0/19 10.0.96.0 - 10.0.127.255 8190 1ry VPC: apps-devstg AZ: us-east-1a 10.0.128.0/19 10.0.128.0 - 10.0.159.255 8190 1ry VPC: apps-devstg AZ: us-east-1b 10.0.160.0/19 10.0.160.0 - 10.0.191.0/255 8190 1ry VPC: apps-devstg AZ: us-east-1c 10.0.192.0/19 10.0.192.0 - 10.0.223.255 8190 1ry VPC: apps-devstg AZ: us-east-1 10.0.224.0/19 10.0.224.0 - 10.0.224.255 8190 1ry VPC: apps-devstg AZ: us-east-1 <p>Note: Additional clusters can use their own available VPC space under 10.x.0.0/16.</p> <ul> <li> <p>Subnetting reference #1 | Visual Subnet Calculator (https://www.davidc.net/)</p> </li> <li> <p>Subnetting reference #2 | IP Calculator / IP Subnetting (https://jodies.de/)</p> </li> </ul>"},{"location":"user-guide/ref-architecture-eks/vpc/#read-more","title":"Read More","text":"<p>EKS Reference Architecture Specs</p> <p>In case you would like to further understand the different tech specs and configs for this Ref Arch you could find some details like at the user-guide/Compute/K8s EKS</p>"},{"location":"user-guide/ref-architecture-vault/configs/","title":"Project Configurations","text":"<p>Config files can be found under each <code>config</code> folders</p> <ul> <li> Global config file <code>/config/common.tfvars</code>  contains global context TF variables that we inject to TF commands which are used by all sub-directories such as  <code>leverage terraform plan</code> or <code>leverage terraform apply</code> and which cannot be stored in <code>backend.tfvars</code> due to TF.</li> <li> Account config files <ul> <li><code>backend.tfvars</code>  contains TF variables that are mainly used to configure TF backend but since  <code>profile</code> and <code>region</code> are defined there, we also use them to inject those values into other TF commands.</li> <li><code>account.tfvars</code>  contains TF variables that are specific to an AWS account.</li> </ul> </li> </ul>"},{"location":"user-guide/ref-architecture-vault/configs/#aws-profile","title":"AWS Profile","text":"<ul> <li>File <code>backend.tfvars</code> will inject the profile name that TF will use to make changes on AWS.</li> <li>Such profile is usually one that relies on another profile to assume a role to get access to each corresponding account.</li> <li>Please follow to correctly setup your AWS Credentials<ul> <li>user-guide/user-guide/identities</li> <li>user-guide/user-guide/identities/credentials </li> </ul> </li> <li>Read the following page leverage doc to understand how to set up a profile to assume  a role</li> </ul>"},{"location":"user-guide/ref-architecture-vault/dir-structure/","title":"Files/Folders Organization","text":"<p>TODO</p>"},{"location":"user-guide/ref-architecture-vault/tf-state-workflow/","title":"Terraform - S3 &amp; DynamoDB for Remote State Storage &amp; Locking","text":""},{"location":"user-guide/ref-architecture-vault/tf-state-workflow/#overview","title":"Overview","text":"<p>Use this terraform configuration files to create the S3 bucket &amp; DynamoDB table needed to use Terraform Remote State Storage &amp; Locking.</p> <p></p> Figure: Terraform remote state store &amp; locking necessary AWS S3 bucket and DynamoDB table components. (Source: binbash Leverage,   \"Terraform Module: Terraform Backend\", Terraform modules registry, accessed December 3rd 2020)."},{"location":"user-guide/ref-architecture-vault/tf-state-workflow/#prerequisites","title":"Prerequisites","text":"<p>Terraform repo structure + state backend initialization</p> <ol> <li>Ensure you have <code>Leverage CLI</code> installed in your system</li> <li>Refer to Configuration Pre-requisites to understand how to set up the   configuration files required for this layer.</li> <li>Leveraged by the Infrastructure as Code (IaC) Library through the  terraform-aws-tfstate-backend module<ul> <li>/aws/base-tf-backend</li> <li>/hcp/base-tf-backend</li> </ul> </li> </ol>"},{"location":"user-guide/ref-architecture-vault/tf-state-workflow/#set-up","title":"Set up","text":"<p>Steps to initialize your tf-backend</p> <ol> <li>At the corresponding account dir,    eg: /hcp/base-tf-backend then,</li> <li>Run <code>leverage terraform init</code></li> <li>Run <code>leverage terraform plan</code>, review the output to understand the expected changes</li> <li>Run <code>leverage terraform apply</code>, review the output once more and type <code>yes</code> if you are okay with that</li> <li> <p>This should create a <code>terraform.tfstate</code> file in this directory but we don't want to push that to the repository so    let's push the state to the backend we just created</p> <ul> <li>Open <code>config.tf</code> and uncomment the following lines: <pre><code>  # backend \"s3\" {\n  #   key = \"hcp/tf-backend/terraform.tfstate\"\n  # }\n</code></pre></li> <li>Run <code>leverage terraform init</code> and type <code>yes</code> when Terraform asks if you want to import the state to the S3 backend</li> <li>Done. You can remove <code>terraform.tfstate</code> now (and also <code>terraform.tfstate.backup</code> if available)</li> </ul> </li> </ol>"},{"location":"user-guide/ref-architecture-vault/tf-state-workflow/#expected-workflow-after-set-up","title":"Expected workflow after set up","text":"<p> this tape must be updated </p>"},{"location":"user-guide/ref-architecture-vault/workflow/","title":"Workflow","text":""},{"location":"user-guide/ref-architecture-vault/workflow/#steps","title":"Steps","text":"<p>Terraform Workflow</p> <ol> <li>Make sure you've read and prepared your local development environment following the Overview base-configurations section.</li> <li>Depending in which Terraform Ref Architecture repo you are working, please review and assure you meet all the terraform aws pre-requisites or  terraform vault pre-requisites <ul> <li> Remote State</li> <li> Configuration files</li> <li> AWS Profile and credentials</li> <li> Vault token secret</li> </ul> </li> <li>Get into the folder that you need to work with (e.g. <code>2_identities</code>)</li> <li>Run <code>leverage terraform init</code></li> <li>Make whatever changes you need to make</li> <li>Run <code>leverage terraform plan</code> if you only mean to preview those changes</li> <li>Run <code>leverage terraform apply</code> if you want to review and likely apply those changes</li> </ol> <p>Note</p> <p>If desired, at step #5 you could submit a PR, allowing you and the rest of the team to  understand and review what changes would be made to your AWS Cloud Architecture components before executing  <code>leverage terraform apply</code> (<code>terraform apply</code>). This brings the huge benefit of treating changes with a GitOps oriented  approach, basically as we should treat any other code &amp; infrastructure change, and integrate it with the  rest of our tools and practices like CI/CD, in</p>"},{"location":"user-guide/ref-architecture-vault/workflow/#running-in-automation","title":"Running in Automation","text":"Figure: Running terraform with AWS in automation (just as reference)."},{"location":"user-guide/ref-architecture-vault/workflow/#read-more","title":"Read More","text":"<p>Extra resources</p> <ul> <li> Running Terraform in automation</li> </ul>"},{"location":"user-guide/troubleshooting/","title":"Troubleshooting","text":""},{"location":"user-guide/troubleshooting/#repositories","title":"Repositories","text":"<ul> <li> General Issues</li> <li> Credential Issues</li> </ul>"},{"location":"user-guide/troubleshooting/credentials/","title":"Troubleshooting credentials issues","text":"<p>Make sure you read general troubleshooting page before trying out anything else.</p>"},{"location":"user-guide/troubleshooting/credentials/#are-you-using-iam-or-sso","title":"Are you using IAM or SSO?","text":"<p>Leverage supports two methods for getting AWS credentials: IAM and SSO. We are progressively favoring SSO over IAM, only using the latter as a fallback option.</p> <p>SSO is enabled through the common.tfvars file on this line: <pre><code>sso_enabled   = true\n</code></pre> If that is set to true, then you are using SSO, otherwise it's IAM.</p>"},{"location":"user-guide/troubleshooting/credentials/#why-should-i-care-whether-i-am-using-iam-or-sso","title":"Why should I care whether I am using IAM or SSO?","text":"<p>Well, because even though both methods will try to get temporary AWS credentials, each method will use a different way to do that. In fact, Leverage relies on the AWS CLI to get the credentials and each method requires completely different commands to achieve that.</p>"},{"location":"user-guide/troubleshooting/credentials/#do-you-have-mfa-enabled","title":"Do you have MFA enabled?","text":"<p>MFA is optionally used via the IAM method. It can be enabled/disabled in the build.env file.</p> <p>Keep in mind that MFA should only be used with the IAM method, not with SSO.</p>"},{"location":"user-guide/troubleshooting/credentials/#identify-which-credentials-are-failing","title":"Identify which credentials are failing","text":"<p>Since Leverage actually relies on Terraform and, since most of the definitions are AWS resources, it is likely that you are having issues with the Terraform AWS provider, in other words, you might be struggling with AWS credentials. Now, bear in mind that Leverage can also be used with other providers such as Gitlab, Github, Hashicorp Cloud Platform, or even SSH via Ansible; so the point here is to understand what credentials are not working for you in order to focus the troubleshooting on the right suspect.</p>"},{"location":"user-guide/troubleshooting/credentials/#determine-the-aws-profile-you-are-using","title":"Determine the AWS profile you are using","text":"<p>When you are facing AWS credentials issues it's important to understand what is the AWS profile that might be causing the issue. Enabling verbose mode should help with that. The suspect profile is likely to show right above the error line and, once you have identified that, you can skip to the next section.</p> <p>If the above doesn't make the error evident yet, perhaps you can explore the following questions:</p> <ol> <li>Is it a problem with the Terraform remote state backend? The profile used for that is typically defined in the backend.tfvars file, e.g. this one, or this other one.</li> <li>Is it a problem with another profile used by the layer? Keep in mind that layers can have multiple profile definitions in order to be able to access resources in different accounts. For instance, this is a simple provider definition that uses a single profile, but here's a more complex definition with multiple provider blocks.</li> <li>Can the problematic profile be found in the AWS config file? Or is the profile entry in the AWS config file properly defined? Read the next sections for more details on that.</li> </ol>"},{"location":"user-guide/troubleshooting/credentials/#check-the-profiles-in-your-aws-config-file","title":"Check the profiles in your AWS config file","text":"<p>Once you know what AWS profile is giving you headaches, you can open the AWS config file, typically under <code>~/.aws/[project_name_here]/config</code>, to look for and inspect that profile definition.</p> <p>Things to look out for:</p> <ul> <li>Is there a profile entry in that file that matches the suspect profile?</li> <li>Are there repeated profile entries?</li> <li>Does the profile entry include all necessary fields (e.g. region, role_arn, source_profile; mfa_serial if MFA is enabled)?</li> <li>Keep in mind that profiles change depending on if you are using SSO or IAM for getting credentials so please refer to the corresponding section below in this page to find specific details about your case.</li> </ul>"},{"location":"user-guide/troubleshooting/credentials/#configure-the-aws-cli-for-leverage","title":"Configure the AWS CLI for Leverage","text":"<p>These instructions can be used when you need to test your profiles with the AWS CLI, either to verify the profiles are properly set up or to validate the right permissions were granted.</p> <p>Since Leverage stores the AWS config and credentials file under a non-default path, when using the AWS CLI you'll need to point it to the right locations: <pre><code>export AWS_CONFIG_FILE=~/.aws/[project_name_here]/config\nexport AWS_SHARED_CREDENTIALS_FILE=~/.aws/[project_name_here]/credentials\n</code></pre></p> <p>Get shell access to the Leverage Toolbox Docker Image</p> <p>Another alternative, if you can't or don't want to install the AWS CLI on your machine, is to use the one included in the Leverage Toolbox Docker image. You can access it by running <code>leverage tf shell</code></p>"},{"location":"user-guide/troubleshooting/credentials/#test-the-failing-profile-with-the-aws-cli","title":"Test the failing profile with the AWS CLI","text":"<p>Once you have narrowed down your investigation to a profile what you can do is test it. For instance, let's assume that the suspect profile is <code>le-shared-devops</code>. You can run this command: <code>aws sts get-caller-identity --profile le-shared-devops</code> in order to mimic the way that AWS credentials are generated in order to be used by Terraform, so if that command succeeds then that's a good sign.</p> <p>Note: if you use the AWS CLI installed in your host machine, you will need to configure the environment variables in the section \"Configure the AWS CLI for Leverage\" below.</p> <p>AWS CLI Error Messages</p> <p>The AWS CLI has been making great improvements to its error messages over time so it is important to pay attention to its output as it can reveal profiles that have been misconfigured with the wrong roles or missing entries.</p>"},{"location":"user-guide/troubleshooting/credentials/#regenerating-the-aws-config-or-credentials-files","title":"Regenerating the AWS config or credentials files","text":"<p>If you think your AWS config file has misconfigured or missing profile entries (which could happen due to manual editing of that file, or when AWS accounts have been added or remove) you can try regenerating it via Leverage CLI. But before you do that make sure you know which authentication method you are using: SSO or IAM.</p> <p>When using IAM, regenerating your AWS config file can be achieved through the <code>leverage credentials</code> command. Check the command documentation here.</p> <p>When using SSO, the command you need to run is <code>leverage aws configure sso</code>. Refer to that command's documentation for more details.</p>"},{"location":"user-guide/troubleshooting/credentials/#logging-out-of-your-sso-session","title":"Logging out of your SSO session","text":"<p>Seldom times, when using SSO, we have received reports of strange behaviors while trying to run Terraform commands via the Leverage CLI. For instance, users would try to run a <code>leverage tf init</code> command but would get an error saying that their session is expire; so they would try to log in via <code>leverage aws sso login</code> as expected, which would proceed normally so they would try the init command again just to get the same error as before. In these cases, which we are still investigating as they are very hard to reproduce, what has worked for most users is to log out from the SSO session via <code>leverage aws sso logout</code>, even log out from your SSO session through the AWS console running your browser, then try logging back in via <code>leverage aws sso login</code>, and then try the init command again.</p>"},{"location":"user-guide/troubleshooting/general/","title":"Troubleshooting general issues","text":""},{"location":"user-guide/troubleshooting/general/#gathering-more-information","title":"Gathering more information","text":"<p>Trying to get as much information about the issue as possible is key when troubleshooting.</p> <p>If the issue happens while you are working on a layer of the reference architecture and you are using Terraform, you can use the <code>--verbose</code> flag to try to get more information about the underlying issue. For instance, if the error shows up while running a Terraform plan command, you can enable a more verbose output like follows: <pre><code>leverage --verbose tf plan\n</code></pre></p> <p>The <code>--verbose</code> flag can also be used when you are working with the Ansible Reference Architecture: <pre><code>leverage --verbose run init\n</code></pre></p>"},{"location":"user-guide/troubleshooting/general/#understanding-how-leverage-gets-the-aws-credentials-for-terraform-and-other-tools","title":"Understanding how Leverage gets the AWS credentials for Terraform and other tools","text":"<p>Firstly, you need to know that Terraform doesn't support AWS authentication methods that require user interaction. For instance, logging in via SSO or assuming roles that require MFA. That is why Leverage made the following two design decisions in that regard:</p> <ol> <li>Configure Terraform to use AWS profiles via Terraform AWS provider and local AWS configuration files.</li> <li>Leverage handles the user interactivity during the authentication phase in order to get the credentials that Terraform needs through AWS profiles.</li> </ol> <p>So, Leverage runs simple bash scripts to deal with 2. and then passes the execution flow to Terraform which by then should have the AWS profiles ready-to-use and in the expected path.</p>"},{"location":"user-guide/troubleshooting/general/#where-are-those-aws-profiles-stored-again","title":"Where are those AWS profiles stored again?","text":"<p>They are stored in 2 files: <code>config</code> and <code>credentials</code>. By default, the AWS CLI will create those files under this path: <code>~/.aws/</code> but Leverage uses a slightly different convention, so they should actually be located in this path: <code>~/.aws/[project_name_here]/</code>.</p> <p>So, for instance, if your project name is <code>acme</code>, then said files should be found under: <code>~/.aws/acme/config</code> and <code>~/.aws/acme/credentials</code>.</p>"},{"location":"user-guide/troubleshooting/general/#ssh-reiterative-confirmation","title":"SSH reiterative confirmation","text":"<p>If you get a reiterative dialog for confirmation while running a <code>leverage terraform init</code> : <pre><code>Warning: the ECDSA host key for 'YYY' differs from the key for the IP address 'ZZZ.ZZZ.ZZZ.ZZZ'\nOffending key for IP in /root/.ssh/known_hosts:xyz\nMatching host key in /root/.ssh/known_hosts:xyw\nAre you sure you want to continue connecting (yes/no)?\n</code></pre> You may have more than 1 key associated to the <code>YYY</code> host. Remove the old or incorrect one, and the dialog should stop.</p>"},{"location":"user-guide/troubleshooting/general/#leverage-cli-cant-find-the-docker-daemon","title":"Leverage CLI can't find the Docker daemon","text":"<p>The Leverage CLI talks to the Docker API which usually runs as a daemon on your machine. Here's an example of the error: <pre><code>$ leverage tf shell\n[17:06:13.754] ERROR    Docker daemon doesn't seem to be responding. Please check it is up and running correctly before re-running the command.\n</code></pre></p>"},{"location":"user-guide/troubleshooting/general/#macos-after-docker-desktop-upgrade","title":"MacOS after Docker Desktop upgrade","text":"<p>We've seen this happen after a Docker Desktop upgrade. Defaults are changed and the Docker daemon no longer uses Unix sockets but TCP, or perhaps it does use Unix sockets but under a different path or user.</p> <p>What has worked for us in order to fix the issue is to make sure the following setting is enabled: </p> <p>Note: that setting can be accessed by clicking on the Docker Desktop icon tray, and then clicking on \"Settings...\". Then click on the \"Advanced\" tab to find the checkbox.</p>"},{"location":"user-guide/troubleshooting/general/#linux-and-docker-in-rootless-mode","title":"Linux and Docker in Rootless mode","text":"<p>The same problem might come from missing env variable <code>DOCKER_HOST</code>. <code>leverage</code> looks for Docker socket at <code>unix:///var/run/docker.sock</code> unless <code>DOCKER_HOST</code> is provided in environment. If you installed Docker in Rootless mode, you need to remember to add <code>DOCKER_HOST</code> in you rc files: <pre><code>export DOCKER_HOST=unix:///run/user/1000/docker.sock\n</code></pre> or prefix the leverage tool with the env var: <pre><code>$ DOCKER_HOST=unix:///run/user/1000/docker.sock leverage tf shell\n</code></pre></p>"},{"location":"user-guide/troubleshooting/general/#leverage-cli-fails-to-mount-the-ssh-directory","title":"Leverage CLI fails to mount the SSH directory","text":"<p>The Leverage CLI mounts the <code>~/.ssh</code> directory in order to make the pulling of private Terraform modules work. The error should look similar to the following: <pre><code>[18:26:44.416] ERROR    Error creating container:\n                        APIError: 400 Client Error for http+docker://localhost/v1.43/containers/create: Bad Request (\"invalid mount config for type \"bind\": stat /host_mnt/private/tmp/com.apple.launchd.CWrsoki5yP/Listeners: operation not supported\")\n</code></pre></p> <p>The problem happes because of the file system virtualization that is used by default and can be fixed by choosing the \"osxfs (Legacy)\" option as shown below: </p> <p>Note: that setting can be accessed by clicking on the Docker Desktop icon tray, and then clicking on \"Settings...\". The setting should be in the \"General\" tab.</p>"},{"location":"work-with-us/","title":"Work with us","text":""},{"location":"work-with-us/#customers-collaboration-methodology","title":"Customers collaboration methodology","text":"<p>What are all the steps of an engagement</p> <ul> <li> 1<sup>st</sup> Stage: Leverage Customer Tech Intro Interview<ol> <li>Complete our binbash Leverage project evaluation form     so we can get to know your project, find out if you're a good fit and get in contact with you. </li> <li>Schedule a tech intro interview meeting to understand which are your exact challenges and do a Leverage    Reference Architecture feasibility assessment.</li> </ol> </li> <li> 2<sup>nd</sup> Stage: Leverage Reference Architecture Review<ol> <li>If we can contribute, we'll execute a Mutual NDA (ours or yours), then walk your through to complete our binbash Leverage due diligence for Reference Architecture form.</li> <li>Once we completely understand your requirements we'll prepare a comprehensive proposal including the complete    \"Leverage Implementation Action Plan Roadmap\" (also known as Statement     of Work - SOW) detailing every task for the entire project. </li> <li>After you review it and we agree on the general scope, a Services Agreement (SA) is signed.</li> <li>The project kick-off day is scheduled. </li> </ol> </li> <li> 3<sup>rd</sup> Stage: Leverage Ref Architecture Implementation <ol> <li>The Roadmap (SOW) is executed, we'll send an invoice for the deposit and first Sprint starts.</li> </ol> </li> <li> 4rth Stage: binbash Leverage Support<ol> <li>During and after finishing the complete Roadmap we'll provide commercial support, maintenance    and upgrades for our work over the long term.</li> </ol> </li> </ul>"},{"location":"work-with-us/#work-methodology-intro-video","title":"Work methodology intro video","text":""},{"location":"work-with-us/#customer-support-workflow","title":"Customer Support workflow","text":""},{"location":"work-with-us/#read-more","title":"Read More","text":"<p>Related articles</p> <ul> <li> FAQs | Agreement and statement of work</li> </ul>"},{"location":"work-with-us/careers/","title":"Careers","text":""},{"location":"work-with-us/careers/#how-we-work","title":"How we work","text":"<p>binbash work culture</p> <p> Fully Remote</p> <p>binbash was founded as a remote-first company. That means you can always work from home,  a co-working place, a nice cafe, or wherever else you feel comfortable, and you'll have almost complete control over your working hours.  Why \"almost\"? Because depending on the current projects we'll require few hours of overlap between all Leverage collaborators for some specific meetings or shared sessions (pair-programming). </p> <p> Distributed Team</p> <p>Despite the fact that our collaborators are currently located in \ud83c\udde6\ud83c\uddf7 Argentina, \ud83c\udde7\ud83c\uddf7 Brazil and \ud83c\uddfa\ud83c\uddfe Uruguay, consider we are currently hiring from most countries in the time zones  between  GMT-7 (e.g. California, USA) to  GMT+2 (e.g., Berlin, Germany).</p> <p> We promote life-work balance</p> <p>Job burnout is an epidemic \ud83d\ude46, and we tech workers are especially at risk. So we'll do our best to de-stress  our workforce at binbash. In order to achieve this we offer:</p> <ul> <li>Remote work that lets you control your hours and physical location.</li> <li>Normal working hours (prime-time 9am-5pm GTM-3), in average no more than ~30-40hs per week, and we don't   work during weekends or your country of residence national holidays.</li> <li>Project management and planning that will take into consideration the time zone of all our team members.</li> <li>A flexible vacation policy where you could take 4 weeks per year away from the keyboard. If more time is needed   we could always try to arrange it for you. </li> <li>No ON-CALL rotation. We only offer support contracts with SLAs of responses on prime time business days hours   exclusively.</li> <li>You will take on big challenges, but the hours are reasonable.</li> <li>Everyone is treated fairly and with respect, but where disagreement and feedback is always welcome.</li> <li>That is welcoming, safe, and inclusive for people of all cultures, genders, and races.</li> </ul>"},{"location":"work-with-us/careers/#leverage-software-devops-engineer-profile","title":"Leverage Software / DevOps Engineer Profile","text":"<p>What You'll Work On (our tech stack)  </p> <ul> <li> <p> Infrastructure as Code (IaC) Library</p> <p>Create a collection of reusable, tested, production-ready E2E AWS oriented infrastructure modules  (e.g., VPC, IAM, Kubernetes, Prometheus, Grafana, EFK, Consul, Vault, Jenkins, etc.) using several tool and  languages: Terraform, Ansible, Helm, Dockerfiles, Python, Bash and Makefiles.</p> </li> <li> <p> Reference Architecture</p> <p>Improve, maintain, extend and update our reference architecture, which has been designed under optimal configs  for the most popular modern web and mobile applications needs. Its design is fully based on the  AWS Well Architected Framework.</p> </li> <li> <p> Open Source &amp; Leverage DevOps Tools </p> <p>Contribute to our open source projects to continue building a fundamentally better DevOps experience, including our open source modules,  leverage python CLI,  Makefiles Lib among others.        </p> </li> <li> <p> Document team knowledge</p> <p>Get siloed and not yet documented knowledge and extend the Leverage documentation, such as  creating knowledgebase articles, runbooks, and other documentation for the internal team as well as binbash Leverage customers.</p> </li> <li> <p> Customer engineering support</p> <p>While participating in business-hours only support rotations, collaborate with customer requests, teach  binbash Leverage and DevOps best-practices, help resolve problems, escalate to internal SMEs, and automate and document the solutions so that problems are mitigated for future scenarios and users.</p> </li> <li> <p> Role scope and extra points!</p> <ul> <li>Responsible for the development, maintenance, support and delivery of binbash Leverage Products.</li> <li>Client side Leverage Reference Architecture solutions implementation, maintenance and support. </li> <li>Client side cloud solutions &amp; tech management (service delivery and project task management).</li> <li>Bring Leverage recs for re-engineering, bug fixes (issues) report and improvements based on real scenario implementations.</li> <li>Mentoring, KT, PRs and team tech follow up both internally and customer facing.   </li> </ul> <p>binbash is a small, distributed startup, so things are changing all the time, and from time to time we all wear  many hats. You should expect to write lot of code, but, depending on your interests, there will also be lot of  opportunities to write blog posts, give talks, contribute to open source, go to conferences, talk with customers,  do sales calls, think through financial questions, interview candidates, mentor new hires, design products,  come up with marketing ideas, discuss strategy, consider legal questions, and all the other tasks that are part of working at a small company.</p> </li> </ul> <p>Nice to have background</p> <ul> <li>  You hate repeating and doing the same thing twice and would rather spend the time to  automate a problem away than do the same task again.</li> <li>  You have strong English communication skills and are comfortable engaging with external  customers.</li> <li>  You know how to write code across the stack (\u201cDev\u201d) and feel very comfortable with Infra as Code (\"IaC\").</li> <li>  You have experience running production software environments (\"Ops\").</li> <li>  You have a strong background in software engineering and understanding of CI/CD  (or you are working hard on it!).</li> <li>  You have a passion for learning new technologies, tools and programming languages.</li> <li>  Bonus points for a sense of humor, empathy, autonomy and curiosity.</li> <li>  Note that even if we're concerned with prior experience like AWS, Linux and Terraform,  we're more concerned with curiosity about all areas of the Leverage stack and demonstrated ability to learn quickly and go  deep when necessary.</li> </ul>"},{"location":"work-with-us/contribute/","title":"Contribute and Developing binbash Leverage","text":"<p>This document explains how to get started with developing for Leverage Reference Architecture. It includes how to build, test, and release new versions.</p>"},{"location":"work-with-us/contribute/#quick-start","title":"Quick Start","text":""},{"location":"work-with-us/contribute/#getting-the-code","title":"Getting the code","text":"<p>The code must be checked out from this same github.com repo inside the binbash Leverage Github Organization.</p> <pre><code>git clone git@github.com:binbashar/le-tf-infra-aws.git\ncd le-tf-infra-aws\ncd ..\n\ngit clone git@github.com:binbashar/le-ansible-infra.git\ncd le-ansible-infra\ncd ..\n</code></pre>"},{"location":"work-with-us/contribute/#initial-developer-environment-build","title":"Initial developer environment build","text":"<p>TODO</p>"},{"location":"work-with-us/contribute/#dependencies","title":"Dependencies","text":"<p>This guide requires you to install X v0.1 or newer.</p>"},{"location":"work-with-us/contribute/#deploying","title":"Deploying","text":"<p>To deploy the Leverage Reference Architecture onto AWS. Please check the deployment guide</p>"},{"location":"work-with-us/contribute/#testing","title":"Testing","text":"<p>To run tests, just run...</p>"},{"location":"work-with-us/contribute/#releasing","title":"Releasing","text":""},{"location":"work-with-us/contribute/#circleci-pr-auto-release-job","title":"CircleCi PR auto-release job","text":"<ul> <li>https://circleci.com/gh/binbashar/bb-devops-tf-infra-aws</li> <li>NOTE: Will only run after merged PR.</li> </ul>"},{"location":"work-with-us/faqs/","title":"Frequently Asked Questions (FAQs)","text":""},{"location":"work-with-us/faqs/#target-audience","title":"Target audience","text":"<p>Who is Leverage's target audience?</p> <ul> <li> <p> Leverage is mainly oriented to  Latam, North America and  European startup's CTOs, VPEs, Engineering Managers and/or team leads  (Software Architects / DevOps Engineers / Cloud Solutions Architects)  looking to rapidly set and host their modern web and mobile applications and systems in  Amazon Web Services (\u2705 typically in just a few weeks!). </p> </li> <li> <p> Oriented to Development leads or teams looking to solve their current AWS infrastructure and software delivery  business needs in a securely and reliably manner, under the most modern best practices.</p> </li> <li> <p> Your Entire AWS Cloud solutions based on DevOps practices will be achieved:</p> <ul> <li> Containerization</li> <li> Infrastructure as Code</li> <li> Container Orchestration (K8s) &amp; Application Services</li> <li> CI / CD</li> <li> Security, Compliance &amp; Reliability</li> <li> Cost Optimization &amp; Performance Efficiency</li> <li> Observability &amp; Monitoring</li> </ul> </li> <li> <p> Moreover, if you are looking to have the complete control of the source code, and of course be able to run it without us, such as building new Development environments and supporting your Production Cloud environments,  you're a great fit for the Leverage AWS Cloud Solutions Reference Architecture model.</p> </li> </ul> <p>And remember you could implement yourself or we could implement it for you! \ud83d\udcaa</p>"},{"location":"work-with-us/faqs/#agreement-and-statement-of-work","title":"Agreement and statement of work","text":""},{"location":"work-with-us/faqs/#project-kick-off","title":"Project Kick-Off","text":"<p> Project Kick-Off</p> <p>Once the agreement contract and NDA are signed we estimate 15 days to have the team ready to start the project following the proposed Roadmap (\u201cStatement of work\u201d) that describes at length exactly what you'll receive.</p>"},{"location":"work-with-us/faqs/#assignments-and-delivery","title":"Assignments and Delivery","text":"<p> Assignments and Delivery</p> <p>After gathering all the customer project requirements and specifications we'll adjust the Reference Architecture based on your needs. As a result we'll develop and present the Leverage Reference Architecture for AWS implementation Roadmap. </p> <p>A typical Roadmap (\u201cStatement of Work\u201d) includes a set number of Iterations (sprints).  We try to keep a narrow scope for each Iteration so that we can tightly control how hours get spent to avoid overruns. We typically avoid adding tasks to a running Iteration so that the scope does not grow.  That's also why we have an allocation for to specific long lived tasks:</p> <ul> <li>General-Task-1: DevOps and Solutions Architecture challenge, definitions, tasks (PM), reviews, issues and audit.</li> <li>General-Task-2: WEEKLY FOLLOW-UP Meeting, </li> </ul> <p>Which is work that falls outside of the current Iteration specific tasks. This is for special requests, meetings, pair programming sessions, extra documentation, etc.</p> <p>binbash will participate and review the planned tasks along the customer:</p> <ul> <li> planned roadmap features</li> <li> bug fixes</li> <li> Implementation support</li> </ul> <p>Using the relevant ticketing system (Jira) to prioritize and plan the corresponding work plan.</p>"},{"location":"work-with-us/faqs/#reports-and-invoicing","title":"Reports and Invoicing","text":"<p> Reports and Invoicing</p> <p>Weekly task reports and tasks management agile metrics. We use Toggl to track all our time by client, project, sprint, and developer. We then import these hours into Quickbooks for invoicing.</p>"},{"location":"work-with-us/faqs/#rates-and-billing","title":"Rates and Billing","text":"<p> Rates and pricing plans</p> <ul> <li> <p> Pre-paid package subscriptions: A number of prepaid hours is agreed according to the needs  of the project. It could be a \"Basic Plan\" of 40 hours per month. Or a \"Premium Plan\" of 80 hours per month (if more hours are needed it could be reviewed). When buying in  bulk there is a discount on the value of the hour. When you pay for the package you start discounting the hours from the total as they are used, and if there are unused hours left, consider that maximum 20%  could be transferred for the next month.</p> </li> <li> <p> On-demand Business Subscription: There are a certain number of hours tracked each month, as planned tasks are demanded. The total spent hours will be reported  each month. There is a monthly minimum of 40 hours per month. Support tasks maximum estimated effort should be between 80 and 120 hs / month.</p> </li> </ul> <p> Billing</p> <p>The Customer will be billed every month. Invoices are due within 15 days of issue. We accept payments via US Bank ACH, Bill.com, and Payoneer. Rates include all applicable taxes and duties as required by law.</p>"},{"location":"work-with-us/support/","title":"Support","text":""},{"location":"work-with-us/support/#leverage-reference-architecture","title":"Leverage Reference Architecture","text":"<p>Please create a Github Issue to get immediate support from the binbash Leverage Team</p>"},{"location":"work-with-us/support/#our-engineering-support-team","title":"Our Engineering &amp; Support Team","text":""},{"location":"work-with-us/support/#aws-well-architected-review","title":"AWS Well Architected Review","text":"<p>Feel free to contact us for an  AWS Well Architected Framework Review </p> <p></p> <p> Well Architected Framework Review Reference Study Case</p> <ul> <li> Operational Excellence</li> <li> Security</li> <li> Cost Optimization</li> <li> Reliability</li> <li> Performance Efficiency</li> </ul> <p>WAF Exta Material</p> <ul> <li> DevSecOps Security Audit - v0.1</li> <li> WAF Cost Optimization Checklist - v0.1</li> </ul>"},{"location":"work-with-us/support/#read-more","title":"Read More","text":"<ul> <li>How AWS Well-Architected Reviews Can Drive a Customer-First Culture</li> </ul>"},{"location":"work-with-us/releases/releases-and-versions/","title":"Leverage Product Releases","text":"<p>Dear Leveragers, We're constantly kicking with a lot of improvements and some exciting new features</p>"},{"location":"work-with-us/releases/releases-and-versions/#reference-architecture","title":"Reference Architecture","text":"<p> RELEASES</p> <ul> <li>Releases | Reference Architecture for AWS</li> <li>Releases | Reference Architecture for HCP Vault</li> </ul>"},{"location":"work-with-us/releases/releases-and-versions/#leverage-cli","title":"Leverage CLI","text":"<p> RELEASES</p> <ul> <li>Releases | <code>leverage-cli</code></li> </ul>"},{"location":"work-with-us/releases/releases-and-versions/#infrastructure-as-code-library","title":"Infrastructure as Code Library","text":"<p> RELEASES</p> <p> Releases |Terraform Leverage\u2122 Modules :</p> <ul> <li>terraform-aws-waf-owasp</li> <li>terraform-aws-cost-billing-alarm</li> <li>terraform-aws-vpc-flowlogs</li> <li>terraform-aws-cost-budget</li> <li>terraform-aws-tfstate-backend</li> <li>terraform-aws-certbot-lambda</li> <li>terraform-aws-ec2-basic-layout</li> <li>terraform-aws-natgw-notifications</li> <li>terraform-aws-guardduty-multiaccount</li> <li>terraform-aws-network-firewall</li> <li>terraform-aws-backup-notifications</li> <li>terraform-aws-rds-export-to-s3</li> </ul> <p> Releases | Terraform Community Forks Modules:</p> <ul> <li>terraform-aws-sso</li> <li>...</li> </ul> <p> Releases | Helm Leverage\u2122 Charts:</p> <ul> <li>helm-charts</li> </ul>"},{"location":"work-with-us/releases/releases-and-versions/#documentation","title":"Documentation","text":"<p> RELEASES</p> <ul> <li>Releases | binbash Leverage\u2122 Documentation</li> </ul>"},{"location":"work-with-us/releases/versions-compatibility-matrix/","title":"Leverage Releases &amp; Versioning","text":"<p>binbash Leverage\u2122 and its components intends to be backward compatible, but due to the complex ecosystems of tools we manage this is not always possible.</p> <p>It is always recommended using the latest version of the Leverage CLI with the latest versions of the Reference Architecture for AWS. In case that's not possible we always recommend pinning versions to favor stability and doing controlled updates component by component based on the below presented compatibility matrix table.</p>"},{"location":"work-with-us/releases/versions-compatibility-matrix/#compatibility-matrix","title":"Compatibility Matrix","text":"<p>If you need to know which Leverage CLI versions are compatible with which Leverage Toolbox Docker Images please refer to the Release Notes. Just look for the section called \"Version Compatibility\". Bear in mind though that, at the moment, we do not include a full compatibility table there but at least you should be able to find out what's the Toolbox Image that was used for a given release.</p> <p>If you are looking for the versions of the software included in the Toolbox Docker Image then go instead to the release notes of that repo instead.</p>"},{"location":"work-with-us/releases/versions-compatibility-matrix/#release-schedule","title":"Release Schedule","text":"<p>This project does not follow the Terraform or other release schedule. Leverage aims to provide a reliable deployment and operations experience for the binbash Leverage\u2122 Reference Architecture for AWS, and typically releases about a quarter after the corresponding Terraform release. This time allows for the Terraform project to resolve any issues introduced by the new version and ensures that we can support the latest features.</p>"},{"location":"work-with-us/releases/versions-compatibility-matrix/#read-more","title":"Read more","text":"<p>Reference links</p> <p>Consider the following extra links as reference:</p> <ul> <li> Hashicorp Terraform releases</li> <li> Amazon EKS Kubernetes release calendar</li> <li> Amazon EKS Kubernetes versions - Amazon EKS</li> </ul>"},{"location":"work-with-us/roadmap/leverage-cli/overview/","title":"Roadmap","text":"<p>Leverage CLI Product Roadmap</p> <ul> <li> 2021</li> <li> 2022</li> <li> 2023</li> </ul>"},{"location":"work-with-us/roadmap/ref-arch/cost-optimization/","title":"Cost Optimization Roadmap","text":""},{"location":"work-with-us/roadmap/ref-arch/cost-optimization/#features-functionalities","title":"Features / Functionalities \ud83d\udcb0\ud83d\udcca\ud83d\udcc9","text":"Category Tags / Labels Feature / Functionality Status Doc CostOptimization(FinOps) leveragecloud-solutions-architecturedocumentation Calculate Cloud provider costs (Cost optimization focus!) \u2705 \u274c CostOptimization(FinOps) leveragecost-optimizationbilling AWS billing alarms + AWS Budget (forecasted account cost / RI Coverage) Notifications to Slack \u2705 \u274c CostOptimization(FinOps) leveragecost-optimizationcost Activate AWS Trusted Advisor cost related results \u2705 \u274c CostOptimization(FinOps) leveragecost-optimizationlambda-nuke Setup Lambda nuke to automatically clean up AWS account resources \u2705 \u274c CostOptimization(FinOps) leveragecost-optimizationlambda-scheduler Setup lambda scheduler for stop and start resources on AWS (EC2, ASG &amp; RDS) \u2705 \u274c"},{"location":"work-with-us/roadmap/ref-arch/demo-apps/","title":"Demo Applications Roadmap","text":""},{"location":"work-with-us/roadmap/ref-arch/demo-apps/#features-functionalities","title":"Features / Functionalities \ud83d\udc68\u200d\ud83d\udcbb\ud83c\udccf\ud83d\udd79\ud83c\udfaf","text":"Category Tags / Labels Feature / Functionality Status Doc CI/CD Pipelineautomation&amp; imple leverageci-cd-pipelinedockerbuild FrontEnd Build (Demo App): set up ECR, create IAM permissions, create pipelines (Jenkins / DroneCI), set up GitHub triggers 2021 Q2 \u274c CI/CD Pipelineautomation&amp; imple leverageci-cd-pipelinedeploy FrontEnd Deploy (Demo App): create pipelines (Jenkins / Spinnaker), set up ECR/Github triggers 2021 Q2 \u274c CI/CD Pipelineautomation&amp; imple leverageci-cd-pipelinedockerbuild BackEnd Build (Demo App): set up ECR, create IAM permissions, create pipelines (Jenkins / DroneCI), set up GitHub triggers 2021 Q2 \u274c CI/CD Pipelineautomation&amp; imple leverageci-cd-pipelinedeploy BackEnd Deploy (Demo App): create pipelines (Jenkins / Spinnaker), set up ECR triggers 2021 Q2 \u274c Testing (QA) leveragetestingci-cd-pipeline Unit Testing (Demo App): Dev team needs this to run on a Jenkins/CircleCI/DroneCI/Spinnaker pipeline 2021 Q2 \u274c Testing (QA) leveragetestingci-cd-pipeline Integration Testing (Demo App): QA team needs automation to run on a Jenkins/Spinnaker pipeline for AWS Cloud QA / Stage envs. 2021 Q2 \u274c Testing (QA) leveragetestingci-cd-pipeline E2E Functional / Aceptannce (Demo App): QA team needs Smoke tests automation to run on a Jenkins/Spinnaker pipeline for AWS Cloud Stage / Prod envs. 2021 Q2 \u274c Testing (QA) leveragetestingci-cd-pipeline Static Analysis (Demo App): code complexity, dependency graph, code frequency, contributors, code activity, and so on. 2021 Q2 \u274c CI/CD Pipelineautomation&amp; imple leverageci-cd-pipelinekubernetespbe Push Button Environments (Demo App): implement ephemeral environments. 2021 Q2 \u274c"},{"location":"work-with-us/roadmap/ref-arch/operational-excellence/","title":"Operational Excellence Roadmap","text":""},{"location":"work-with-us/roadmap/ref-arch/operational-excellence/#features-functionalities","title":"Features / Functionalities \ud83d\udc68\u200d\ud83d\udcbb \ud83d\udcaf\ud83e\udd47","text":"Category Tags / Labels Feature / Functionality Status Doc CloudSolutionsArchitecture leveragecloud-solutions-architecturedocumentation DevSecOps &amp; AWS Cloud Solutions Architecture Doc \u2705 \u2705 CloudSolutionsArchitecture leveragecloud-solutions-architecturedocumentation Demo Applications architecture / Services Specifications Doc 2021 Q1 \u274c BaseInfrastructure leveragebase-infrastructuregithub Open Source Ref Architecture (le-tf-aws / le-ansible / le-tf-vault / le-tf-github) 2021 Q2 \u274c BaseInfrastructure leveragebase-infrastructurecli Leverage CLI (https://github.com/binbashar/leverage) for every Reference Architecture Repo (le-tf-aws / le-ansible / le-tf-vault / le-tf-github) 2021 Q2 \u274c BaseInfrastructure leveragebase-infrastructureorganizations Account Settings: Account Aliases and Password Policies, MFA, and enable IAM Access Analyzer across accounts. \u2705 \u274c BaseInfrastructure leveragebase-infrastructurestorage Storage: Account Enable encrypted EBS by default on all accounts; disable S3 public ACLs and policies \u2705 \u274c BaseInfrastructure leveragebase-infrastructureregion Define AWS Region / Multi-Region: keep in mind customers proximity, number of subnets, and other region limitations (https://infrastructure.aws) \u2705 \u274c BaseInfrastructure leveragebase-infrastructurevcs Terraform Github Ref Architecture / Pre-requisites: permissions to set up webhooks, create/configure repositories, create groups (Preferred SSO tool) 2021 Q2 \u274c BaseInfrastructure leveragebase-infrastructureorganizations AWS Organizations: development/stage, production, shared, security, legacy \u2705 \u2705 BaseInfrastructure leveragebase-infrastructureiam IAM: initial accounts (security users, groups, policies, roles; shared/appdevtsg/appprd DevOps role) \u2705 \u2705 BaseInfrastructure leveragebase-infrastructurevpc Networking 1: DNS, VPC, Subnets, Route Tables, NACLs, NATGW, VPC Peering or TGW \u2705 \u274c BaseInfrastructure leveragebase-infrastructurevpn Networking 2: VPN (install Pritunl, create organization, servers and users) \u2705 \u274c Kubernetes leveragekuberneteseks Production Grade Cluster: deploy EKS cluster as code \u2705 \u274c Kubernetes leveragekubernetesk8s K8s Helm + Terraform binbash Leverage repository backing all the K8s components deployment and configuration \u2705 \u274c Kubernetes leveragekubernetesmetrics Monitoring: metrics-server (metrcis for K8s HPA + Cluster AutoScaler + Prom node Exporter) + kube-state-metrics (for Grafana Dasboards) 2021 Q2 \u274c Kubernetes leveragekubernetesiamsecurity Security: Iam-authenticator, K8s RBAC (user, group and roles) \u2705 \u274c Kubernetes leveragekubernetesiam Implement AWS service accounts (IRSA for EKS) to provide IAM credentials to containers running inside a kubernetes cluster based on annotations. \u2705 \u274c Kubernetes leveragekubernetesdashboard Monitoring: K8s dashboard &amp; Weave Scope \u2705 \u274c Kubernetes leveragekubernetesingress Ingress: review, analyze and implement (alb skipper, k8s nginx, alb sigs, etc) \u2705 \u274c Kubernetes leveragekubernetesingress Load Balancing: review, analyze and implement Ingress w/ LB (AWS ALB or NLB + access logs) \u2705 \u274c Kubernetes leveragekubernetesdns Implement external-dns w/ annotations for K8s deployed Apps (https://github.com/kubernetes-sigs/external-dns) \u2705 \u274c Kubernetes leveragekubernetesservices-discovery Service Discovery: review, analyze and implement k8s native [env vars &amp; core-dns] or Consul 2021 Q3 \u274c Kubernetes leveragekubernetesservice-meshlinkerd Service Mesh: review, analyze and implement consul or linkerd2. 2021 Q3 \u274c CI/CDInfrastructure leverageci-cd-infrastructurejenkins Jenkins: installation, configuration, GitHub/GSuite/Bitbucket SSO-Auth integration \u2705 \u274c CI/CDInfrastructure leverageci-cd-infrastructurespinnaker Deployments / Jenkins or Tekton Pipelines + Argo-CD: installation, configuration, Github integration 2021 Q3 \u274c CI/CDInfrastructure leverageci-cd-infrastructuredroneci DroneCI: installation, configuration, Github integration 2021 Q4 \u274c CI/CDInfrastructure leverageci-cd-infrastructurewebhook Proxy Instance (webhooks) : installation, configuration, GitHub integration 2021 Q4 \u274c CI/CDInfrastructure leverageci-cd-infrastructureqa SonarQube: installation, configuration, GitHub/GSuite/Bitbucket SSO-Auth integration 2021 Q4 \u274c ApplicationsInfrastructure leverageapps-infrastructuredockercontainers Automate and containerized app environments by using docker images, enabling consistent experience in local environment and dev/stage/prod Cloud environments. \u2705 \u274c ApplicationsInfrastructure leverageapps-infrastructuredockercontainers Automate and containerized app environments by using docker images, enabling consistent experience in local environment and dev/stage/prod Cloud environments. \u2705 \u274c ApplicationsInfrastructure leverageapps-infrastructuredatabaserds Databases: RDS (most likely AWS Aurora MySql, single db for all microservices at first - Prod dedicated instance considering new auto-scaling feature and read-replicas) + RDS Proxy (if needed for high Cx N\u00b0) - Compliance: Consider using SSL/TLS to Encrypt a Connection to a DB Instance \u2705 \u274c ApplicationsInfrastructure leverageapps-infrastructurequeuesqs Queues: SQS (recommended for background workers and some microservices). Redis (AWS ElasticCache) / RabbitMQ (K8s Containerzied). \u2705 \u274c ApplicationsInfrastructure leverageapps-infrastructurestorages3 Storage: S3 (for the FrontEnd statics) \u2705 \u274c ApplicationsInfrastructure leverageapps-infrastructurecloudfrontcdn Caching: CloudFront (for the FrontEnd) w/ access logs \u2705 \u274c ApplicationsInfrastructure leverageapps-infrastructurecacheredis CacheLayer: AWS Elasticache (Memcache or Redis) \u2705 \u274c"},{"location":"work-with-us/roadmap/ref-arch/overview/","title":"Roadmap","text":"<p>Leverage AWS Cloud Solutions Reference Architecture Features / Functionalities per category</p> <ul> <li> Operational Excellence</li> <li> Reliability &amp; Performance</li> <li> Security</li> <li> Cost Optimization</li> <li> Demo Applications</li> </ul>"},{"location":"work-with-us/roadmap/ref-arch/reliability-performance/","title":"Reliability Performance Roadmap","text":""},{"location":"work-with-us/roadmap/ref-arch/reliability-performance/#features-functionalities","title":"Features / Functionalities \ud83d\ude80\u23f2\ud83d\udcca","text":"Category Tags / Labels Feature / Functionality Status Doc MonitoringMetrics&amp; Alerting leveragemonitoring-metrics-alertingprometheusgrafana Metrics: install and configure Prometheus (NodeExporter for EC2 / BlackBox exporter / Alert Monitroing), install and configure Grafana (K8s Plugin + Prometheus int + CloudWatch int) \u2705 \u274c MonitoringMetrics&amp; Alerting leveragemonitoring-metrics-alertinggrafanacloudwatch Metrics: Grafana + AWS Cloudwatch integrations config (https://github.com/monitoringartist/grafana-aws-cloudwatch-dashboards) 2021 Q2 \u274c MonitoringMetrics&amp; Alerting leveragemonitoring-metrics-alertingapm APM: review, analyze and implement (New Relic, DataDog, ElasticAPM Agent/Server) 2021 Q2 \u274c MonitoringMetrics&amp; Alerting leveragemonitoring-metrics-alertingdocumentation Define and document reference notification/escalation procedure \u2705 \u274c MonitoringMetrics&amp; Alerting leveragemonitoring-metrics-alerting Alerting: configure AlertsManager, Elastalert (optimized logs rotation when using it from docker image), PagerDuty, Slack according to the procedure above 2021 Q2 \u274c MonitoringMetrics&amp; Alerting leveragemonitoring-metrics-alertingprometheus Monitor Infra Tool Instances (WebHook Proxy, Jenkins, Vault, Pritunl, Prometheus, Grafana, etc) / implement monitoring via Prometheus + Grafana or Another Solution \u2705 \u274c MonitoringDistributedTracing leveragemonitoring-tracingjaeger Distributed Tracing Instrumentation: review, analyze and implement to detect and improve transactions performance and svs dep analysis (jaeger, instana, lightstep, AWS X-Ray, etc) 2021 Q3 \u274c MonitoringLogging leveragemonitoring-logsefk Logging / EFK - use separate indexes per K8s components &amp; apps/svc for each custer/env (segregating dev/stg from prd) + enable ES monitoring w/ X-Pack + configure curator to rotate indices + tool to improve index mgmt 2021 Q2 \u274c Performance&amp; Optimization leverageperformance-optimizationci-cd-pipeline Load Testing: set up and run continuous load tests pipelines (Jenkins) to determine and improve apps/services capacity through time (apapche ab, gatling, iperf, locust, taurus, BlazeMeter and https://github.com/loadimpact/k6) 2021 Q3 \u274c Performance&amp; Optimization leverageperformance-optimizationci-cd-pipeline Performance Testing (stress, soak, spike, etc): set up and run continuous performance tests pipelines (Jenkins) to measure performance through time (apapche ab, gatling, iperf, locust, taurus and BlazeMeter) 2021 Q3 \u274c Performance&amp; Optimization leverageperformance-optimizationkubernetes Tune K8S nodes (EC2 family type, size and AWS ASG -&gt; K8s HPA + Cluster AutoScaler ) 2021 Q3 \u274c Performance&amp; Optimization leverageperformance-optimizationkubernetes Tune K8S requests and limits per namespace (CPU and RAM) / https://github.com/FairwindsOps/goldilocks  2021 Q2 \u274c Performance&amp; Optimization leverageperformance-optimizations3 S3: ensure each bucket is using the proper storage types and persistence (automate mv these objs into lower $ storage tier w/ Life Cycle Policies or w/ S3 Intelligent-Tiering) \u2705 \u274c DisasterRecovery leveragedisaster-recoverybackup AWS Backup Service: RDS, EC2 (AMI), EBS, Dynamo, EFS, SFx, Storage Gw \u2705 \u274c DisasterRecovery leveragedisaster-recoverybackup Replication: S3 (CRR cross-region replication or SRR same-region replication) \u2705 \u274c DisasterRecovery leveragedisaster-recoverybackup Replication: VPC / Compute / Database (CRR cross-region replication) \u2705 \u274c DisasterRecovery leveragedisaster-recoverybackupkubernetes Backup and migrate Kubernetes applications and their persistent volumes w/ https://velero.io/  2021 Q3 \u274c DisasterRecovery leveragedocumentationdisaster-recovery Review: Disaster recovery plan, missing resources, RTO / RPO, level of automation 2021 Q4 \u274c DisasterRecovery leveragedocumentationdisaster-recovery Improve Plan: create a plan to improve the existing recovery plan and determine implementation phases 2021 Q4 \u274c DisasterRecovery leveragedocumentationdisaster-recovery Execute Plan: implement according to the plan, review/measure and iterate 2021 Q4 \u274c"},{"location":"work-with-us/roadmap/ref-arch/security/","title":"Security Roadmap","text":""},{"location":"work-with-us/roadmap/ref-arch/security/#features-functionalities","title":"Features / Functionalities \ud83d\udd10\u2705","text":"Category Tags / Labels Feature / Functionality Status Doc Security &amp;Audit (SecOps) leveragesecurity-auditpasswords Team Password Management: review, analyze and implement (passbolt, bitwarden, 1password, etc) \u2705 \u274c Security &amp;Audit (SecOps) leverageci-cd-infrastructuresecrets Secrets Management: review, analyze and implement Hashicorp vault 2021 Q1 \u274c Compliance(SecOps) leveragesecrets aws-vault implementation 2021 Q1 \u274c Security &amp;Audit (SecOps) leveragesecurity-auditguardduty AWS Guarduty (Cross-Org with Master and member accounts setup + Trusted IP Lists and Threat IP Lists / Creation + Deletion of Filters for your GuardDuty findings to avoid false possitives + CloudWatch Rule to Lambda/ Cw-Metrics w/ CloudWatch Dashboard) \u2705 \u274c Security &amp;Audit (SecOps) leveragesecurity-auditinspector AWS Inspector (w/ Ansible aws-inpector galaxy role per EC2) 2021 Q3 \u274c Security &amp;Audit (SecOps) leveragesecurity-auditcloudtrail AWS CloudTrail w/ CloudWatch Dashboard + Alarms (include RootLogin) to Slack \u2705 \u274c Security &amp;Audit (SecOps) leveragesecurity-auditfirewall AWS Firewall Manager (cross-org WAF + Shield integrated with ALBs, CloudFront and/or API-GW + Cross-org Sec group audit) \u2705 \u274c Security &amp;Audit (SecOps) leveragesecurity-auditvpc AWS VPC Flow Logs \u2705 \u274c Security &amp;Audit (SecOps) leveragesecurity-audit ScoutSuite / Prowler: set up continuous, automated reports for each account (Evaluate the use of CloudMapper) 2021 Q2 \u274c Security &amp;Audit (SecOps) leveragesecurity-auditusers Infra DevOps Tools OS Layer ( OS security updates and patches, root user config, ssh port, fail2ban ) \u2705 \u274c Compliance(SecOps) leveragesecurity-auditcompliance AWS Config: implement audit controls (evaluate automatic remediation if applicable) \u2705 \u274c Compliance(SecOps) leveragesecurity-auditcompliance AWS Security Hub: implement audit controls 2021 Q3 \u274c Compliance(SecOps) leveragesecurity-auditcompliance AWS Trusted Advisor: Review automated Costs Optimization, Performance, Security, Fault Tolerance and Service Limits audit results. \u2705 \u274c Compliance(SecOps) leveragesecurity-auditcompliancekubernetes Kubernetes Audit: implement on the clusters: KubeAudit, Kube-Bench, Kube-Hunter and Starboard. 2021 Q2 \u274c Security &amp;Audit (SecOps) leveragesecurity-auditci-cd-pipeline Security and Vulnerability static code analysis (code dependencies): implement tools to continuously analyze and report vulnerabilities, automated reports (OWASP, bandit, snyk, HawkEye scanner, yarn audit, etc) 2021 Q2 \u274c Security &amp;Audit (SecOps) leveragesecurity-auditdocker Containers: implement tools to continuously analyze and report on vulnerabilities (docker-bench-security, snyk, aquasecurity microscanner, docker-bench, aws ecr scan) \u2705 \u274c Security &amp;Audit (SecOps) leveragesecurity-audit Review and Fix all snyk high sev findings 2021 Q2 \u274c Security &amp;Audit (SecOps) leveragesecurity-audit Security and cost analysis in the CI PR automated process (le-tf-aws / le-ansible / le-tf-vault / le-tf-github) 2021 Q1 \u274c Security &amp;Audit (SecOps) leveragesecurity-audit Comply with AWS Security Maturity Roadmap 2021 2021 Q2 \u274c Compliance(SecOps) leveragesecurity-auditcompliance Certified compliant by the Center for Internet Security (CIS)end-to-end CIS-compliant Reference Architecture (get compliance out of the box) 2021 Q2 \u274c Security &amp;Audit (SecOps) leveragesecurity-auditdashboard Centralized DevSecOps Tools and Audit Report Dashboard 2021 Q3 \u274c"}]}